[def list [func list [.. entries] entries]]

[def-with-meta defmacro
  [[extern host kv-map]
    [quote no-eval-args] [i32 1]
    [quote eval-result] [i32 1]]
  [func defmacro [name parameters .. bodies]
    [list [quote def-with-meta] name
      [quote
        [[extern host kv-map]
          [quote no-eval-args] [i32 1]
          [quote eval-result] [i32 1]]]
      [[extern host concat] [list [quote func] name parameters] bodies]]]]

[defmacro defn [name parameters .. bodies]
  [list [quote def] name
    [[extern host concat] [list [quote func] name parameters] bodies]]]

[defmacro defexpr [name parameters .. bodies]
  [list [quote def-with-meta] name
    [quote [[extern host kv-map] [quote no-eval-args] [i32 1]]]
    [[extern host concat] [list [quote func] name parameters] bodies]]]

[def quote-word [quote quote]]

[defn mk-quote [form] [list quote-word form]]

[defmacro def-extern [name type]
  [list [quote def-with-meta] name
    [list [quote [extern host kv-map]] [quote [quote type]] [mk-quote type]]
    [list [quote extern] [quote host] name]]]

[def-extern concat [type-scheme [a] [func [.. [list a]] [list a]]]]

[def-extern size [type-scheme [a] [func [[list a]] i32]]]
[def-extern at [type-scheme [a] [func [[list a] i32] a]]]

[defmacro comment [.. -]
  [quote [let []]]]

[def-extern concat-words [func [word word] word]]

[defn def-instruction-fn [def-name inst-name]
  [list [quote def] def-name
    [list [quote extern] [quote instructions] inst-name]]]

[defmacro def-instruction [def-name inst-name] [def-instruction-fn def-name inst-name]]

[defmacro def-bin-i32-inst [name] [def-instruction-fn name [concat-words [quote i32.] name]]]

[def-bin-i32-inst add]
[def-bin-i32-inst lt-s]

[def -2 [i32 -2]]
[def -1 [i32 -1]]
[def 0  [i32 0]]
[def 1  [i32 1]]
[def 2  [i32 2]]
[def 3  [i32 3]]
[def 4  [i32 4]]

[defn inc [x] [add x 1]]

[def-bin-i32-inst sub]
[def-bin-i32-inst mul]

[defn dec [x] [sub x 1]]

[defn not [c] [if c 0 1]]

[def-bin-i32-inst eq]

[defn is-zero [x] [eq x 0]]

[def-instruction i32.bitwise-and i32.and]

[defn is-odd [x] [i32.bitwise-and x 1]]

[defn is-even [x] [not [is-odd x]]]

[defn is-negative [x] [lt-s x 0]]

[defn min [a b] [if [lt-s a b] a b]]
[defn max [a b] [if [lt-s a b] b a]]

[defn first [l] [at l 0]]
[defn second [l] [at l 1]]
[defn third [l] [at l 2]]
[defn fourth [l] [at l 3]]
[defn last [l] [at l -1]]

[defmacro do [.. forms]
  [concat [quote [let []]] forms]]

[defmacro when [cond .. forms]
  [list
    [quote if] cond
    [concat [quote [let []]] forms]]]

[defmacro when-not [cond .. forms]
  [list
    [quote if] cond
    [quote [let []]]
    [concat [quote [let []]] forms]]]

[defmacro if-not [cond false-form true-form]
  [list
    [quote if] cond
    true-form
    false-form]]

[def-extern is-word [func [form] i32]]

[def-extern mutable-list-of-size [type-scheme [a] [func [i32] [mutable-list a]]]]
[def-extern set-array [type-scheme [a] [func [[mutable-list a] i32 a] []]]]
[def-extern freeze-mutable-list [type-scheme [a] [func [[mutable-list a]] [tuple]]]]

[defn quote-list [lmsg]
  [let [s [size lmsg]
        msg [mutable-list-of-size [inc s]]]
    [set-array msg 0 [quote list]]
    [loop [i 0]
      [when [lt-s i s]
        [set-array msg [inc i] [let [e [at lmsg i]] [if [is-word e] [mk-quote e] e]]]
        [continue i [inc i]]]]
    [freeze-mutable-list msg]
    msg]]

[def-extern log [func [list] []]]

[def unreachable [extern instructions unreachable]]

[defmacro assert [cond .. lmsg]
  [list [quote if] cond
    [quote [let []]]
    [list [quote let] [quote []]
      [list [quote log] [quote-list lmsg]]
      [quote [unreachable]]]]]

[defmacro logq [.. lmsg]
  [list [quote log] [quote-list lmsg]]]

[defmacro logq-abort [.. lmsg]
  [list [quote let] [list]
    [list [quote log] [quote-list lmsg]]
    [quote [unreachable]]]]

[defn identity [x] x]

[defmacro ifs [.. clauses]
  [let [s [size clauses]]
    [assert [is-odd s] ifs requires an odd number of arguments]
    [loop [i [dec s] res [at clauses -1]]
      [if [eq i 0]
        res
        [continue
          i [sub i 2]
          res [list [quote if] [at clauses [sub i 2]] [at clauses [dec i]] res]]]]]]

[defmacro and [.. clauses]
  [let [s [size clauses]]
    [if [is-zero s]
      [quote [i32 1]]
      [loop [i [dec s]
             res [at clauses -1]]
        [if [eq i 0]
          res
          [continue
            i [dec i]
            res [list [quote if] [at clauses [dec i]] res [quote [i32 0]]]]]]]]]

[def-extern atom [type-scheme [a] [func [a] [atom a]]]]

[def word-counter [atom 0]]

[def-extern char-code-to-word [func [i32] word]]

[def-instruction i32.rem-s i32.rem-s]
[def-instruction i32.div-s i32.div-s]

[def-extern growable-list [type-scheme [a] [func [] [growable-list a]]]]
[def-extern clone-growable-to-frozen-list [type-scheme [a] [func [[growable-list a]] [list a]]]]
[def-extern push [type-scheme [a] [func [[growable-list a] a] []]]]

[defn int-to-word [n]
  [if [is-zero n]
    [quote 0]
    [let [l [growable-list]]
      [if [is-negative n]
        [do
          [loop [i n]
            [when i
              [push l [char-code-to-word [add [i32 48] [sub 0 [i32.rem-s i [i32 10]]]]]]
              [continue i [i32.div-s i [i32 10]]]]]
          [push l [quote -]]]
        [loop [i n]
          [when i
            [push l [char-code-to-word [add [i32 48] [i32.rem-s i [i32 10]]]]]
            [continue i [i32.div-s i [i32 10]]]]]]
      [loop [res [first l] i 1]
        [if [lt-s i [size l]]
          [continue res [concat-words [at l i] res] i [inc i]]
          res]]]]]

[def-extern char-code-at [func [word i32] i32]]

[defmacro word-to-char-code [w] [list [quote i32] [int-to-word [char-code-at w 0]]]]

[def-bin-i32-inst le-s]

[defn is-between-inclusive [lower c upper]
  [and [le-s lower c] [le-s c upper]]]

[def-extern word-byte-size [func [word] i32]]

[defn dec-word-to-int [w]
  [loop [i 0 res 0]
    [if [lt-s i [word-byte-size w]]
      [let [cc [char-code-at w i]]
        [assert [is-between-inclusive [word-to-char-code 0] cc [word-to-char-code 9]] dec-word-to-int expects a decimal word]
        [continue res [add [mul res [i32 10]] [sub cc [word-to-char-code 0]]] i [inc i]]]
      res]]]

[def-extern atom-get [type-scheme [a] [func [[atom a]] a]]]
[def-extern atom-set [type-scheme [a] [func [[atom a] a] [tuple]]]]

[defn genword []
  [let [c [atom-get word-counter]]
    [atom-set word-counter [inc c]]
    [concat-words [quote genword] [int-to-word c]]]]

[defmacro or [.. clauses]
  [let [s [size clauses]]
    [if [is-zero s]
      [quote [i32 0]]
      [loop [i [dec s]
             res [at clauses -1]]
        [if [eq i 0]
          res
          [continue
            i [dec i]
            res
            [let [w [genword]]
              [list [quote let] [list w [at clauses [dec i]]]
                [list [quote if] w w res]]]]]]]]]

[def-extern is-list [func [form] i32]]

[defmacro if-let [binding true-form false-form]
  [assert [is-list binding] if-let requires a list as the first argument]
  [assert [eq 2 [size binding]] if-let requires a list of size 2 as the first argument]
  [let [v [first binding]
        cond [second binding]
        tmp-word [genword]]
    [assert [is-word v] if-let requires a word as the first element of the first argument]
    [list [quote let] [list tmp-word cond]
      [list [quote if] tmp-word [list [quote let] [list v tmp-word] true-form] false-form]]]]

[defn eq-word [a b]
  [and [is-word a] [is-word b]
    [let [sa [word-byte-size a] sb [word-byte-size b]]
      [and
        [eq sa sb]
        [loop [i 0]
          [if [lt-s i sa]
            [if [eq [char-code-at a i] [char-code-at b i]]
              [continue i [inc i]]
              0]
            1]]]]]]

[defn eq-form [a b]
  [or
    [eq-word a b]
    [and [is-list a] [is-list b]
      [let [sa [size a]]
        [and [eq sa [size b]]
          [loop [i 0]
            [if [lt-s i sa]
              [if [recur [at a i] [at b i]]
                [continue i [inc i]]
                0]
              1]]]]]]]

[defn for-func [iw start increment end forms]
  [assert [lt-s 0 increment] for-func increment must be positive]
  [let [ew [genword]]
    [list
      [quote let] [list ew end]
      [list
        [quote loop] [list iw start]
        [list [quote if]
          [list [quote lt-s] iw ew]
          [concat [quote [let []]] forms
            [list [list [quote continue] iw [list [quote add] iw [list [quote i32] [int-to-word increment]]]]]]]]]]]

[defmacro for [iw start end .. forms]
  [for-func iw start [i32 1] end forms]]

[defmacro for-pair [iw start end .. forms]
  [for-func iw start [i32 2] end forms]]

[defmacro for-each [element-var collection .. forms]
  [assert [is-word element-var] for-each requires a word as the first argument]
  [let [iteration-var [genword]
        col-var [genword]
        col-size-var [genword]]
    [list
      [quote let] [list col-var collection col-size-var [list [quote size] col-var]]
      [list
        [quote loop] [list iteration-var [quote [i32 0]]]
        [list [quote if]
          [list [quote lt-s] iteration-var col-size-var]
          [concat [quote [let]]
            [list [list element-var [list [quote at] col-var iteration-var]]]
            forms
            [list [list [quote continue] iteration-var [list [quote add] iteration-var [quote [i32 1]]]]]]]]]]]

[defmacro list-map [element-var collection form]
  [assert [is-word element-var] list-map requires a word as the first argument]
  [let [iteration-var [genword]
        col-var [genword]
        col-size-var [genword]
        new-col-var [genword]]
    [list
      [quote let] [list col-var collection
                        col-size-var [list [quote size] col-var]
                        new-col-var [list [quote mutable-list-of-size] col-size-var]]
      [list
        [quote loop] [list iteration-var [quote [i32 0]]]
        [list [quote if]
          [list [quote lt-s] iteration-var col-size-var]
          [concat [quote [let]]
            [list [list element-var [list [quote at] col-var iteration-var]]]
            [list [list [quote set-array] new-col-var iteration-var form]]
            [list [list [quote continue] iteration-var [list [quote add] iteration-var [quote [i32 1]]]]]]]]
      [list [quote freeze-mutable-list] new-col-var]
      new-col-var]]]

[defn half [x] [i32.div-s x 2]]

[def-extern transient-kv-map [func [] transient-kv-map]]
[def-extern set-kv-map [type-scheme [a] [func [transient-kv-map word a] []]]]
[def-extern freeze-kv-map [func [transient-kv-map] []]]

[defmacro kv-mapq [.. entries]
  [let [s [size entries]
        n-of-pairs [half s]
        ml [mutable-list-of-size [add 4 n-of-pairs]]
        tmp-word [genword]]
    [assert [is-even s] kv-map requires an even number of arguments]
    [set-array ml 0 [quote let]]
    [set-array ml 1 [list tmp-word [quote [transient-kv-map]]]]
    [for-pair i 0 s
      [set-array ml [add 2 [half i]]
        [let [k [at entries i]]
          [list [quote set-kv-map] tmp-word [if [is-word k] [mk-quote k] k] [at entries [inc i]]]]]]
    [set-array ml [add 2 n-of-pairs] [list [quote freeze-kv-map] tmp-word]]
    [set-array ml [add 3 n-of-pairs] tmp-word]
    ml]]

[defmacro kv-map-id [.. entries]
  [let [s [size entries]
        ml [mutable-list-of-size [add 4 s]]
        tmp-word [genword]]
    [set-array ml 0 [quote let]]
    [set-array ml 1 [list tmp-word [quote [transient-kv-map]]]]
    [for i 0 s
      [set-array ml [add 2 i]
        [let [k [at entries i]]
          [list [quote set-kv-map] tmp-word [mk-quote k] k]]]]
    [set-array ml [add 2 s] [list [quote freeze-kv-map] tmp-word]]
    [set-array ml [add 3 s] tmp-word]
    ml]]

[def-extern has [func [kv-map word] i32]]

[defmacro hasq [m w]
  [list [quote has] m [mk-quote w]]]

[def-extern get [type-scheme [a] [func [kv-map word] a]]]

[defmacro getq [m w]
  [list [quote get] m [mk-quote w]]]

[defn try-get [m k]
  [if [has m k]
    [get m k]
    0]]

[defmacro try-getq [m w]
  [list [quote try-get] m [mk-quote w]]]

[defmacro setq [m w v]
  [list [quote set-kv-map] m [mk-quote w] v]]

[defn is-empty [form]
  [eq 0 [size form]]]

[defn push-all [mut-list list]
  [for-each e list [push mut-list e]]]

[def-extern keys [func [kv-map] [list word]]]

[defn assoc [m k v]
  [let [new [transient-kv-map]]
    [for-each k [keys m]
      [set-kv-map new k [get m k]]]
    [set-kv-map new k v]
    [freeze-kv-map new]
    new]]

[def empty-kv-map [kv-mapq]]

[defn slice [l start end]
  [assert [is-list l] slice expects list]
  [assert [not [is-negative start]] negative start index]
  [assert [not [is-negative end]] negative end index]
  [let [s [sub end start]]
    [if [lt-s s 1]
      [quote []]
      [let [ml [mutable-list-of-size s]]
        [for i start end
          [set-array ml [sub i start] [at l i]]]
        [freeze-mutable-list ml]
        ml]]]]

[def ascii-dash [i32 45]]

[defn is-decimal [dw]
  [let [s [word-byte-size dw]]
    [loop [i [if [eq [char-code-at dw 0] ascii-dash] 1 0]]
      [if [lt-s i s]
        [let [c [char-code-at dw i]]
          [if [and [le-s [i32 48] c] [le-s c [i32 57]]]
            [continue i [inc i]]
            0]]
        1]]]]

[defn is-non-negative-decimal [dw]
  [let [s [word-byte-size dw]]
    [loop [i 0]
      [if [lt-s i s]
        [let [c [char-code-at dw i]]
          [if [and [le-s [i32 48] c] [le-s c [i32 57]]]
            [continue i [inc i]]
            0]]
        1]]]]

[def-extern meta [func [form] kv-map]]
[def-extern var-get [func [var] any]]
[def-extern var-meta [func [var] any]]
[def-extern apply [func [[func] [list any]] any]]
[def-extern word-with-meta [func [word kv-map] word]]
[def-extern list-with-meta [func [list kv-map] list]]
[def-extern is-atom [type-scheme [a] [func [[atom a]] i32]]]
[def-extern is-identical [type-scheme [a] [func [a a] i32]]]
