[load check.wuns]

[type wat-type-basic []
  [union
    [i32]
    [i64]
    [f32]
    [f64]]]

[type wat-inst []
  [union
    [i32.const word]
    [drop wat-inst]
    [instructions [list wat-inst]]]]

[type output-func []
  [record
    [name word]
    [parameters [list [pair word wat-type-basic]]]
    [result [list wat-type-basic]]
    [body wat-inst]]]

[type wat-output []
  [record
    [funcs [atom [linked-list output-func]]]]]

[defn empty-wat-output []
  [wat-output [atom [linked-list/nil]]]]

[type translate-context []
  [record
    [check-context check-context]
    ]]

[defn empty-translate-context []
  [translate-context [make-global-context]]]

[defn get-form-type [form]
  [match form
    [form/word w] [logq-abort not implemented]
    [form/list l]
    [do
      [assert [not [is-empty l]] expected non-empty list]
      [match [first l]
        [form/word w]
        [ifs
          [eq-word w [word i32]]
          [list [wat-type-basic/i32]]

          [eq-word w [word do]]
          [if [eq [size l] 1]
            [list]
            [get-form-type [last l]]]

          [logq-abort not implemented]]

        [form/list l]
        [logq-abort not implemented]]]]]

[defn translate-form [tctx lctx form]
  [match form
    [form/word w]
    [do
      [log w]
      [log [meta form]]
      [logq-abort translate-form word not implemented]]

    [form/list l]
    [do
      [assert [not [is-empty l]] expected non-empty list]
      [match [first l]
        [form/word w]
        [ifs
          [eq-word w [word i32]]
          [wat-inst/i32.const [form-to-word [second l]]]

          [eq-word w [word do]]
          [wat-inst/instructions
            [concat
              [list-map f [slice l 1 [dec [size l]]]
                [let-do [types [get-form-type f]]
                  [logq func]
                  [log f]
                  [[func go [i]
                    [if i
                      [wat-inst/drop [go [dec i]]]
                      [translate-form tctx lctx f]]]
                    [size types]]]]
              [if [eq [size l] 1]
                [list]
                [list [translate-form tctx lctx [last l]]]]]]

          [eq-word w [word def]]
          [logq-abort no defs in top level]

          [logq-abort translate-top unknown special form]]

        [form/list l]
        [logq-abort not implemented]]]]]

[defn translate-top [tctx output form]
  [match form
    [form/word w] [logq-abort not implemented]
    [form/list l]
    [do
      [assert [not [is-empty l]] expected non-empty list]
      [match [first l]
        [form/word w]
        [ifs
          [eq-word w [word def]]
          [do
            [assert [eq [size l] 3] expected 3 elements]
            [let-do [name [second l]
                     body [form-to-list [third l]]
                     head-body [first body]
                     rest-body [rest body]]
              [ifs
                [eq-form head-body [quote func]]
                [do
                  [assert [eq [size rest-body] 3] expected 3 elements found]
                  [let-do [params [form-to-list [second rest-body]]
                           func-body [third rest-body]
                           lctx [transient-kv-map]
                           output-params [list]
                           output-results [get-form-type func-body]]
                    [for i 0 [size params]
                      [logq-abort not implemented]
                      [set-kv-map lctx [at params i] i]]
                    [push
                      [wat-output/funcs output]
                      [output-func
                        [form-to-word name]
                        output-params
                        output-results
                        [translate-form tctx lctx func-body]]]]]

                [logq-abort translate-top unknown special form]]]]

          [logq-abort translate-top unknown special form]]

        [form/list l]
        [logq-abort not implemented]]]]]

[defn translate-intermediate [top-forms]
  [let-do [o [empty-wat-output]
           tctx [empty-translate-context]]
    [for-each f top-forms
      [translate-top tctx o f]]
    o]]

[def ascii-line-feed [i32 10]]
[def ascii-space [i32 32]]
[def ascii-double-quote [i32 34]]
[def ascii-dollar [i32 36]]
[def ascii-left-paren [i32 40]]
[def ascii-right-paren [i32 41]]
[def ascii-equal [i32 61]]
[def ascii-backslash [i32 92]]

[type printer []
  [record
    [bytes [atom byte-array]]
    [index [atom i32]]]]

[defn empty-printer [init-capacity]
  [printer [atom [byte-array init-capacity]] [atom 0]]]

[defn printer-to-byte-array [p]
  [let-do
    [ci [atom-get [printer/index p]]
     cb [atom-get [printer/bytes p]]
     trimmed [byte-array ci]]
    [for i 0 ci
      [byte-array-set trimmed i [byte-array-get cb i]]]
    trimmed]]

[defn print-byte [printer byte]
  [let-do [ia [printer/index printer]
           i [atom-get ia]
           ba [printer/bytes printer]
           a [atom-get ba]]
    [assert [lt-s i [byte-array-size a]] printer buffer overflow]
    [byte-array-set a i byte]
    [atom-set [printer/index printer] [inc i]]]]

[defn print-word [printer word]
  [for i 0 [word-byte-size word]
    [print-byte printer [char-code-at word i]]]]

[type wat []
  [union
    [word word]
    [dollar word]
    [dqstring word]
    [seq [list wat]]
    [list [list wat]]]]

[defn print-wat [printer wat]
  [match wat
    [wat/word w] [print-word printer w]
    [wat/dollar w] [do [print-byte printer ascii-dollar] [print-word printer w]]
    [wat/dqstring w] [do [print-byte printer ascii-double-quote] [print-word printer w] [print-byte printer ascii-double-quote]]
    [wat/seq l]
      [do
        [when-not [is-empty l]
          [print-wat printer [first l]]
          [for i 1 [size l]
            [print-byte printer ascii-space]
            [print-wat printer [at l i]]]]]
    [wat/list l]
      [do
        [print-byte printer ascii-left-paren]
        [when-not [is-empty l]
          [print-wat printer [first l]]
          [for i 1 [size l]
            [print-byte printer ascii-space]
            [print-wat printer [at l i]]]]
        [print-byte printer ascii-right-paren]]
      ]]

[defn wat-list [.. l] [wat/list l]]

[defn wat-type-basic-to-word [t]
  [match t
    [wat-type-basic/i32] [word i32]
    [wat-type-basic/i64] [word i64]
    [wat-type-basic/f32] [word f32]
    [wat-type-basic/f64] [word f64]]]

[defn wat-concat [.. l] [wat/list [concat-lists l]]]

[defn wat-inst-to-out [i]
  [match i
    [wat-inst/i32.const w]
    [wat-concat
      [list [wat/word [word i32.const]] [wat/word w]]]

    [wat-inst/drop inst]
    [wat-concat
      [list [wat/word [word drop]] [wat-inst-to-out inst]]]

    [wat-inst/instructions insts]
    [wat/seq
      [list-map inst insts [wat-inst-to-out inst]]]]]

[defn print-wat-output [printer output]
  [for-each of [clone-growable-to-frozen-list [wat-output/funcs output]]
    [print-wat printer
      [wat-concat
        [list
          [wat/word [word func]]
          [wat/dollar [output-func/name of]]
          [wat-list [wat/word [word export]] [wat/dqstring [output-func/name of]]]]
        [list-map p [output-func/parameters of]
          [wat-list [wat/word [word param]] [wat/dollar [pair/fst p]] [wat/word [wat-type-basic-to-word [pair/snd p]]]]]
        [list
          [wat-concat
            [list [wat/word [word result]]]
            [list-map rt [output-func/result of] [wat/word [wat-type-basic-to-word rt]]]]]
        [list
          [wat-inst-to-out [output-func/body of]]]]]]]

[defn generate-wat [output]
  [let-do [p [empty-printer [i32 80]]]
    [print-wat-output p output]
    [let-do [ba [printer-to-byte-array p]]
      [byte-array-log-as-string ba]
      [wasm-instantiate [byte-array-to-wasm-module [wat-to-byte-array ba]]]]]]

[defn translate-to-wat [forms]
  [generate-wat [translate-intermediate forms]]]
