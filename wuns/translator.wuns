[def list [func list [.. entries] entries]]
[type form []
  [union
    [word word]
    [list [list form]]]]

[def form-word form/word]
[def form-list form/list]

[def flist [func flist [.. elements] [form-list elements]]]

[def defmacro
  [macro defmacro [name params .. bodies]
    [flist [quote def] name
      [flist [quote macro] name params [form-list [[extern host concat] [list [quote do]] bodies]]]]]]

[defmacro def-extern [name type]
  [flist [quote def] name
    [flist [quote type-anno]
      [flist [quote extern] [quote host] name]
      type]]]

[def-extern log [type-scheme [a] [func [.. a] [tuple]]]]

[def-extern concat [type-scheme [a] [func [[list a] [list a]] [list a]]]]

[defmacro let-do [bindings .. forms]
  [flist [quote let] bindings [form-list [concat [list [quote do]] forms]]]]

[defmacro defn [name params .. bodies]
  [flist [quote def] name [flist [quote func] name params [form-list [concat [list [quote do]] bodies]]]]]

[defmacro defexpr [name params .. bodies]
  [flist [quote def] name [flist [quote fexpr] name params [form-list [concat [list [quote do]] bodies]]]]]

[def-extern concat-lists [type-scheme [a] [func [[list [list a]]] [list a]]]]

[defn form-concat [.. list-forms]
  [form-list [concat-lists list-forms]]]

[defn mk-quote [form] [flist [quote quote] form]]

[def-extern size [type-scheme [a] [func [[list a]] i32]]]

[def-extern at [type-scheme [a] [func [[list a] i32] a]]]

[defmacro comment [.. -]
  [quote [do]]]

[def-extern concat-words [func [word word] word]]

[defn def-instruction-fn [def-name inst-name]
  [flist
    [quote def]
    def-name
    [flist [quote intrinsic] [quote instructions] inst-name]]]

[defmacro def-instruction [def-name inst-name] [def-instruction-fn def-name inst-name]]

[def unreachable [intrinsic instructions unreachable]]

[defn form-to-word [form]
  [match form
    [form-word w] w
    [unreachable]]]

[defmacro def-bin-i32-inst [name] [def-instruction-fn name [form-word [concat-words [word i32.] [form-to-word name]]]]]

[def-bin-i32-inst add]
[comment maybe introduce booleans instead of i32s for comparisons]
[def-bin-i32-inst lt-s]

[def -2 [i32 -2]]
[def -1 [i32 -1]]
[def 0  [i32 0]]
[def 1  [i32 1]]
[def 2  [i32 2]]
[def 3  [i32 3]]
[def 4  [i32 4]]

[defn inc [x] [add x 1]]

[def-bin-i32-inst sub]
[def-bin-i32-inst mul]

[defn dec [x] [sub x 1]]

[defn not [c] [if c 0 1]]

[def-bin-i32-inst eq]

[defn is-empty [form]
  [eq 0 [size form]]]

[defn is-zero [x] [eq x 0]]

[def-instruction i32.bitwise-and i32.and]

[defn is-odd [x] [i32.bitwise-and x 1]]

[defn is-even [x] [not [is-odd x]]]

[defn is-negative [x] [lt-s x 0]]

[defn min [a b] [if [lt-s a b] a b]]
[defn max [a b] [if [lt-s a b] b a]]

[defn first [l] [at l 0]]
[defn second [l] [at l 1]]
[defn third [l] [at l 2]]
[defn fourth [l] [at l 3]]
[defn last [l] [at l -1]]

[defmacro when [cond .. forms]
  [flist
    [quote if] cond
    [form-concat [list [quote do]] forms]
    [quote [do]]]]

[defmacro when-not [cond .. forms]
  [flist
    [quote if] cond
    [quote [do]]
    [form-concat [list [quote do]] forms]]]

[defmacro if-not [cond false-form true-form]
  [flist
    [quote if] cond
    true-form
    false-form]]

[type mutable-list [a]
  [union]]

[defn is-word [form] [match form [form-word x] 1 0]]

[def-extern list-init-func [type-scheme [a] [func [i32 [func [i32] a]] [list a]]]]

[defn list-map-fn [f l]
  [list-init-func [size l] [func list-map-fn-f [i] [f [at l i]]]]]

[def-extern list-reverse [type-scheme [a] [func [[list a]] [list a]]]]

[defn quote-list [lmsg]
  [form-list
    [concat
      [list [quote list]]
      [list-map-fn
        [func f [e]
          [match e
            [form/word w] [mk-quote e]
            [form/list l] e]]
        lmsg]]]]

[defmacro assert [cond .. lmsg]
  [flist [quote if] cond
    [quote [do]]
    [flist [quote do]
      [flist [quote log] [quote-list lmsg]]
      [quote [unreachable]]]]]

[defmacro logq [.. lmsg]
  [flist [quote log] [quote-list lmsg]]]

[defmacro logq-abort [.. lmsg]
  [flist [quote do]
    [flist [quote log] [quote-list lmsg]]
    [quote [unreachable]]]]

[defn identity [x] x]

[def-extern meta [func [form] form]]

[defmacro ifs [.. clauses]
  [let [s [size clauses]]
    [do
      [assert [is-odd s] ifs requires an odd number of arguments]
      [[func go [i res]
        [if [eq i 0]
          res
          [go
            [sub i 2]
            [flist [quote if] [at clauses [sub i 2]] [at clauses [dec i]] res]]]]
        [dec s]
        [at clauses -1]]]]]

[comment and relies on there only being one falsy value [i32 0]
        it will not return any other falsy value as or returns the first truthy argument]
[defmacro and [.. clauses]
  [let [s [size clauses]]
    [if [is-zero s]
      [quote [i32 1]]
      [[func go [i res]
        [if [eq i 0]
          res
          [go
            [dec i]
            [flist [quote if] [at clauses [dec i]] res [quote [i32 0]]]]]]
         [dec s]
         [at clauses -1]]]]]

[def-extern atom-get [type-scheme [a] [func [[atom a]] a]]]
[def-extern atom-set [type-scheme [a] [func [[atom a] a] [tuple]]]]

[defn inc-atom [atom]
  [let [prev-val [atom-get atom]]
    [do
      [atom-set atom [inc prev-val]]
      prev-val]]]

[def word-counter [atom 0]]

[def-extern char-code-to-word [func [i32] word]]

[def-instruction i32.rem-s i32.rem-s]
[def-instruction i32.div-s i32.div-s]

[def-extern int-to-word [func [i32] word]]

[defn i32-to-form [i]
  [flist [quote i32] [form-word [int-to-word i]]]]

[def-extern char-code-at [func [word i32] i32]]

[defmacro word-to-char-code [w]
  [i32-to-form [char-code-at [form-to-word w] 0]]]

[def-bin-i32-inst le-s]

[defn is-between-inclusive [lower c upper]
  [and [le-s lower c] [le-s c upper]]]

[def-extern word-byte-size [func [word] i32]]

[defn genword []
  [form-word [concat-words [word genword] [int-to-word [inc-atom word-counter]]]]]

[defmacro or [.. clauses]
  [let [s [size clauses]]
    [if [is-zero s]
      [quote [i32 0]]
      [[func go [i res]
        [if [eq i 0]
          res
          [go
            [dec i]
            [let [w [genword]]
              [flist [quote let] [flist w [at clauses [dec i]]]
                [flist [quote if] w w res]]]]]]
       [dec s]
       [at clauses -1]]]]]

[defn form-to-list [form]
  [match form
    [form-list l] l
    [do
      [log [quote [form-to-list requires a list as its argument]] form]
      [unreachable]]]]

[defn is-list [form]
  [match form
    [form-list l] 1
    0]]

[type option [a]
  [union
    [none]
    [some a]]]

[def none option/none]
[def some option/some]

[defmacro if-let [binding-form true-form false-form]
  [match binding-form
    [form-list binding]
    [do
      [assert [eq 2 [size binding]] if-let bindings should have exactly two elements]
      [let-do [v [first binding] cond [second binding]]
        [assert [is-word v] if-let-option requires a word as the first element of the first argument]
        [flist [quote match]
          cond
          [flist [quote option/some] v] true-form
          false-form]]]
    [logq-abort if-let requires a list as the first argument]]]

[defmacro when-let [binding-form .. forms]
  [match binding-form
    [form-list binding]
    [do
      [assert [eq 2 [size binding]] when-let bindings should have exactly two elements]
      [let-do [v [first binding] cond [second binding]]
        [assert [is-word v] when-let-option requires a word as the first element of the first argument]
        [flist [quote match]
          cond
          [flist [quote option/some] v] [form-concat [list [quote do]] forms]
          [quote [do]]]]]
    [logq-abort when-let requires a list as the first argument]]]

[defn eq-word [wa wb]
  [let [sa [word-byte-size wa] sb [word-byte-size wb]]
    [and
      [eq sa sb]
      [[func go [i]
        [if [lt-s i sa]
          [if [eq [char-code-at wa i] [char-code-at wb i]]
            [go [inc i]]
            0]
          1]] 0]]]]

[defn eq-form-word [fa fb]
  [match fa
    [form-word wa]
    [match fb
      [form-word wb] [eq-word wa wb]
      0]
    0]]

[defn eq-form [a b]
  [or
    [eq-form-word a b]
    [and [is-list a] [is-list b]
      [let [la [form-to-list a]
            lb [form-to-list b]
            sa [size la]]
        [and [eq sa [size lb]]
          [[func go [i]
            [if [lt-s i sa]
              [if [eq-form [at la i] [at lb i]]
                [go [inc i]]
                0]
              1]] 0]]]]]]

[defn for-func [iw start increment end forms]
  [assert [lt-s 0 increment] for-func increment must be positive]
  [let [ew [genword]
        loopw [genword]]
    [flist
      [quote let] [flist ew end]
      [flist
        [flist
          [quote func] loopw [flist iw]
          [flist [quote if]
            [flist [quote lt-s] iw ew]
            [form-concat
              [list [quote do]]
              forms
              [list [flist loopw [flist [quote add] iw [i32-to-form increment]]]]]
            [quote [do]]]]
        start]]]]

[defmacro for [iw start end .. forms]
  [for-func iw start [i32 1] end forms]]

[defmacro for-3 [iw start end .. forms]
  [for-func iw start [i32 3] end forms]]

[defmacro for-pair [iw start end .. forms]
  [for-func iw start [i32 2] end forms]]

[defmacro for-each [element-var collection .. forms]
  [assert [is-word element-var] for-each requires a word as the first argument]
  [let [iteration-var [genword]
        col-var [genword]
        col-size-var [genword]
        loopw [genword]]
    [flist
      [quote let] [flist col-var collection
                        col-size-var [flist [quote size] col-var]]
      [flist
        [flist
          [quote func] loopw [flist iteration-var]
          [flist [quote if]
            [flist [quote lt-s] iteration-var col-size-var]
            [form-concat
              [list [quote let]]
              [list [flist element-var [flist [quote at] col-var iteration-var]]]
              [list
                [form-concat [list [quote do]]
                  forms
                  [list [flist loopw [flist [quote add] iteration-var [quote [i32 1]]]]]]]]
            [quote [do]]]]
        [quote [i32 0]]]]]]

[defmacro list-map [element-var collection form]
  [assert [is-word element-var] list-map requires a word as the first argument]
  [flist [quote list-map-fn]
    [flist [quote func] [genword] [flist element-var] form]
    collection]]

[defn half [x] [i32.div-s x 2]]

[type transient-kv-map [k v] [union]]

[def-extern transient-kv-map [type-scheme [k v] [func [] [transient-kv-map k v]]]]
[def-extern set-kv-map [type-scheme [k v] [func [[transient-kv-map k v] k v] [tuple]]]]

[defn mk-word [w] [flist [quote word] w]]

[def-extern has [type-scheme [k v] [func [[transient-kv-map k v] k] i32]]]

[defmacro hasq [m w]
  [flist [quote has] m [mk-word w]]]

[def-extern get [type-scheme [k v] [func [[transient-kv-map k v] k] v]]]

[defmacro getq [m w]
  [flist [quote get] m [mk-word w]]]

[defn try-get [m k]
  [if [has m k]
    [some [get m k]]
    [none]]]

[defmacro try-getq [m w]
  [flist [quote try-get] m [mk-word w]]]

[defmacro setq [m w v]
  [flist [quote set-kv-map] m [flist [quote word] w] v]]

[comment
  maybe we should be able to specify in the type-scheme that a is of pointer type
  we do not want to be able to compare functions with it
  and do not want to compare i32s with it]
[def-extern is-identical [type-scheme [a] [func [a a] i32]]]

[def-extern slice [type-scheme [a] [func [[list a] i32 i32] [list a]]]]

[defn rest [l] [slice l 1 [size l]]]

[def read-file
  [type-anno
    [extern interpreter read-file]
    [func [word] [list form]]]]

[type byte-array [] [union]]
[def-extern byte-array [func [i32] byte-array]]
[def-extern byte-array-size [func [byte-array] i32]]
[def-extern byte-array-get [func [byte-array i32] i32]]
[def-extern byte-array-set [func [byte-array i32 i32] [tuple]]]
[def-extern byte-array-log-as-string [func [byte-array] [tuple]]]
[def-extern wat-to-byte-array [func [byte-array] byte-array]]
[type wasm-module [] [union]]
[def-extern byte-array-to-wasm-module [func [byte-array] wasm-module]]
[type wasm-instance [] [union]]
[def-extern wasm-instantiate [func [wasm-module] wasm-instance]]
[def-extern wasm-call-export [type-scheme [a] [func [wasm-instance word [list a]] [list a]]]]

[type function-kind []
  [union
    [ctor]
    [func]
    [macro]
    [fexpr]]]

[type
  type-var-kind []
  [union
    [linked type]
    [word word]]

  type-var []
  [record
    [kind [atom type-var-kind]]
    [level [atom i32]]]

  func-type []
  [record
    [params [list type]]
    [rest-param-opt [option type]]
    [result type]
    [kind function-kind]]

  inst-type []
  [union
    [func func-type]
    [apply word [list type]]]

  type []
  [union
    [var type-var]
    [inst inst-type]]]

[defn make-type-list [type-name type-args] [type/inst [inst-type/apply type-name type-args]]]

[defn make-type [type-name .. type-args] [make-type-list type-name type-args]]

[def type-i32 [make-type [word i32]]]
[def type-f64 [make-type [word f64]]]

[def type-word [make-type [word word]]]

[def type-form [make-type [word form]]]

[defn type-list [elem-type] [make-type [word list] elem-type]]
[defn type-atom [elem-type] [make-type [word atom] elem-type]]

[def type-empty-tuple [make-type [word tuple]]]

[defn type-func [params opt-rest-param result]
  [type/inst [inst-type/func [func-type params opt-rest-param result [function-kind/func]]]]]

[def i32i32-to-i32 [type-func [list type-i32 type-i32] [none] type-i32]]

[defn type-ctor [params result]
  [type/inst [inst-type/func [func-type params [none] result [function-kind/ctor]]]]]

[defn get-type-var-kind [type-var]
  [atom-get [type-var/kind type-var]]]

[defn set-type-var-kind-to-type [type-var type]
  [atom-set [type-var/kind type-var] [type-var-kind/linked type]]]

[comment normalize a type make type variable point directly to the linked type - if any]
[defn normalize-type [t0]
  [match t0
    [type/var tv]
    [match [get-type-var-kind tv]
      [type-var-kind/word w] t0
      [type-var-kind/linked linked-t]
      [let-do [t2 [normalize-type linked-t]]
        [set-type-var-kind-to-type tv t2]
        t2]]
    t0]]

[defn member-type-var-list [set t]
  [[func member-type-var-list-go [i]
    [if [lt-s i [size set]]
      [if [is-identical [at set i] t]
        1
        [member-type-var-list-go [inc i]]]
      0]] 0]]

[type linked-list [a]
  [union
    [nil]
    [cons a [linked-list a]]]]

[defn linked-list-to-list [ll]
  [match ll
    [linked-list/nil] [list]
    [linked-list/cons hd tl] [concat [list hd] [linked-list-to-list tl]]]]

[defn push [list-ref element]
  [atom-set list-ref [linked-list/cons element [atom-get list-ref]]]]

[defn growable-list. [] [atom [linked-list/nil]]]

[defn clone-growable-to-frozen-list [atom-linked-list]
  [list-reverse [linked-list-to-list [atom-get atom-linked-list]]]]

[defn free-type-vars [t]
  [let-do
    [set [atom [linked-list/nil]]
     is-member
     [func is-member [tv]
      [[func is-member-go [ll]
        [match ll
          [linked-list/nil] 0
          [linked-list/cons hd tl]
            [if [is-identical hd tv]
              1
              [is-member-go tl]]]]
        [atom-get set]]]
     go
     [func go [t]
      [let [nt [normalize-type t]]
        [match nt
          [type/var tv]
          [when-not [is-member tv]
            [push set tv]]

          [type/inst inst-type]
          [match inst-type
            [inst-type/func ft]
            [do
              [for-each param [func-type/params ft]
                [go param]]
              [when-let [rest [func-type/rest-param-opt ft]]
                [go rest]]
              [go [func-type/result ft]]]

            [inst-type/apply type-name type-args]
            [for-each arg type-args
              [go arg]]]]]]]
    [go t]
    [clone-growable-to-frozen-list set]]]

[defn prune-level [max-level tvs]
  [for-each tv tvs
    [let [tvla [type-var/level tv]]
      [atom-set tvla [min [atom-get tvla] max-level]]]]]

[defn get-type-var-level [tv]
  [atom-get [type-var/level tv]]]

[defn link-var-to-type [type-var type]
  [let-do
    [level [get-type-var-level type-var]
     fvs [free-type-vars type]]
    [comment todo report instead of assert]
    [assert [not [member-type-var-list fvs type-var]] type-var occurs in type]
    [prune-level level fvs]
    [set-type-var-kind-to-type type-var type]]]

[defn unify [outer-t1 outer-t2]
  [let-do
    [errors [atom [linked-list/nil]]
     push-unify-error
     [func push-unify-error [msg] [push errors [form-to-list msg]]]
     go
     [func go [t1 t2]
      [let [nt1 [normalize-type t1]
            nt2 [normalize-type t2]]
        [match nt1
          [type/var tv1]
          [match nt2
            [type/var tv2]
            [when-not [is-identical tv1 tv2]
              [if [lt-s [get-type-var-level tv1] [get-type-var-level tv2]]
                [link-var-to-type tv1 nt2]
                [link-var-to-type tv2 nt1]]]

            [type/inst inst-type2]
            [link-var-to-type tv1 nt2]]

          [type/inst inst-type1]
          [match nt2
            [type/var tv2]
            [link-var-to-type tv2 nt1]

            [type/inst inst-type2]
            [match inst-type1
              [inst-type/func ft1]
              [match inst-type2
                [inst-type/func ft2]
                [let-do [type-args1 [func-type/params ft1] type-args2 [func-type/params ft2]
                        s1 [size type-args1] s2 [size type-args2]]
                  [for i 0 [min s1 s2]
                    [go [at type-args1 i] [at type-args2 i]]]
                  [when [not [eq s1 s2]]
                    [if [lt-s s1 s2]
                      [if-let [rest1 [func-type/rest-param-opt ft1]]
                        [for i s1 s2
                          [go rest1 [at type-args2 i]]]
                        [push-unify-error [quote [not unifiable - different number of parameters]]]]
                      [if-let [rest2 [func-type/rest-param-opt ft2]]
                        [for i s2 s1
                          [go [at type-args1 i] rest2]]
                        [push-unify-error [quote [not unifiable - different number of parameters]]]]]]
                  [go [func-type/result ft1] [func-type/result ft2]]]

                [push-unify-error [quote [not unifiable - different types 0]]]]

              [inst-type/apply type-name1 type-args1]
              [match inst-type2
                [inst-type/apply type-name2 type-args2]
                [if [eq-word type-name1 type-name2]
                  [if [eq [size type-args1] [size type-args2]]
                    [for i 0 [size type-args1]
                      [go [at type-args1 i] [at type-args2 i]]]
                    [push-unify-error [quote [not unifiable - different number of type arguments]]]]
                  [do
                    [push-unify-error [quote [not unifiable - different types]]]]]

                [do
                  [push-unify-error [quote [not unifiable - different types]]]]]]]]]]]
    [go outer-t1 outer-t2]
    [clone-growable-to-frozen-list errors]]]

[type report-message []
  [record
    [message [list form]]
    [form form]]]

[type type-def []
  [record
    [arity i32]
    [param-map [transient-kv-map word type]]
    [result-type type]]]

[type check-type-scheme []
  [record
    [type-vars [list type-var]]
    [type type]]]

[type evaluation-context [] [union]]

[def make-eval-context
  [type-anno
    [extern interpreter make-context]
    [func [] [evaluation-context]]]]

[type check-context []
  [record
    [messages [atom [linked-list report-message]]]
    [def-var-types [transient-kv-map word check-type-scheme]]
    [type-var-counter [atom i32]]
    [types [transient-kv-map word type-def]]
    [eval-context [evaluation-context]]
    [form-expansions [transient-kv-map form form]]
    [type-annotations [transient-kv-map form type]]]]

[defn make-global-context []
  [check-context
    [atom [linked-list/nil]]
    [transient-kv-map]
    [atom 0]
    [transient-kv-map]
    [make-eval-context]
    [transient-kv-map]
    [transient-kv-map]]]

[defn annotate [gctx form type]
  [set-kv-map [check-context/type-annotations gctx] form type]
  type]

[defn report-fn [gctx message form]
  [push [check-context/messages gctx] [report-message [form-to-list message] form]]]

[defmacro report-when [cond form .. lmsg]
  [flist [quote when] cond
    [flist [quote report-fn] [quote gctx] [flist [quote quote] [form/list lmsg]] form]]]

[defmacro report-when-not [cond form .. lmsg]
  [flist [quote when-not] cond
    [flist [quote report-fn] [quote gctx] [flist [quote quote] [form/list lmsg]] form]]]

[defmacro report [form .. lmsg]
  [flist [quote report-fn] [quote gctx] [flist [quote quote] [form/list lmsg]] form]]

[defn unify-report [gctx t1 t2 .. forms]
  [let [form [first forms]
        errors [unify t1 t2]]
    [for-each error errors
      [report-fn gctx [form/list error] form]]]]

[defn int-to-type-var-name [i]
  [if [lt-s i [i32 26]]
    [char-code-to-word [add [i32 97] i]]
    [concat-words
      [int-to-type-var-name [i32.div-s i [i32 26]]]
      [char-code-to-word [add [i32 97] [i32.rem-s i [i32 26]]]]]]]

[defn make-type-var [kind level]
  [type-var [atom kind] [atom level]]]

[defn generate-fresh-type-var-atom [counter-atom level]
  [type/var [make-type-var [type-var-kind/word [int-to-type-var-name [inc-atom counter-atom]]] level]]]

[defn generate-fresh-type-var [gctx level]
  [generate-fresh-type-var-atom [check-context/type-var-counter gctx] level]]

[defmacro report-generate [form .. lmsg]
  [flist [quote do]
    [flist [quote report-fn] [quote gctx] [quote-list lmsg] form]
    [quote [generate-fresh-type-var gctx 0]]]]

[defn unify-call [gctx level func-type arg-types form]
  [let-do [t-res [generate-fresh-type-var gctx level]
        t-func [type-func arg-types [none] t-res]]
    [unify-report gctx func-type t-func form]
    t-res]]

[defn mk-empty-type-scheme [type] [check-type-scheme [list] type]]

[defn generalize [current-level type]
  [let-do [tvs [atom [linked-list/nil]]
           ftvs [free-type-vars type]]
    [for-each tv ftvs
      [if [lt-s current-level [get-type-var-level tv]]
        [push tvs tv]
        [comment [logq tv not generalized [identity tv]]]
        ]]
    [let-do [ftvs [clone-growable-to-frozen-list tvs]]
      [check-type-scheme ftvs type]]]]

[defn generalize-top [type] [generalize 0 type]]

[type pair [a b] [record [fst a] [snd b]]]

[defn try-get-assoc-identical [assoc-list var]
  [[func try-get-assoc-identical-go [i]
    [if [lt-s i [size assoc-list]]
      [let [p [at assoc-list i]]
        [if [is-identical var [pair/fst p]]
          [some [pair/snd p]]
          [try-get-assoc-identical-go [inc i]]]]
      [none]]]
    0]]

[defn copy-type [subst-map t]
  [match t
    [type/var tv]
    [if-let [subst-type [try-get-assoc-identical subst-map tv]]
      subst-type
      [match [get-type-var-kind tv]
        [type-var-kind/word w] t
        [type-var-kind/linked linked-t] [copy-type subst-map linked-t]]]

    [type/inst inst-type]
    [match inst-type
      [inst-type/func ft]
      [type/inst
        [inst-type/func
          [func-type
            [list-map param [func-type/params ft] [copy-type subst-map param]]
            [if-let [rest [func-type/rest-param-opt ft]]
              [some [copy-type subst-map rest]]
              [none]]
            [copy-type subst-map [func-type/result ft]]
            [func-type/kind ft]]]]

      [inst-type/apply type-name type-args]
      [type/inst [inst-type/apply type-name [list-map arg type-args [copy-type subst-map arg]]]]]]]

[defn specialize-type-scheme [gctx level scheme]
  [let [subst-assoc-list [list-map tv [check-type-scheme/type-vars scheme] [pair tv [generate-fresh-type-var gctx level]]]]
    [copy-type subst-assoc-list [check-type-scheme/type scheme]]]]

[type
  local-context []
  [record
    [vars [transient-kv-map word check-type-scheme]]
    [outer [option local-context]]
    [first-form form]]]

[defn make-local-context [var-values lctx-opt first-form]
  [some [local-context var-values lctx-opt first-form]]]

[defn try-get-local-var-type [local-ctx var-name]
  [[func go [cur-ctx]
    [if-let [type [try-get [local-context/vars cur-ctx] var-name]]
      [some type]
      [if-let [outer [local-context/outer cur-ctx]]
        [go outer]
        [none]]]] local-ctx]]

[defn try-get-var-type [gctx local-ctx-opt var-name]
  [if-let [ltype [if-let [local-ctx local-ctx-opt]
                    [try-get-local-var-type local-ctx var-name]
                    [none]]]
    [some ltype]
    [try-get [check-context/def-var-types gctx] var-name]]]

[type parameters []
  [record
    [regular-params [list form]]
    [rest-param-opt [option form]]]]

[defn parse-parameter-list [params]
  [if [and [lt-s 1 [size params]] [eq-form-word [at params -2] [quote ..]]]
    [parameters [slice params 0 [sub [size params] 2]] [some [last params]]]
    [parameters params [none]]]]

[defn try-get-form-word-option [form]
  [match form
    [form-word w] [some w]
    [none]]]

[defn check-type-arity [gctx type-name n-of-given-type-args]
  [if-let [type-name-word [try-get-form-word-option type-name]]
    [ifs
      [eq-word type-name-word [word tuple]]
      [report-when [eq n-of-given-type-args 1] type-name tuple type expects zero or multiple arguments]

      [or
        [eq-word type-name-word [word i32]]
        [eq-word type-name-word [word f64]]
        [eq-word type-name-word [word word]]]
      [report-when-not [eq n-of-given-type-args 0] type-name atomic type expects no arguments]

      [eq-word type-name-word [word atom]]
      [report-when-not [eq n-of-given-type-args 1] type-name atom type expects one argument]

      [eq-word type-name-word [word list]]
      [report-when-not [eq n-of-given-type-args 1] type-name list type expects one argument]

      [if-let [type [try-get [check-context/types gctx] type-name-word]]
        [let [arity [type-def/arity type]]
          [report-when-not [eq n-of-given-type-args arity]
            type-name type expects [identity arity] arguments]]
        [report type-name not a known type]]]
    [logq-abort check-builtin-type-arity type-name not word [identity type-name]]]]

[defn try-get-word-report [gctx form]
  [match form
    [form/word w] [some w]
    [do
      [report form expected a word]
      [none]]]]

[defn try-get-list-report [gctx form]
  [match form
    [form/list l] l
    [do
      [report form expected a list]
      [list]]]]

[comment given a type such as [func [i32 i32] i32] instantiates to a type-scheme]
[defn instantiate-annotated-type [gctx type-var-env outer-syntax-type]
  [[func go [syntax-type]
    [match syntax-type
      [form/word w]
      [switch w
        [word i32]
        type-i32

        [word f64]
        type-f64

        [word word]
        type-word

        [word form]
        type-form

        [if-let [t [try-get type-var-env w]]
          t
          [do
            [check-type-arity gctx syntax-type 0]
            [make-type w]]]]

      [form/list elements]
      [let-do [s-form [size elements]
               n-of-args [dec s-form]]
        [assert [not [eq s-form 0]] type-scheme expects a non-empty list]
        [if-let [w [try-get-word-report gctx [first elements]]]
          [if [eq-word w [word func]]
            [do
              [report-when-not [eq n-of-args 2] syntax-type expects 2 arguments a parameter list and a return type]
              [let [params [second elements]
                    params-list [try-get-list-report gctx params]
                    params-parsed [parse-parameter-list params-list]
                    reg-params [parameters/regular-params params-parsed]
                    internal-params
                    [list-map param reg-params
                      [do
                        [go param]]]
                    result [third elements]]
                [type-func
                  internal-params
                  [if-let [rest-param [parameters/rest-param-opt params-parsed]]
                    [some [go rest-param]]
                    [none]]
                  [go result]]]]

            [do
              [check-type-arity gctx [first elements] n-of-args]
              [make-type-list w
                [list-map e [rest elements] [go e]]]]]

          [logq-abort instantiate-annotated-type unknown type]]]]]
            outer-syntax-type
            ]]

[def empty-kv-map [transient-kv-map]]

[defn instantiate-annotated-type-or-scheme [gctx level syntax-type]
  [match syntax-type
    [form/word w]
    [instantiate-annotated-type gctx empty-kv-map syntax-type]

    [form/list elements]
    [let-do [s-form [size elements]
             n-of-args [dec s-form]]
      [assert [not [eq s-form 0]] expects a non-empty list]
      [if-let [w [try-get-word-report gctx [first elements]]]
        [if [eq-word w [word type-scheme]]
          [do
            [report-when-not [eq n-of-args 2] syntax-type type-scheme expects 2 arguments]
            [let-do [type-var-env [transient-kv-map]]
              [for-each tv [try-get-list-report gctx [second elements]]
                [when-let [tvw [try-get-word-report gctx tv]]
                  [set-kv-map type-var-env tvw [generate-fresh-type-var gctx level]]]]
              [instantiate-annotated-type gctx type-var-env [third elements]]]]
          [instantiate-annotated-type gctx empty-kv-map syntax-type]]
        [instantiate-annotated-type gctx empty-kv-map syntax-type]]]]]

[defn is-builtin-type [word]
  [or [eq-word word [word i32]]
      [eq-word word [word f64]]
      [eq-word word [word word]]

      [eq-word word [word tuple]]

      [eq-word word [word list]]
      [eq-word word [word atom]]

      [eq-word word [word func]]
      [eq-word word [word type-scheme]]]]

[defn try-get-ctor [t]
  [match t
    [type/var tv]
    [none]

    [type/inst inst-type]
    [match inst-type
      [inst-type/func ft]
      [match [func-type/kind ft]
        [function-kind/ctor] [some ft]
        [none]]

      [inst-type/apply type-name type-args]
      [none]]]]

[defn is-syntactic-value [form]
  [match form
    [form/word w] 1
    [form/list l]
    [do
      [assert [not [is-empty l]] value expects a non-empty list]
      [match [first l]
        [form/word fw]
          [switch fw
            [word atom] 0

            [word i32] 1
            [word f64] 1
            [word word] 1
            [word quote] 1

            [word extern] 1

            [word func] 1
            [word macro] 1
            [word fexpr] 1

            [word if] 0
            [word type] 0
            [word match] 0
            [word do] 0
            [word let] 0
            [word def] 0

            [word type-anno] [is-syntactic-value [second l]]
            0]
        [form/list l] 0]]]]

[def try-get-macro [extern interpreter try-get-macro]]
[def interpreter-apply [extern interpreter apply]]

[defn try-expand-form [gctx form]
  [match form
    [form/word w] [none]
    [form/list l]
    [if [is-empty l]
      [none]
      [if-let [mac
        [if-let [w [try-get-form-word-option [first l]]]
          [try-get-macro [check-context/eval-context gctx] w]
          [none]]]
        [let-do [expanded [interpreter-apply mac [rest l]]
                 form-expansions [check-context/form-expansions gctx]]
          [assert [not [has form-expansions form]] form already in expansion map]
          [set-kv-map form-expansions form expanded]
          [some expanded]]
        [none]]]]]

[defn word-list-contains [w .. words]
  [let [s-words [size words]]
    [[func go [i]
      [if [lt-s i s-words]
        [if [eq-word w [at words i]]
          1
          [go [inc i]]]
        0]]
      0]]]

[defn is-i32-bin-inst [w2]
  [word-list-contains w2
    [word i32.add] [word i32.sub] [word i32.mul] [word i32.rem-s] [word i32.div-s]
    [word i32.and] [word i32.or] [word i32.xor]
    [word i32.eq] [word i32.lt-s] [word i32.le-s]]]

[defn check [gctx level lctx form]
  [match form
    [form/word w]
    [if-let [type-scheme [try-get-var-type gctx lctx w]]
      [annotate gctx form [specialize-type-scheme gctx level type-scheme]]
      [do
        [report form not found]
        [generate-fresh-type-var gctx level]]]

    [form/list sub-forms]
    [let [s-form [size sub-forms]
          first-form [first sub-forms]
          n-of-args [dec s-form]]
      [ifs
        [eq-form [quote i32] first-form]
        [do
          [report-when-not [eq n-of-args 1] form expects 1 argument]
          type-i32]

        [eq-form [quote f64] first-form]
        [do
          [report-when-not [eq n-of-args 1] form expects 1 argument]
          type-f64]

        [eq-form [quote word] first-form]
        [do
          [report-when-not [eq n-of-args 1] form expects 1 argument]
          type-word]

        [eq-form [quote quote] first-form]
        [do
          [report-when-not [eq n-of-args 1] form expects 1 argument]
          type-form]

        [eq-form first-form [quote if]]
        [let-do
          [- [assert [eq n-of-args 3] form expects 3 arguments]
           cond [second sub-forms]
           then-branch [third sub-forms]
           else-branch [fourth sub-forms]
           cond-type [check gctx level lctx cond]
           then-type [check gctx level lctx then-branch]
           else-type [check gctx level lctx else-branch]]
          [report-when-not [eq n-of-args 3] form expects 3 argument]
          [unify-report gctx cond-type type-i32 cond]
          [unify-report gctx then-type else-type then-branch else-branch]
          [annotate gctx form then-type]]

        [eq-form first-form [quote type]]
        [let-do
          [types [check-context/types gctx]
           def-var-types [check-context/def-var-types gctx]]
          [report-when-not [eq [i32.rem-s n-of-args 3] 0] form expects triplets of arguments]
          [for-3 i 1 s-form
            [let [name-form [at sub-forms i]]
              [when-let [name-word [try-get-word-report gctx name-form]]
                [ifs
                  [is-builtin-type name-word]
                  [report name-form built-in type cannot be redefined]

                  [has types name-word]
                  [report name-form already defined]

                  [let-do [type-params-list [try-get-list-report gctx [at sub-forms [inc i]]]
                           param-map [transient-kv-map]
                           type-args [atom [linked-list/nil]]]
                    [for-each param type-params-list
                      [when-let [param-word [try-get-word-report gctx param]]
                        [report-when [has param-map param-word] param already defined]
                        [let-do [tv [generate-fresh-type-var gctx 1]]
                          [set-kv-map param-map param-word tv]
                          [push type-args tv]]]]
                    [set-kv-map types name-word
                      [type-def
                        [size type-params-list]
                        param-map
                        [make-type-list name-word [clone-growable-to-frozen-list type-args]]]]]]]]]
          [for-3 i 1 s-form
            [when-let [name-word [try-get-form-word-option [at sub-forms i]]]
              [let-do
                [type-prefix [concat-words name-word [word /]]
                 this-type-def [get types name-word]
                 result-type [type-def/result-type this-type-def]
                 param-map [type-def/param-map this-type-def]
                 type-def-list [try-get-list-report gctx [at sub-forms [add 2 i]]]]
                [if-let [type-def-first-word [try-get-word-report gctx [first type-def-list]]]
                  [switch type-def-first-word
                    [word union]
                    [for i 1 [size type-def-list]
                      [let-do [ctor [try-get-list-report gctx [at type-def-list i]]
                              param-list [list-map param [rest ctor] [instantiate-annotated-type gctx param-map param]]]
                        [when-let [ctor-name [try-get-word-report gctx [first ctor]]]
                          [set-kv-map def-var-types [concat-words type-prefix ctor-name]
                            [generalize-top [type-ctor param-list result-type]]]]]]

                    [word record]
                    [let-do
                      [fields [atom [linked-list/nil]]]
                      [for i 1 [size type-def-list]
                        [let-do
                          [field-def [try-get-list-report gctx [at type-def-list i]]
                          inst-field-type [instantiate-annotated-type gctx param-map [second field-def]]]
                          [push fields inst-field-type]
                          [when-let [field-name [try-get-word-report gctx [first field-def]]]
                            [set-kv-map def-var-types [concat-words type-prefix field-name]
                              [generalize-top [type-func [list result-type] [none] inst-field-type]]]]]]
                      [set-kv-map def-var-types name-word
                        [generalize-top [type-func [clone-growable-to-frozen-list fields] [none] [type-def/result-type [get types name-word]]]]]]

                    [logq-abort check type definition not recognized]]
                  [logq-abort check type definition not recognized]]]]]
          type-empty-tuple]

        [eq-form first-form [quote match]]
        [let-do [match-value [second sub-forms]
                 match-type [check gctx level lctx match-value]
                 result-type [generate-fresh-type-var gctx level]]
          [for-pair i 2 [dec s-form]
            [let [pattern [at sub-forms i]
                  branch [at sub-forms [inc i]]]
              [match pattern
                [form-list pattern-list]
                [if [is-empty pattern-list]
                  [report pattern expects a non-empty list]
                  [let-do
                    [first-pattern [first pattern-list]
                     destructor-type [check gctx level lctx first-pattern]
                     destructor-opt [try-get-ctor [normalize-type destructor-type]]]
                      [if-let [destructor destructor-opt]
                        [let-do [destructor-params [func-type/params destructor]
                                 var-values [transient-kv-map]
                                 branch-ctx [make-local-context var-values lctx first-form]]
                          [report-when-not [eq [size destructor-params] [dec [size pattern-list]]]
                            pattern
                            pattern and destructor-params have different sizes]
                          [for i 1 [size pattern-list]
                            [if-let [pattern-var [try-get-form-word-option [at pattern-list i]]]
                              [let [general-val-type [generalize level [at destructor-params [dec i]]]]
                                [set-kv-map var-values pattern-var general-val-type]]
                              [report [at pattern-list i] expects a word]]]
                          [unify-report gctx match-type [func-type/result destructor] pattern]
                          [unify-report gctx [check gctx level branch-ctx branch] result-type branch]]
                        [report first-pattern destructor not found]]]]

                  [do
                    [report pattern expects a list]
                    [generate-fresh-type-var gctx level]]]]]
          result-type]

        [eq-form first-form [quote switch]]
        [let-do [match-value [second sub-forms]
                 match-type [check gctx level lctx match-value]
                 result-type [generate-fresh-type-var gctx level]]
          [report-when-not [is-even n-of-args] form expects an even number of arguments]
          [for-pair i 2 [dec s-form]
            [let [case-const [at sub-forms i]
                  branch [at sub-forms [inc i]]]
              [match case-const
                [form-list case-const-list]
                [do
                  [if [is-empty case-const-list]
                    [report case-const expects a non-empty list]
                    [let-do
                      [first-case-const [first case-const-list]]
                      [when-let [case-const-word [try-get-form-word-option first-case-const]]
                        [report-when-not [word-list-contains case-const-word [word i32] [word f64] [word word]] case-const expects a constant]]
                      [unify-report gctx match-type [check gctx level lctx case-const] case-const]]]
                  [unify-report gctx [check gctx level lctx branch] result-type branch]]

                  [do
                    [report case-const expects a list]
                    [generate-fresh-type-var gctx level]]]]]
          result-type]

        [eq-form first-form [quote do]]
        [if n-of-args
          [do
            [for i 1 n-of-args
              [check gctx level lctx [at sub-forms i]]]
            [check gctx level lctx [last sub-forms]]]
          type-empty-tuple]

        [eq-form first-form [quote let]]
        [let-do
          [var-values [transient-kv-map]
           let-ctx [make-local-context var-values lctx first-form]
           bindings
            [if [lt-s 1 s-form]
              [form-to-list [second sub-forms]]
              [do [report form expects bindings] [list]]]
           n-of-bindings [size bindings]
           level-1 [inc level]]
          [report-when-not [eq n-of-args 2] form expects two arguments]
          [when [lt-s 1 s-form]
            [for-pair i 0 [dec n-of-bindings]
              [let-do
                [var [form-to-word [at bindings i]]
                 value [at bindings [inc i]]
                 val-type [check gctx level-1 let-ctx value]
                 general-val-type
                 [if [is-syntactic-value value]
                    [generalize level val-type]
                    [mk-empty-type-scheme val-type]]]
                [set-kv-map var-values var general-val-type]]]]
          [for i 2 [dec s-form]
            [check gctx level let-ctx [at sub-forms i]]]
          [if [lt-s 2 s-form]
            [check gctx level let-ctx [last sub-forms]]
            type-empty-tuple]]

        [or
          [eq-form first-form [quote func]]
          [eq-form first-form [quote macro]]
          [eq-form first-form [quote fexpr]]]
        [let-do
          [takes-form-params [or [eq-form first-form [quote macro]] [eq-form first-form [quote fexpr]]]
           function-kind
           [if-let [fw [try-get-form-word-option first-form]]
              [switch fw
                [word func] [function-kind/func]
                [word macro] [function-kind/macro]
                [word fexpr] [function-kind/fexpr]
                [logq-abort check function-kind not recognized]]
              [logq-abort check function-kind not recognized]]
           level-1 [inc level]
           param-ctx [transient-kv-map]
           gen-func-type [generate-fresh-type-var gctx level-1]
           func-ctx [make-local-context param-ctx lctx first-form]
           reg-params [atom [linked-list/nil]]
           opt-rest-param-atom [atom [none]]]
          [report-when-not [eq n-of-args 3] form expects 3 arguments]
          [when-let [func-name [try-get-form-word-option [second sub-forms]]]
            [set-kv-map param-ctx func-name [mk-empty-type-scheme gen-func-type]]]
          [let [params [try-get-list-report gctx [third sub-forms]]]
            [let-do
              [params-parsed [parse-parameter-list params]]
              [for-each param [parameters/regular-params params-parsed]
                [let-do [tv [if takes-form-params type-form [generate-fresh-type-var gctx level-1]]]
                  [annotate gctx param tv]
                  [set-kv-map param-ctx [form-to-word param] [mk-empty-type-scheme tv]]
                  [push reg-params tv]]]
              [when-let [rest-param [parameters/rest-param-opt params-parsed]]
                  [let-do [tv [if takes-form-params type-form [generate-fresh-type-var gctx level-1]]]
                    [set-kv-map param-ctx [form-to-word rest-param] [mk-empty-type-scheme [type-list tv]]]
                    [atom-set opt-rest-param-atom [some tv]]]]]]
          [let-do
            [frozen-params [clone-growable-to-frozen-list reg-params]
             body [fourth sub-forms]
             return-type [check gctx level-1 func-ctx body]]
            [unify-report gctx
              gen-func-type
              [type/inst [inst-type/func [func-type frozen-params [atom-get opt-rest-param-atom] return-type function-kind]]]
              form]
            [when [eq-form first-form [quote macro]]
              [unify-report gctx return-type type-form body]]]
          gen-func-type]

        [eq-form first-form [quote def]]
        [let-do
          [name [second sub-forms]
           value-form [third sub-forms]
           value-type [check gctx [inc level] lctx value-form]
           general-val-type [generalize level value-type]]
          [report-when-not [eq n-of-args 2] form expects 2 arguments]
          [set-kv-map [check-context/def-var-types gctx] [form-to-word name] general-val-type]
          value-type]

        [eq-form first-form [quote atom]]
        [type-atom [check gctx level lctx [second sub-forms]]]

        [eq-form first-form [quote extern]]
        [do
          [for i 1 s-form
            [let [sf [at sub-forms i]]
              [report-when-not [is-word sf] sf expects words]]]
          [generate-fresh-type-var gctx level]]

        [eq-form first-form [quote intrinsic]]
        [do
          [for i 1 s-form
            [let [sf [at sub-forms i]]
              [report-when-not [is-word sf] sf expects words]]]
          [let [opt-type
            [if-let [w1 [try-get-word-report gctx [second sub-forms]]]
              [if [eq-word w1 [word instructions]]
                [if-let [w2 [try-get-word-report gctx [third sub-forms]]]
                  [ifs
                    [is-i32-bin-inst w2]
                    [some i32i32-to-i32]

                    [eq-word w2 [word unreachable]]
                    [some [type-func [list] [none] [generate-fresh-type-var gctx [inc level]]]]

                    [none]]
                  [none]]
                [none]]
              [none]]]
            [match opt-type
              [none] [generate-fresh-type-var gctx level]
              [some t] t]]]

        [eq-form first-form [quote type-anno]]
        [let-do
          [value-form [second sub-forms]
           annotated-type [third sub-forms]
           value-type [check gctx level lctx value-form]
           inst-anno-type [instantiate-annotated-type-or-scheme gctx level annotated-type]]
          [report-when-not [eq n-of-args 2] form expects 2 arguments]
          [unify-report gctx inst-anno-type value-type form]
          value-type]

        [eq-form first-form [quote load]]
        [do
          [if-not [eq n-of-args 1]
            [report form expects 1 argument]
            [when-let [file-word [try-get-word-report gctx [second sub-forms]]]
              [for-each form [read-file file-word]
                [check gctx level lctx form]]]]
          type-empty-tuple]

        [if-let [expanded-form [try-expand-form gctx form]]
          [check gctx level lctx expanded-form]
          [let-do
            [func-type [check gctx level lctx first-form]
             opt-func-kind
              [match [normalize-type func-type]
                [type/inst inst-type]
                [match inst-type
                  [inst-type/func ft] [some [func-type/kind ft]]
                  [none]]
                [none]]
             is-fexpr
              [match opt-func-kind
                [some fk]
                [match fk
                  [function-kind/fexpr] 1
                  [function-kind/macro]
                  [do
                    [log first-form]
                    [log [meta first-form]]
                    [logq-abort check unexpected macro]]
                  0]
                0]]
            [annotate gctx first-form func-type]
            [let [args [rest sub-forms]
                  arg-types
                  [if is-fexpr
                    [list-map-fn [func f [-] type-form] args]
                    [list-map-fn [func f [arg] [check gctx level lctx arg]] args]]]
              [let-do
                [t-res [generate-fresh-type-var gctx level]
                 t-func [type-func arg-types [none] t-res]]
                [unify-report gctx func-type t-func form]
                [annotate gctx form t-res]]]]]]]]]

[defn internal-to-present-type [internal-type]
  [let [nt internal-type]
    [match nt
      [type/var tv]
      [let-do [kind [get-type-var-kind tv]]
        [match kind
          [type-var-kind/linked lt] [logq-abort internal-to-present-type expected a non-linked type var]
          [type-var-kind/word w] [form-word w]]]

      [type/inst inst-type]
      [match inst-type
        [inst-type/func ft]
        [flist [quote func]
          [if-let [rest-type [func-type/rest-param-opt ft]]
            [form-concat [list-map type [func-type/params ft] [internal-to-present-type type]] [list [quote ..] [internal-to-present-type rest-type]]]
            [form-list [list-map type [func-type/params ft] [internal-to-present-type type]]]]
          [internal-to-present-type [func-type/result ft]]]

        [inst-type/apply type-name type-args]
        [if [eq-word type-name [word tuple]]
          [form-concat [list [quote tuple]] [list-map type type-args [internal-to-present-type type]]]
          [let [n-of-args [size type-args]]
            [if n-of-args
              [form-concat
                [list [form-word type-name]]
                [list-map ta [slice type-args 0 n-of-args] [internal-to-present-type ta]]]
              [form-word type-name]]]]]]]]

[defn normalize-deep [internal-type]
  [let-do [nt [normalize-type internal-type]]
    [match nt
      [type/var tv]
      [match [get-type-var-kind tv]
        [type-var-kind/linked lt] [logq-abort normalize-deep expected a non-linked type var]
        [do]]

      [type/inst inst-type]
      [match inst-type
        [inst-type/func ft]
        [do
          [for-each param [func-type/params ft] [normalize-deep param]]
          [when-let [rest-type [func-type/rest-param-opt ft]]
            [normalize-deep rest-type]]
          [normalize-deep [func-type/result ft]]]

        [inst-type/apply type-name type-args]
        [for-each type-arg type-args
          [normalize-deep type-arg]]]]]]

[defn normalize-present-type-scheme [internal-type]
  [normalize-deep internal-type]
  [let-do
       [type-vars [free-type-vars internal-type]
        type-var-counter [atom 0]
        subst-assoc-list [list-map tv type-vars [pair tv [generate-fresh-type-var-atom type-var-counter 0]]]
        copied-type [copy-type subst-assoc-list internal-type]
        new-present-type-vars [list-map tv [free-type-vars copied-type]
          [let-do [kind [get-type-var-kind tv]]
            [match kind
              [type-var-kind/linked lt] [logq-abort internal-to-present-type expected a non-linked type var]
              [type-var-kind/word w] [form-word w]]]]]
    [if [is-empty new-present-type-vars]
      [internal-to-present-type copied-type]
      [flist [quote type-scheme]
        [form-list new-present-type-vars]
        [internal-to-present-type copied-type]]]]]

[def evaluate
  [type-anno
    [extern interpreter evaluate]
    [func [evaluation-context form] [tuple]]]]

[defn check-top [gctx form]
  [evaluate [check-context/eval-context gctx] form]
  [check gctx 0 [none] form]]

[defn check-top-forms [gctx forms]
  [assert [size forms] check-top-forms expects at least one form]
  [[func check-top-forms-go [i]
    [if [lt-s i [dec [size forms]]]
      [do
        [check-top gctx [at forms i]]
        [check-top-forms-go [inc i]]]
      [check-top gctx [at forms i]]]] 0]]


[defn get-messages-list [gctx]
  [clone-growable-to-frozen-list [check-context/messages gctx]]]

[defn log-report-message [message]
  [log [report-message/message message]]
  [log [meta [report-message/form message]]]]

[defn eq-list-of-forms [l1 l2]
  [and [eq [size l1] [size l2]]
    [[func eq-list-of-forms-go [i]
      [if [lt-s i [size l1]]
        [if [eq-form [at l1 i] [at l2 i]]
          [eq-list-of-forms-go [inc i]]
          0]
        1]] 0]]]

[defn i32-form [i]
  [form/word [int-to-word i]]]

[defn size-form [l]
  [i32-form [size l]]]

[defn test-ok-fn [tests-run-atom expected-type forms]
  [let [gctx [make-global-context]
        res [check-top-forms gctx forms]
        present-type [normalize-present-type-scheme res]
        messages [get-messages-list gctx]]
    [do
      [when-not [is-empty messages]
        [for-each message messages
          [log-report-message message]]
        [logq-abort test-ok failed there were errors]]
      [assert [eq-form present-type expected-type] test-ok failed expected type [identity expected-type] but found [identity present-type]]
      [inc-atom tests-run-atom]]]]

[defmacro test-ok [expected-type .. forms]
  [flist [quote test-ok-fn]
    [quote tests-run-atom]
    [mk-quote expected-type]
    [form-concat [list [quote list]] [list-map f forms [mk-quote f]]]]]

[defn test-errors-fn [tests-run-atom expected-type expected-messages forms]
  [let-do
   [gctx [make-global-context]
    res [check-top-forms gctx forms]
    present-type [normalize-present-type-scheme res]
    messages [get-messages-list gctx]]
    [if [is-empty messages]
      [logq-abort test-failed failed there were no errors]
      [when-not [eq [size expected-messages] [size messages]]
        [for-each message messages [log-report-message message]]
        [logq-abort test-failed failed expected [size-form expected-messages] messages but found [size-form messages]]]]
    [for i 0 [size messages]
      [let-do [expected-message [form-to-list [at expected-messages i]]
               message [report-message/message [at messages i]]]
        [assert [eq-list-of-forms expected-message message]
          test-failed failed expected message
          but found
          ]]]
    [assert [eq-form present-type expected-type] test-errors failed expected type [identity expected-type] but found [identity present-type]]
    [inc-atom tests-run-atom]]]

[defmacro test-errors [expected-type expected-messages .. forms]
  [flist [quote test-errors-fn]
    [quote tests-run-atom]
    [mk-quote expected-type]
    [form-concat [list [quote list]] [list-map m [form-to-list expected-messages] [mk-quote m]]]
    [form-concat [list [quote list]] [list-map f forms [mk-quote f]]]]]

[defn run-unit-tests []
  [let-do [tests-run-atom [atom 0]]

[comment variable]
[test-errors [type-scheme [a] a] [[not found]] [do not-found]]

[comment i32]
[test-ok i32 [i32 42]]

[comment word]
[test-ok word [word a]]

[comment quote]
[test-ok form [quote a]]
[test-ok form [quote []]]
[test-ok form [quote [[]]]]
[test-ok form [quote [a []]]]

[comment if]
[test-errors i32 [[not unifiable - different types]] [if [quote ok] [i32 5] [i32 5]]]
[test-errors i32 [[not unifiable - different types]] [if [i32 5] [i32 5] [quote a]]]
[test-errors form [[not unifiable - different types]] [if [i32 5] [quote a] [i32 5]]]
[test-ok i32 [if [i32 5] [i32 6] [i32 7]]]
[test-ok i32 [quote a] [if [i32 5] [i32 6] [i32 7]]]
[test-ok form [if [i32 5] [quote a] [quote b]]]

[comment do]
[test-ok [tuple] [do]]
[test-errors [type-scheme [a] a] [[not found]] [do v]]
[test-errors [tuple] [[not found]] [do v [do]]]
[test-errors [type-scheme [a] a] [[not found]] [do [do] v]]
[test-ok form [do [quote a]]]
[test-ok i32 [do [quote a] [i32 3]]]

[comment let]
[test-errors [tuple] [[expects two arguments]] [let []]]
[test-ok form [let [] [quote a]]]
[test-ok form [let [v [quote a]] v]]
[test-ok form [let [v [quote a] u v] u]]

[comment func]
[comment function parameters cannot be polymorphically instantiated]
[test-errors [type-scheme [a] [func [[func [i32] a]] a]] [[not unifiable  - different types]]
  [func f [i]
    [do
      [i [i32 5]]
      [i [quote a]]]]]
[test-ok [type-scheme [a] [func [[func [i32] a]] a]]
  [func f [i]
    [i [i32 5]]]]
[test-ok
  [type-scheme [a] [func [.. a] [list a]]]
  [func list [.. entries] entries]]
[test-ok
  [type-scheme [a b] [func [a b] i32]]
  [func f [x y] [i32 5]]]
[test-ok
  [type-scheme [a] [func [] a]]
  [func diverge [] [diverge]]]
[test-ok
  [func [i32] i32]
  [func f [p]
    [if p
      [i32 2]
      [f [i32 1]]]]]
[test-ok
  [type-scheme [a] [func [.. a] i32]]
  [func f [.. p] [i32 0]]]
[test-ok
  [type-scheme [a] [list a]]
  [[func f [.. p] p]]]
[test-ok
  [list i32]
  [[func f [.. p] p] [i32 5]]]
[test-ok
  [list i32]
  [[func f [.. p] p] [i32 5] [i32 6]]]
[test-errors
  [list i32]
  [[not unifiable - different types]]
  [[func f [.. p] p] [i32 5] [quote a]]]
[test-ok
  [type-scheme [a] [func [a] a]]
  [func id [x] x]]
[test-ok
  [func [i32] i32]
  [if [i32 5]
    [func id-i32 [x] [if x x x]]
    [func id [x] x]]]
[test-errors
  [func [form] i32]
  [[not unifiable - different types]]
  [macro mac-i32 [x] [i32 5]]]
[test-ok
  [func [form] form]
  [macro mac-id [x] x]]
[test-ok
  [func [form] form]
  [fexpr fexpr-id [x] x]]
[test-ok
  [func [form] i32]
  [fexpr fexpr-i32 [x] [i32 5]]]

[test-ok
  i32
  [[fexpr fexpr-i32 [x] [i32 5]] [this is not evaluated]]]

[comment call]
[test-errors i32 [[not unifiable - different number of parameters]]
  [[func one-param [p] [i32 5]]]]
[test-errors i32 [[not unifiable - different number of parameters]]
  [[func zero-params [] [i32 5]] [quote extra-argument]]]
[test-ok form
  [[func f [i] [i [quote a]]] [func id [x] x]]]
[test-ok form [let [id [func id [x] x]] [do [id [i32 5]] [id [quote a]]]]]
[test-errors [type-scheme [a] a] [[not unifiable - different types]]
  [[i32 5] [i32 6]]]

[comment def]
[test-errors [type-scheme [a] a] [[not found]] [def a a]]
[test-errors [type-scheme [a] a] [[not found]] [def a [do a]]]
[test-errors [type-scheme [a] a] [[not found]] [def a [[func id [x] x] a]]]
[test-ok
  form
  [def d [quote a]]]
[test-ok
  form
  [def d [quote a]]
  d]
[test-ok
  i32
  [def f [func id [x] x]]
  [f [i32 5]]
  [f [i32 6]]]
[test-ok
  form
  [def f [func id [x] x]]
  [f [i32 5]]
  [f [quote a]]]
[test-ok
  [list i32]
  [def list [func list [.. entries] entries]]
  [def test [list [i32 1] [i32 2]]]
  test]
[test-ok form
  [def d [quote a]]
  [def d [quote b]]]
[test-ok [type-scheme [a] [func [.. a] [list a]]]
  [def list [func list [.. entries] entries]]]

[comment extern]
[test-ok [type-scheme [a] a] [extern host size]]

[comment macro expansion]
[test-ok i32
  [def m [macro m [] [quote [i32 5]]]]
  [m]]

[comment type annotations]
[test-ok [func [word] form]
  [def form-word
    [type-anno
      [extern host form-word]
      [func [word] form]]]]
[test-ok i32
  [type-anno
    [extern host form-word]
    i32]]
[test-ok form
  [type-anno
    [extern host form-word]
    form]]
[test-ok word
  [def id [func id [p] p]]
  [id [i32 4]]
  [id [word a]]]
[test-ok word
  [let
    [id [func id [p] p]]
    [do
      [id [i32 4]]
      [id [word a]]]]]

[test-ok word
  [let
    [id [type-anno [extern] [type-scheme [a] [func [a] a]]]]
    [do
      [id [i32 4]]
      [id [word a]]]]]

[test-ok word
  [def id [type-anno [extern] [type-scheme [a] [func [a] a]]]]
  [id [i32 4]]
  [id [word a]]]

[test-ok i32
  [def size
    [type-anno
      [extern host size]
      [type-scheme [a] [func [[list a]] i32]]]]
  [def list [func list [.. entries] entries]]
  [size [list [i32 5]]]
  [size [list [word a]]]]

[comment type union]
[test-ok boolean
  [type boolean [] [union [false] [true]]]
  [boolean/false]]
[test-ok boolean
  [type boolean [] [union [false] [true]]]
  [boolean/true]]
[test-ok [type-scheme [a] [func [] [option a]]]
  [type option [a] [union [none] [some a]]]
  option/none]
[test-ok [type-scheme [a] [func [a] [option a]]]
  [type option [a] [union [none] [some a]]]
  option/some]
[test-ok [type-scheme [a] [linked-list a]]
  [type linked-list [a] [union [nil] [cons a [linked-list a]]]]
  [linked-list/nil]]
[test-ok [linked-list i32]
  [type linked-list [a] [union [nil] [cons a [linked-list a]]]]
  [linked-list/cons [i32 5] [linked-list/nil]]]

[comment type record]
[test-ok empty-rec
  [type empty-rec [] [record]]
  [empty-rec]]
[test-ok one-field-rec
  [type one-field-rec [] [record [field i32]]]
  [one-field-rec [i32 5]]]
[test-ok [func [one-field-rec] i32]
  [type one-field-rec [] [record [field i32]]]
  one-field-rec/field]
[test-ok two-field-rec
  [type two-field-rec [] [record [field i32] [word word]]]
  [two-field-rec [i32 5] [word a]]]

[test-ok [func [word [list type]] type]
  [type
    type []
    [union
      [apply word [list [type]]]]]
    type/apply]

[test-ok [func [inst-type] type]
[type function-kind []
  [union
    [ctor]
    [func]]]

[type option [a]
  [union
    [none]
    [some a]]]
[type
  type-var-kind []
  [union
    [linked type]
    [word word]]

  type-var []
  [record
    [kind [atom type-var-kind]]
    [level [atom i32]]]

  func-type []
  [record
    [params [list type]]
    [rest-param-opt [option type]]
    [result type]
    [kind function-kind]]

  inst-type []
  [union
    [func func-type]
    [apply word [list type]]]

  type []
  [union
    [var type-var]
    [inst inst-type]]]
    type/inst]

[comment match]
[test-ok i32
  [type option []
    [union
      [none]]]
  [match [option/none] [option/none] [i32 5]]]

[comment switch]
[test-errors word [[not unifiable - different types]]
  [switch [i32 0]
    [i32 0] [word zero]
    [word a] [word one]
    [word not-01]]]
[test-ok word
  [switch [i32 0]
    [i32 0] [word zero]
    [i32 1] [word one]
    [word not-01]]]

[comment from wright]
[test-errors i32 [[not unifiable - different types]]
  [def atom-get
    [type-anno
      [extern atom-get]
      [type-scheme [a] [func [[atom a]] a]]]]
  [def atom-set
    [type-anno
      [extern atom-set]
      [type-scheme [a] [func [[atom a] a] [tuple]]]]]
  [def add
    [type-anno
      [extern add]
      [func [i32 i32] i32]]]
  [let [c [atom [func id [x] x]]]
    [do
      [atom-set c [func inc [x] [add [i32 1] x]]]
      [[atom-get c] [word true]]]]]
[test-errors i32 [[not unifiable - different types]]
  [def atom-get
    [type-anno
      [extern atom-get]
      [type-scheme [a] [func [[atom a]] a]]]]
  [def atom-set
    [type-anno
      [extern atom-set]
      [type-scheme [a] [func [[atom a] a] [tuple]]]]]
  [def add
    [type-anno
      [extern add]
      [func [i32 i32] i32]]]
  [def mk-atom [func mk-atom [init] [atom init]]]
  [let [c [mk-atom [func id [x] x]]]
    [do
      [atom-set c [func inc [x] [add [i32 1] x]]]
      [[atom-get c] [word true]]]]]
[test-ok i32
  [def atom-get
    [type-anno
      [extern atom-get]
      [type-scheme [a] [func [[atom a]] a]]]]
  [def atom-set
    [type-anno
      [extern atom-set]
      [type-scheme [a] [func [[atom a] a] [tuple]]]]]
  [type linked-list [a]
    [union
      [nil]
      [cons a [linked-list a]]]]
  [def push [func push [list-ref element]
    [atom-set list-ref [linked-list/cons element [atom-get list-ref]]]]]
  [let [gli [atom [linked-list/nil]]]
    [push gli [i32 5]]]
  [def push2 [func push [list-ref element]
    [atom-set list-ref [linked-list/cons element [atom-get list-ref]]]]]
  push2
  [let [glw [atom [linked-list/nil]]]
    [push2 glw [word a]]]
  [i32 5]]

[logq tests-run [i32-form [atom-get tests-run-atom]]]
  ]]

[defn test-ok-fn-stop-at-error [gctx forms]
  [for-each form forms
    [evaluate [check-context/eval-context gctx] form]
    [check-top gctx form]
    [let [messages [get-messages-list gctx]]
      [when-not [is-empty messages]
        [for-each message messages
          [log-report-message message]]
        [logq-abort test-ok-fn-stop-at-error failed there were errors [meta [identity form]]]]]]]

[def performance-now
  [type-anno
    [extern performance-now]
    [func [] f64]]]

[defn test-ok-files [.. files]
  [let-do
    [gctx [make-global-context]
     before [performance-now]]
    [for-each file files
      [test-ok-fn-stop-at-error gctx [read-file file]]]
    [logq it took ms]
    [log [[intrinsic instructions f64.sub] [performance-now] before]]]]

[defn test-check []
  [test-ok-files [word translator.wuns]]]

[type wat-type-basic []
  [union
    [i32]
    [i64]
    [f32]
    [f64]]]

[type wat-inst []
  [union
    [i32.const word]
    [f64.const word]
    [local.get word]
    [inst word [list wat-inst]]
    [if [list wat-type-basic] wat-inst wat-inst wat-inst]
    [call word [list wat-inst]]
    [instructions [list wat-inst]]]]

[type output-func []
  [record
    [name word]
    [parameters [list [pair word wat-type-basic]]]
    [result [list wat-type-basic]]
    [body wat-inst]]]

[type wat-output []
  [record
    [funcs [atom [linked-list output-func]]]]]

[defn empty-wat-output []
  [wat-output [atom [linked-list/nil]]]]

[type translate-context []
  [record
    [check-context check-context]
    ]]

[defn empty-translate-context []
  [translate-context [make-global-context]]]

[defn translate-type [present-type]
  [match present-type
    [form/word w]
    [switch w
      [word i32] [wat-type-basic/i32]
      [word f64] [wat-type-basic/f64]

      [logq-abort not implemented translate-type word]]

    [form/list l]
    [do
      [assert [not [is-empty l]] expected elements]
      [match [first l]
        [form/word w]
        [logq-abort not implemented translate-type unknown first]
        [logq-abort not implemented translate-type list]]]]]

[defn translate-types [present-type]
  [match present-type
    [form/word w]
    [switch w
      [word i32] [list [wat-type-basic/i32]]
      [word f64] [list [wat-type-basic/f64]]

      [logq-abort not implemented translate-types word]]

    [form/list l]
    [do
      [assert [not [is-empty l]] expected elements]
      [match [first l]
        [form/word w]
        [if [eq-word w [word tuple]]
          [list-map a [rest l] [logq-abort not implemented]]
          [logq-abort not implemented translate-types unknown first]]
        [logq-abort not implemented translate-types list]]]]]

[defn get-annotated-types [check-gctx form]
  [if-let [internal-type [try-get [check-context/type-annotations check-gctx] form]]
    [translate-types [normalize-present-type-scheme internal-type]]
    [do
      [log form]
      [logq-abort get-annotated-types no type annotation found]]]]

[defn get-annotated-type [check-gctx form]
  [if-let [internal-type [try-get [check-context/type-annotations check-gctx] form]]
    [translate-type [normalize-present-type-scheme internal-type]]
    [do
      [log form]
      [logq-abort get-annotated-type no type annotation found]]]]

[defn get-form-types [tctx form]
  [match form
    [form/word w] [logq-abort not implemented get-form-types variables]
    [form/list l]
    [do
      [assert [not [is-empty l]] expected non-empty list]
      [match [first l]
        [form/word w]
        [switch w
          [word i32]
          [list [wat-type-basic/i32]]

          [word do]
          [if [eq [size l] 1]
            [list]
            [get-form-types tctx [last l]]]

          [get-annotated-types [translate-context/check-context tctx] form]]

        [form/list fl]
        [get-annotated-types [translate-context/check-context tctx] form]]]]]

[defn translate-form [tctx lctx form]
  [match form
    [form/word w]
    [wat-inst/local.get w]

    [form/list l]
    [do
      [assert [not [is-empty l]] expected non-empty list]
      [match [first l]
        [form/word w]
        [switch w
          [word i32]
          [wat-inst/i32.const [form-to-word [second l]]]

          [word f64]
          [wat-inst/f64.const [form-to-word [second l]]]

          [word do]
          [wat-inst/instructions
            [concat
              [list-map f [slice l 1 [dec [size l]]]
                [let-do [types [get-form-types tctx f]]
                  [[func go [i]
                    [if i
                      [wat-inst/inst [word drop] [list [go [dec i]]]]
                      [translate-form tctx lctx f]]]
                    [size types]]]]
              [if [eq [size l] 1]
                [list]
                [list [translate-form tctx lctx [last l]]]]]]

          [word if]
          [wat-inst/if
            [get-form-types tctx form]
            [translate-form tctx lctx [second l]]
            [translate-form tctx lctx [third l]]
            [translate-form tctx lctx [fourth l]]]

          [word def]
          [logq-abort no defs in top level]

          [wat-inst/call w [list-map a [rest l] [translate-form tctx lctx a]]]]

        [form/list fl]
        [if [size fl]
          [match [first fl]
            [form/word flw]
            [if [eq-word flw [word intrinsic]]
              [let [inst-name [form-to-word [third fl]]]
                [if [or [is-i32-bin-inst inst-name] [eq-word inst-name [word unreachable]]]
                  [wat-inst/inst inst-name [list-map a [rest l] [translate-form tctx lctx a]]]
                  [logq-abort translate-form unknown instruction]]]
              [logq-abort translate-form unknown instruction]]]
          [logq-abort not implemented translate-form empty head list]]]]]]

[defn translate-top [tctx output form]
  [let-do [gctx [translate-context/check-context tctx]]
    [check-top gctx form]
    [match [atom-get [check-context/messages gctx]]
      [linked-list/cons m ms] [logq-abort translate-top binding errors found]
      [linked-list/nil] [do]]]
  [match form
    [form/word w] [logq-abort not implemented]
    [form/list l]
    [do
      [assert [not [is-empty l]] expected non-empty list]
      [match [first l]
        [form/word w]
        [if [eq-word w [word def]]
          [do
            [assert [eq [size l] 3] expected 3 elements]
            [let-do [name [second l]
                     body [form-to-list [third l]]
                     head-body [first body]
                     rest-body [rest body]]
              [if [eq-form head-body [quote func]]
                [do
                  [assert [eq [size rest-body] 3] expected 3 elements found]
                  [let-do [params [form-to-list [second rest-body]]
                           func-body [third rest-body]
                           lctx [transient-kv-map]
                           output-params-atom [atom [linked-list/nil]]
                           output-results [get-form-types tctx func-body]]
                    [for i 0 [size params]
                      [let [p [at params i]]
                        [push output-params-atom
                          [pair [form-to-word p] [get-annotated-type [translate-context/check-context tctx] p]]]]]
                    [push
                      [wat-output/funcs output]
                      [output-func
                        [form-to-word name]
                        [clone-growable-to-frozen-list output-params-atom]
                        output-results
                        [translate-form tctx lctx func-body]]]]]

                [logq-abort translate-top unknown special form]]]]

          [logq-abort translate-top unknown special form]]

        [form/list l]
        [logq-abort not implemented]]]]]

[defn translate-intermediate [top-forms]
  [let-do [o [empty-wat-output]
           tctx [empty-translate-context]]
    [for-each f top-forms
      [translate-top tctx o f]]
    o]]

[def ascii-line-feed [i32 10]]
[def ascii-space [i32 32]]
[def ascii-double-quote [i32 34]]
[def ascii-dollar [i32 36]]
[def ascii-left-paren [i32 40]]
[def ascii-right-paren [i32 41]]
[def ascii-equal [i32 61]]
[def ascii-backslash [i32 92]]

[type printer []
  [record
    [bytes [atom byte-array]]
    [index [atom i32]]]]

[defn empty-printer [init-capacity]
  [printer [atom [byte-array init-capacity]] [atom 0]]]

[defn printer-to-byte-array [p]
  [let-do
    [ci [atom-get [printer/index p]]
     cb [atom-get [printer/bytes p]]
     trimmed [byte-array ci]]
    [for i 0 ci
      [byte-array-set trimmed i [byte-array-get cb i]]]
    trimmed]]

[defn print-byte [printer byte]
  [let-do [ia [printer/index printer]
           i [atom-get ia]
           ba [printer/bytes printer]
           a [atom-get ba]]
    [assert [lt-s i [byte-array-size a]] printer buffer overflow]
    [byte-array-set a i byte]
    [atom-set [printer/index printer] [inc i]]]]

[defn print-word [printer word]
  [for i 0 [word-byte-size word]
    [print-byte printer [char-code-at word i]]]]

[type wat []
  [union
    [word word]
    [dollar word]
    [dqstring word]
    [seq [list wat]]
    [list [list wat]]]]

[defn print-wat [printer wat]
  [match wat
    [wat/word w] [print-word printer w]
    [wat/dollar w] [do [print-byte printer ascii-dollar] [print-word printer w]]
    [wat/dqstring w] [do [print-byte printer ascii-double-quote] [print-word printer w] [print-byte printer ascii-double-quote]]
    [wat/seq l]
      [do
        [when-not [is-empty l]
          [print-wat printer [first l]]
          [for i 1 [size l]
            [print-byte printer ascii-space]
            [print-wat printer [at l i]]]]]
    [wat/list l]
      [do
        [print-byte printer ascii-left-paren]
        [when-not [is-empty l]
          [print-wat printer [first l]]
          [for i 1 [size l]
            [print-byte printer ascii-space]
            [print-wat printer [at l i]]]]
        [print-byte printer ascii-right-paren]]
      ]]

[defn wat-list [.. l] [wat/list l]]

[defn wat-type-basic-to-word [t]
  [match t
    [wat-type-basic/i32] [word i32]
    [wat-type-basic/f64] [word f64]]]

[defn wat-concat [.. l] [wat/list [concat-lists l]]]

[defn wat-inst-to-out [i]
  [match i
    [wat-inst/i32.const w]
    [wat-concat
      [list [wat/word [word i32.const]] [wat/word w]]]

    [wat-inst/f64.const w]
    [wat-concat
      [list [wat/word [word f64.const]] [wat/word w]]]

    [wat-inst/inst w args]
    [wat-concat
      [list [wat/word w]] [list-map a args [wat-inst-to-out a]]]

    [wat-inst/local.get w]
    [wat-list [wat/word [word local.get]] [wat/dollar w]]

    [wat-inst/instructions insts]
    [wat/seq [list-map inst insts [wat-inst-to-out inst]]]

    [wat-inst/if result-types cond true false]
    [wat-list [wat/word [word if]]
      [wat/list [concat [list [wat/word [word result]]] [list-map rt result-types [wat/word [wat-type-basic-to-word rt]]]]]
      [wat-inst-to-out cond]
      [wat-list [wat/word [word then]] [wat-inst-to-out true]]
      [wat-list [wat/word [word else]]  [wat-inst-to-out false]]]

    [wat-inst/call w args]
    [wat-concat
      [list [wat/word [word call]] [wat/dollar w]]
      [list-map a args [wat-inst-to-out a]]]

    [logq-abort wat-inst-to-out unknown instruction]]]

[defn output-func-to-wat [of]
  [wat-concat
    [list
      [wat/word [word func]]
      [wat/dollar [output-func/name of]]
      [wat-list [wat/word [word export]] [wat/dqstring [output-func/name of]]]]
    [list-map p [output-func/parameters of]
      [wat-list [wat/word [word param]] [wat/dollar [pair/fst p]] [wat/word [wat-type-basic-to-word [pair/snd p]]]]]
    [list
      [wat-concat
        [list [wat/word [word result]]]
        [list-map rt [output-func/result of] [wat/word [wat-type-basic-to-word rt]]]]]
    [list
      [wat-inst-to-out [output-func/body of]]]]]

[defn generate-wat [output]
  [let-do [p [empty-printer [i32 800]]]
    [print-wat p
      [wat/seq [list-map of [clone-growable-to-frozen-list [wat-output/funcs output]]
        [output-func-to-wat of]]]]
    [let-do [ba [printer-to-byte-array p]]
      [byte-array-log-as-string ba]
      [wasm-instantiate [byte-array-to-wasm-module [wat-to-byte-array ba]]]]]]

[defn translate-to-wat [forms]
  [generate-wat [translate-intermediate forms]]]



[defn eq-int-list [expected actual]
  [and [eq [size expected] [size actual]]
    [[func go [i]
      [if [lt-s i [size expected]]
        [if [eq [at expected i] [at actual i]]
          [go [inc i]]
          0]
        1]] 0]]]

[defn eq-f64-list [expected actual]
  [and [eq [size expected] [size actual]]
    [[func go [i]
      [if [lt-s i [size expected]]
        [if [[intrinsic instructions f64.eq] [at expected i] [at actual i]]
          [go [inc i]]
          0]
        1]] 0]]]

[type test-assert []
  [union
    [eq [list f64] word [list f64]]]]

[type test []
  [record
    [asserts [list test-assert]]
    [module [list form]]]]

[defn run-test [test-data]
  [let-do [instance [translate-to-wat [test/module test-data]]]
    [for-each a [test/asserts test-data]
      [match a
        [test-assert/eq expected func-name args]
        [let [actual [wasm-call-export instance func-name args]]
          [when-not [eq-f64-list expected actual]
            [logq test failed]
            [log expected]
            [log actual]]]]]]]

[def evaluate-list-num
  [type-anno
    [extern interpreter evaluate-list-num]
    [func [evaluation-context word [list f64]] [list f64]]]]

[defn run-test-interpreter [test-data]
  [let-do
    [forms [test/module test-data]
     eval-ctx [make-eval-context]]
    [for-each form forms
      [evaluate eval-ctx form]]
    [for-each a [test/asserts test-data]
      [match a
        [test-assert/eq expected func-name args]
        [let [actual [evaluate-list-num eval-ctx func-name args]]
          [when-not [eq-f64-list expected actual]
            [logq test failed in interpreter]
            [log expected]
            [log actual]]]]]]]

[defn test-translate []
[let [tests
  [list
    [test
      [list [test-assert/eq [list] [word f] [list]]]
      [list
        [quote [def f [func f [] [do]]]]]]
    [test
      [list [test-assert/eq [list] [word g] [list]]]
      [list
        [quote [def g [func internal-name [] [do]]]]]]
    [test
      [list [test-assert/eq [list [f64 5]] [word f] [list]]]
      [list
        [quote [def f [func internal-name [] [i32 5]]]]]]
    [test
      [list [test-assert/eq [list [f64 5]] [word f] [list]]]
      [list
        [quote [def f [func internal-name [] [do [i32 2] [i32 5]]]]]]]
    [test
      [list [test-assert/eq [list [f64 5]] [word f] [list]]]
      [list
        [quote [def f [func internal-name [] [[intrinsic instructions i32.sub] [i32 7] [i32 2]]]]]]]
    [test
      [list [test-assert/eq [list [f64 5]] [word f] [list]]]
      [list
        [quote [def f [func f [] [if [i32 0] [i32 7] [i32 5]]]]]]]
    [test
      [list [test-assert/eq [list [f64 5]] [word f] [list]]]
      [list
        [quote [def f [func f [] [if [i32 1] [i32 5] [i32 9]]]]]]]
    [test
      [list [test-assert/eq [list] [word f] [list]]]
      [list
        [quote [def f [func f [] [if [i32 1] [do] [do]]]]]]]
    [test
      [list
        [test-assert/eq [list [f64 1]] [word not] [list [f64 0]]]
        [test-assert/eq [list [f64 0]] [word not] [list [f64 1]]]
        [test-assert/eq [list [f64 0]] [word not] [list [f64 2]]]
        [test-assert/eq [list [f64 0]] [word not] [list [f64 -1]]]
        [test-assert/eq [list [f64 0]] [word not] [list [f64 10]]]]
      [list
        [quote [def not [func not [p] [if p [i32 0] [i32 1]]]]]]]
    [test
      [list
        [test-assert/eq [list [f64 1.5]] [word twop] [list [f64 0] [f64 0]]]
        [test-assert/eq [list [f64 1.5]] [word twop] [list [f64 0] [f64 0.25]]]
        [test-assert/eq [list [f64 0]] [word twop] [list [f64 1] [f64 0]]]
        [test-assert/eq [list [f64 0.25]] [word twop] [list [f64 13.0] [f64 0.25]]]
        [test-assert/eq [list [f64 0.1337]] [word twop] [list [f64 13.0] [f64 0.1337]]]
        ]
      [list
        [quote [def twop [func twop [i f] [if i f [f64 1.5]]]]]]]
    [test
      [list
        [test-assert/eq [list [f64 1]] [word f] [list]]
        [test-assert/eq [list [f64 1]] [word g] [list]]]
      [list
        [quote [def f [func f [] [i32 1]]]]
        [quote [def g [func g [] [f]]]]]]
]]
  [for-each t tests
    [run-test t]
    [run-test-interpreter t]]]
]
