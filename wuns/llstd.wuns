[type vector [a size]
  [record
    [size i32]
    [elements [array a size]]]]

[memory mem 1]

[defn get-top []
  [intrinsic i32.load mem 0 4 [i32 0]]]

[defn init-mem []
  [if [intrinsic i32.eq [get-top] [i32 0]]
    [intrinsic i32.store mem 0 4 [i32 0] [i32 16]]
    [intrinsic unreachable]]]

[defn align-address [x]
  [intrinsic i32.and
    [intrinsic i32.add x [i32 3]]
    [intrinsic i32.xor [i32 -1] [i32 3]]]]

[defn alloc-n [n-bytes]
  [if [intrinsic i32.le-s n-bytes [i32 0]] [intrinsic unreachable] [do]]
  [let [top [get-top]]
    [if [intrinsic i32.eq [get-top] [i32 0]]
      [intrinsic unreachable]
      [do]]
    [intrinsic i32.store mem 0 4 [i32 0] [intrinsic i32.add top [align-address n-bytes]]]
    top]]

[defn vector-i8-alloc [s]
  [if [intrinsic i32.eq s [i32 0]] [intrinsic unreachable] [do]]
  [let [p [alloc-n [size-of [vector i8 [exp s]]]]]
    [store-field mem p [vector i32 any] size s]
    p]]

[defn vector-size [vp]
  [load-field mem vp [vector i8 any] size]]

[defn array-i32-alloc [s]
  [let [p [alloc-n [size-of [array i32 [exp s]]]]]
    p]]

[defexpr quote [f] f]

[defmacro comment [.. -]
  [quote [do]]]

[comment
[defn set-character [word-pointer i c]
  [if [lt-s i [i32 0]] [unreachable]]
  [let [s [intrinsic i32.load mem [offset [vector i8 [exp [i32 -1]]] size] 4 word-pointer]]
    [if [ge-s i s] [unreachable]]
    [intrinsic i32.store8 mem [offset [vector i8 [exp [i32 -1]]] 1 [intrinsic i32.add word-pointer i] c]]]]

[defn get-character [word-pointer i]
  [if [lt-s i [i32 0]] [unreachable]]
  [let [s [intrinsic i32.load mem [offset [vector i8 [exp [i32 -1]]] size] 4 word-pointer]]
    [if [ge-s i s] [unreachable]]
    [intrinsic i32.load8-u mem [offset [vector i8 [exp [i32 -1]]] 1 [intrinsic i32.add word-pointer i]]]]]
 ]