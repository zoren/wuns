[load std.wuns]

[def lltype-params [transient-kv-map]]

[type lltype []
  [union
    [var word]
    [inst word [list lltype]]
    [exp form]
    [func [list lltype] [option lltype] lltype]]]

[defn validate-lltype [type-var-env type-form]
  [match type-form
    [form/word w]
    [if [set-has type-var-env w]
      [lltype/var w]
      [validate-lltype type-var-env [flist type-form]]]

    [form/list l]
    [do
      [assert [size l] not empty]
      [let [type-name [form-to-word [first l]]
            type-args [slice l 1 [size l]]]
        [switch type-name
          [[word i8] [word i16] [word i32] [word f64] [word any]]
          [do
            [when-not [is-empty type-args]
              [log type-args]
              [logq-abort invalid number of arguments]]
            [assert [eq [size type-args] 0] ll invalid number of arguments1]
            [lltype/inst type-name [list]]]

          [[word pointer]]
          [do
            [assert [eq [size type-args] 1] ll invalid number of arguments2]
            [lltype/inst type-name [list [validate-lltype type-var-env [first type-args]]]]]

          [[word exp]]
          [do
            [assert [eq [size type-args] 1] ll invalid number of arguments3]
            [lltype/exp [first type-args]]]

          [[word array]]
          [let [element-type-form [first type-args]
                size-form [second type-args]
                size-type [validate-lltype type-var-env size-form]]
            [match size-type
              [lltype/var -] [do]
              [lltype/exp -] [do]
              [logq-abort invalid size type]]
            [lltype/inst type-name
              [list [validate-lltype type-var-env element-type-form]
              size-type]]]

          [let [type-var-env [get lltype-params type-name]
                type-params [pair/fst type-var-env]]
            [assert [eq [pair/snd type-var-env] [size type-args]] ll invalid number of arguments4]
            [lltype/inst type-name
              [list-map targ type-args [validate-lltype type-params targ]]]]]]]]]

[type lltype-decl-kind []
  [union
    [record [list [pair word lltype]]]
    [tagged-union [list [pair word [list lltype]]]]
    [untagged-union [list [list lltype]]]]]

[def lltypes [transient-kv-map]]

[defexpr lltype [.. t]
  [assert [eq [i32.rem-s [size t] 3] 0] lltype invalid number of arguments not multiple of 3]
  [for-3 i 0 [size t]
    [let
      [type-name [form-to-word [at t i]]
       type-params [list-map p [form-to-list [at t [inc i]]] [form-to-word p]]
       type-var-env [set]]
      [when [has lltype-params type-name]
        [log type-name]
        [log lltype-params]
        [logq-abort ll type already defined]]
      [assert [not [has lltype-params type-name]] ll type already defined]
      [for-each p type-params
        [assert [not [set-has type-var-env p]] ll duplicate type parameter]
        [set-add type-var-env p]]
      [set-kv-map lltype-params type-name [pair type-var-env [size type-params]]]]]
  [for-3 i 0 [size t]
    [let
      [type-name [form-to-word [at t i]]
       type-var-env [pair/fst [get lltype-params type-name]]
       type-body [form-to-list [at t [add i 2]]]
       type-kind [form-to-word [first type-body]]
       type-kind-args [rest type-body]]
      [assert [size type-body] body empty]
      [set-kv-map lltypes type-name
        [switch type-kind
          [[word record]]
          [let [field-name-set [set]]
            [lltype-decl-kind/record
              [list-map field-form type-kind-args
                [let [field [form-to-list field-form]]
                  [assert [eq [size field] 2] ll invalid field]
                  [let [field-name [form-to-word [at field 0]]
                        field-type-form [at field 1]]
                    [assert [not [set-has field-name-set field-name]] ll field name already defined]
                    [set-add field-name-set field-name]
                    [pair field-name [validate-lltype type-var-env field-type-form]]]]]]]

          [[word tagged-union]]
          [let [ctor-name-set [set]]
            [lltype-decl-kind/tagged-union
              [list-map ctor-form type-kind-args
                [let [ctor-list [form-to-list ctor-form]]
                  [assert [not [is-empty ctor-list]] ll invalid ctor-list]
                  [let [ctor-name [form-to-word [first ctor-list]]]
                    [assert [not [set-has ctor-name-set ctor-name]] ll ctor-list name already defined]
                    [set-add ctor-name-set ctor-name]
                    [pair ctor-name
                      [list-map tp [rest ctor-list]
                        [validate-lltype type-var-env tp]]]]]]]]

          [[word untagged-union]]
          [lltype-decl-kind/untagged-union
            [list-map tp type-kind-args [validate-lltype type-var-env tp]]]

          [logq-abort unknown lltype kind]]]]]]

[defn llsize-of [t]
  [match t
    [lltype/var -] [logq-abort llsize-of var]
    [lltype/inst name args]
    [switch name
      [[word i8] [word u8]] 1
      [[word i16] [word u16]] 2
      [[word i32] [word u32]] 4
      [[word i64] [word f64]] 8
      [[word pointer]] 4

      [match [get lltypes name]
        [lltype-decl-kind/record fields]
        [loop [i 0 csize 0]
          [if-not [lt-s i [size fields]]
            csize
            [continue
              csize [add csize [llsize-of [pair/snd [at fields i]]]]
              i [inc i]]]]

        [lltype-decl-kind/tagged-union ctors]
        [loop [j 0 max-size 0]
          [if-not [lt-s j [size ctors]]
            max-size
            [let
              [ctor [at ctors j]
               params [pair/snd ctor]
               total-size
                [loop [i 0 acc-size 0]
                  [if-not [lt-s i [size params]]
                    acc-size
                    [continue
                      acc-size [add acc-size [llsize-of [at params i]]]
                      i [inc i]]]]]
              [continue
                j [inc j]
                max-size [max max-size total-size]]]]]

        [lltype-decl-kind/untagged-union types]
        [loop [i 0 max-size 0]
          [if-not [lt-s i [size types]]
            max-size
            [let
              [type [at types i]
               size [llsize-of type]]
              [continue
                i [inc i]
                max-size [max max-size size]]]]]]]
    [lltype/exp -] 4
    [lltype/func args ret] [logq-abort llsize-of func]]]

[defn lloffset-fn [record-type-name field-name]
  [match [get lltypes record-type-name]
    [lltype-decl-kind/record fields]
    [loop [i 0
           offset 0]
      [let [p [at fields i]
            type [pair/snd p]]
        [if [eq-word field-name [pair/fst p]]
          [pair offset type]
          [continue
            i [inc i]
            offset [add offset [llsize-of type]]]]]]]]

[defexpr lloffset [record-type-name-form field-form]
  [lloffset-fn [form-to-word record-type-name-form] [form-to-word field-form]]]

[lltype llvector [a size]
  [record
    [size i32]
    [elements [array a size]]]]

[lltype
  word-or-list []
  [tagged-union
    [word [pointer [llvector i8 i32]]]
    [list [pointer [llvector [pointer tform] i32]]]]

  tform []
  [record
    [tag i32]
    [data word-or-list]]]

[lltype
  form-word []
  [record
    [tag [exp [i32 0]]]
    [data [pointer [llvector i8 i32]]]]

  form-list []
  [record
    [tag [exp [i32 1]]]
    [data [pointer [llvector [pointer uform] i32]]]]

  uform []
  [untagged-union
    form-word
    form-list]]

[type vector [a size]
  [record
    [size i32]
    [elements [array a size]]]]

[defn type-to-load-inst-name [type-name]
  [switch type-name
    [[word i32]] [word i32.load]
    [[word i64]] [word i64.load]
    [[word f32]] [word f32.load]
    [[word f64]] [word f64.load]
    [[word i8]] [word i32.load8-s]
    [[word u8]] [word i32.load8-u]
    [[word i16]] [word i32.load16-s]
    [[word u16]] [word i32.load16-u]

    [logq-abort unknown type-to-load-inst-name]]]

[defn type-to-store-inst-name [type-name]
  [switch type-name
    [[word i32]] [word i32.store]
    [[word i64]] [word i64.store]
    [[word f32]] [word f32.store]
    [[word f64]] [word f64.store]
    [[word i8] [word u8]] [word i32.store8]
    [[word i16] [word u16]] [word i32.store16]

    [logq-abort unknown type-to-store-inst-name]]]

[defn type-to-lltype [type]
  [match type
    [lltype/var -] [logq-abort type-to-lltype var]
    [lltype/func - --] [logq-abort type-to-lltype func]
    [lltype/exp -] [word i32]
    [lltype/inst name args]
      [switch name
        [[word i8] [word i16] [word i32] [word f64]]
        [do
          [assert [is-empty args] type-to-lltype invalid number of arguments]
          name]

        [[word pointer]]
        [do
          [assert [eq [size args] 1] type-to-lltype invalid number of arguments]
          [word i32]]

        [logq-abort type-to-lltype unknown]]]]

[defmacro load-record-field [mem pexp record-type-name-form field-form]
  [let [p [lloffset-fn [form-to-word record-type-name-form] [form-to-word field-form]]]
  [flist
    [quote intrinsic]
    [form/word [type-to-load-inst-name [type-to-lltype [pair/snd p]]]]
    mem
    [form/word [int-to-word [pair/fst p]]]
    [quote 0]
    pexp]]]

[defmacro store-record-field [mem pexp record-type-name-form field-form value]
  [let [p [lloffset-fn [form-to-word record-type-name-form] [form-to-word field-form]]]
  [flist
    [quote intrinsic]
    [form/word [type-to-store-inst-name [type-to-lltype [pair/snd p]]]]
    mem
    [form/word [int-to-word [pair/fst p]]]
    [quote 0]
    pexp
    value]]]

[defmacro load-array [mem pexp array-type-element-form start-offset-form index-form]
  [let [t [validate-lltype [set] array-type-element-form]
        element-size [llsize-of t]]
    [flist
      [quote intrinsic]
      [form/word [type-to-load-inst-name [type-to-lltype t]]]
      mem
      start-offset-form
      [quote 0]
      [flist
        [quote intrinsic]
        [quote i32.mul]
        index-form
        [flist [quote i32] [form/word [int-to-word element-size]]]]]]]

[defmacro store-array [mem pexp array-type-element-form start-offset-form index-form value]
  [let [t [validate-lltype [set] array-type-element-form]
        element-size [llsize-of t]]
    [flist
      [quote intrinsic]
      [form/word [type-to-store-inst-name [type-to-lltype t]]]
      mem
      start-offset-form
      [quote 0]
      [flist
        [quote intrinsic]
        [quote i32.mul]
        index-form
        [flist [quote i32] [form/word [int-to-word element-size]]]]
      value]]]

[memory mem 1]

[defn get-top []
  [intrinsic i32.load mem 0 4 [i32 0]]]

[defn init-mem []
  [if [intrinsic i32.eq [get-top] [i32 0]]
    [intrinsic i32.store mem 0 4 [i32 0] [i32 16]]
    [intrinsic unreachable]]]

[defn align-address [x]
  [intrinsic i32.and
    [intrinsic i32.add x [i32 3]]
    [intrinsic i32.xor [i32 -1] [i32 3]]]]

[defn alloc-n [n-bytes]
  [if [intrinsic i32.le-s n-bytes [i32 0]] [intrinsic unreachable] [do]]
  [let [top [get-top]]
    [if [intrinsic i32.eq [get-top] [i32 0]]
      [intrinsic unreachable]
      [do]]
    [intrinsic i32.store mem 0 4 [i32 0] [intrinsic i32.add top [align-address n-bytes]]]
    top]]

[defn vector-i8-alloc [s]
  [if [intrinsic i32.eq s [i32 0]] [intrinsic unreachable] [do]]
  [let [p [alloc-n [size-of [vector i8 [exp s]]]]]
    [store-field mem p [vector i32 any] size s]
    p]]

[defn vector-size [vp]
  [load-field mem vp [vector i8 any] size]]

[defn array-i32-alloc [s]
  [let [p [alloc-n [size-of [array i32 [exp s]]]]]
    p]]

[comment
[defn set-character [word-pointer i c]
  [if [lt-s i [i32 0]] [unreachable]]
  [let [s [intrinsic i32.load mem [offset [vector i8 [exp [i32 -1]]] size] 4 word-pointer]]
    [if [ge-s i s] [unreachable]]
    [intrinsic i32.store8 mem [offset [vector i8 [exp [i32 -1]]] 1 [intrinsic i32.add word-pointer i] c]]]]

[defn get-character [word-pointer i]
  [if [lt-s i [i32 0]] [unreachable]]
  [let [s [intrinsic i32.load mem [offset [vector i8 [exp [i32 -1]]] size] 4 word-pointer]]
    [if [ge-s i s] [unreachable]]
    [intrinsic i32.load8-u mem [offset [vector i8 [exp [i32 -1]]] 1 [intrinsic i32.add word-pointer i]]]]]
 ]