[memory mem [i32] 1]

[type list-data [a datatype size [exp [i32]]]
  [record
    [size [i32]]
    [array [array a size]]]]

[type pmem [a datatype]
  [pointer [exp mem] a]]

[type plist [vp datatype]
  [pmem [list-data vp -size]]]

[defn list-size [pvec [plist -a]] [i32]
  [deref [field pvec size]]]

[def 0 [i32 0]]
[def 1 [i32 1]]

[defn not [x [i32]] [i32]
  [if x 0 1]]

[defn get-byte [pvec [plist [u8]] i [i32]] [i32]
  [when [lt-s i 0] [intrinsic unreachable]]
  [when-not [lt-s i [list-size pvec]] [intrinsic unreachable]]
  [deref-to [index [field pvec array] i] [i32]]]

[defn inc [x [i32]] [i32] [add x 1]]
[defn dec [x [i32]] [i32] [sub x 1]]

[type pword []
  [plist [u8]]]

[def form-word-tag [i32 10]]
[def form-list-tag [i32 11]]

[type form-word []
  [record
    [tag [exp form-word-tag]]
    [pword [pword]]]]

[type
  form-list []
  [record
    [tag [exp form-list-tag]]
    [forms [plist [pmem [form]]]]]

  form []
  [union
    [form-word]
    [form-list]]]

[defn form-tag [pf [pmem [form]]] [i32]
  [deref [field pf tag]]]

[defn form-word-is [pf [pmem [form]]] [i32]
  [eq [deref [field pf tag]] form-word-tag]]

[defn form-word-get [pf [pmem [form]]] [pword]
  [when-not [form-word-is pf] [intrinsic unreachable]]
  [deref [field [cast [pmem [form-word]] pf] pword]]]

[defn form-list-is [pf [pmem [form]]] [i32]
  [eq [deref [field pf tag]] form-list-tag]]

[defn form-list-get [pf [pmem [form]]] [plist [pmem [form]]]
  [when-not [form-list-is pf] [intrinsic unreachable]]
  [deref [field [cast [pmem [form-list]] pf] forms]]]

[defn list-get-form [pvec [plist [pmem [form]]] i [i32]] [pmem [form]]
  [when [lt-s i 0] [intrinsic unreachable]]
  [when-not [lt-s i [list-size pvec]] [intrinsic unreachable]]
  [deref [index [field pvec array] i]]]

[mutable mem-top [memory-static-top mem]]

[defn get-top [] [i32]
  mem-top]

[defn set-top [new-top [i32]] [tuple]
  [assign-mutable mem-top new-top]]

[defn align [p [i32] x [i32]] [i32]
  [intrinsic i32.and
    [add x [dec p]]
    [intrinsic i32.xor [i32 -1] [dec p]]]]

[defn alloc-n [n-bytes [i32]] [i32]
  [let [align-bytes [align [i32 16] n-bytes]
        top-val [get-top]]
    [when [eq top-val 0] [intrinsic unreachable]]
    [set-top [add top-val align-bytes]]
    top-val]]

[defn form-word-alloc [pw [pword]] [pmem [form]]
  [let [pfw [alloc mem [form-word]]]
    [assign pfw
      [record
        tag form-word-tag
        pword pw]]
    [cast [pmem [form]] pfw]]]

[defn form-list-alloc [pfs [plist [pmem [form]]]] [pmem [form]]
  [let [pfl [alloc mem [form-list]]]
    [assign pfl
      [record
        tag form-list-tag
        forms pfs]]
    [cast [pmem [form]] pfl]]]

[type growable-list [a datatype]
  [record
    [size [i32]]
    [capacity [i32]]
    [parray [pmem [array a]]]]]

[defn growable-list-alloc-form [init-capacity [i32]] [pmem [growable-list [pmem [form]]]]
  [let
    [p [alloc mem [growable-list [pmem [form]]]]
     parray
     [cast [pmem [array [pmem [form]]]]
      [alloc-n [size-of [array [pmem [form]] [exp init-capacity]]]]]]
    [assign p
      [record
        size 0
        capacity init-capacity
        parray parray]]
    p]]

[defn growable-list-push-form [pglist [pmem [growable-list [pmem [form]]]] elem [pmem [form]]] [tuple]
  [let
    [cur-size [deref [field pglist size]]
     cur-capacity [deref [field pglist capacity]]
     parray [deref [field pglist parray]]]
    [when [eq cur-size cur-capacity]
      [intrinsic unreachable]]
    [assign [index parray cur-size] elem]
    [assign [field pglist size] [inc cur-size]]]]

[defn growable-list-to-list-form [pglist [pmem [growable-list [pmem [form]]]]] [plist [pmem [form]]]
  [let
    [gsize [deref [field pglist size]]
     pglist-arr [deref [field pglist parray]]
     plist [alloc mem [list-data [pmem [form]] [exp gsize]]]
     par [field plist array]]
    [assign [field plist size] gsize]
    [for i 0 gsize
      [assign [index par i] [deref [index pglist-arr i]]]]
    plist]]

[defn growable-list-reset [pglist [pmem [growable-list -a]]] [tuple]
  [assign [field pglist size] 0]]

[defn is-between-inclusive [lower [i32] c [i32] upper [i32]] [i32]
  [and [le-s lower c] [le-s c upper]]]

[defn is-whitespace [c [i32]] [i32]
  [or [eq c [i32 32]] [eq c [i32 10]]]]

[defn is-word-char [c [i32]] [i32]
  [or
    [is-between-inclusive [i32 97] c [i32 122]]
    [is-between-inclusive [i32 45] c [i32 57]]]]

[defn scan-word-end [bytes [plist [u8]] start [i32]] [i32]
  [loop
    [n-of-bytes [list-size bytes]
     i start]
    [if-not [lt-s i n-of-bytes]
      i
      [if [is-word-char [get-byte bytes i]]
        [continue i [inc i]]
        i]]]]

[defn make-stack [stack-size [i32] init-capacity [i32]] [pmem [array [growable-list [pmem [form]]]]]
  [let [parray [alloc mem [array [growable-list [pmem [form]]] [exp stack-size]]]]
    [for i 0 stack-size
      [assign
        [index parray i]
        [record
          size 0
          capacity init-capacity
          parray [alloc mem [array [pmem [form]] [exp init-capacity]]]]]]
    parray]]

[def stack-size [i32 16]]
[def init-capacity [i32 32]]

[defn list-slice-byte [psrc [plist [u8]] start [i32] end [i32]] [plist [u8]]
  [let
    [sz [sub end start]
     pdst [alloc mem [list-data [u8] [exp sz]]]
     pdst-ar [field pdst array]
     psrc-ar [field psrc array]]
    [assign [field pdst size] sz]
    [for i 0 sz
      [assign
        [index pdst-ar i]
        [deref [index psrc-ar [add start i]]]]]
    pdst]]

[defn parse [bytes [plist [u8]]] [pmem [form]]
  [loop
    [stack [make-stack stack-size init-capacity]
     n-of-bytes [list-size bytes]
     i 0
     stack-index [i32 -1]]
    [if-not [lt-s i n-of-bytes]
      [if [is-negative stack-index]
        [cast [pmem [form]] 0]
        [do
          [when-not [eq 0 stack-index] [intrinsic unreachable]]
          [form-list-alloc
            [growable-list-to-list-form [index stack stack-index]]]]]
      [let [c [get-byte bytes i]]
        [ifs
          [is-word-char c]
          [let [word-end [scan-word-end bytes [inc i]]
                fw [form-word-alloc [list-slice-byte bytes i word-end]]]
            [if [is-negative stack-index]
              fw
              [do
                [growable-list-push-form [index stack stack-index] fw]
                [when-not [lt-s i word-end] [intrinsic unreachable]]
                [continue i word-end]]]]

          [is-whitespace c]
          [continue i [inc i]]

          [eq c [i32 91]]
          [do
            [when [lt-s stack-size stack-index] [intrinsic unreachable]]
            [continue
              i [inc i]
              stack-index [inc stack-index]]]

          [eq c [i32 93]]
          [do
            [when [is-negative stack-index] [intrinsic unreachable]]
            [let [glist [index stack stack-index]
                  form-list [growable-list-to-list-form glist]]
              [growable-list-reset glist]
              [let [fl [form-list-alloc form-list]]
                [if [eq stack-index 0]
                fl
                [do
                  [growable-list-push-form [index stack [dec stack-index]] fl]
                  [continue
                    i [inc i]
                    stack-index [dec stack-index]]]]]]]

          [intrinsic unreachable]]]]]]

[defn byte-array-alloc [sz [i32]] [plist [u8]]
  [let [p [alloc mem [list-data [u8] [exp sz]]]]
    [assign [field p size] sz]
    p]]

[defn list-data [pvec [plist [u8]]] [pmem [array [u8]]]
  [field pvec array]]

[export mem parse byte-array-alloc list-size list-data
  form-tag form-word-is form-word-get form-list-is form-list-get
  get-byte
  list-get-form
]
