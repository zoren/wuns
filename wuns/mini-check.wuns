[defn make-type-var [kind level]
  [let-do [tv [transient-kv-map]]
    [setq tv kind kind]
    [setq tv level level]
    tv]]

[defn is-type-var [v]
  [and [hasq v kind] [hasq v level]]]

[defn type-var-kind [t]
  [assert [is-type-var t] type-var-kind not a type var [identity t]]
  [getq t kind]]

[defn type-var-level [t]
  [assert [is-type-var t] type-var-level not a type var [identity t]]
  [getq t level]]

[defn set-type-var-kind [type-var kind]
  [assert [is-type-var type-var] set-type-var-kind not a type var [identity type-var]]
  [setq type-var kind kind]]

[defn set-type-var-level [type-var level]
  [assert [is-type-var type-var] set-type-var-level not a type var [identity type-var]]
  [setq type-var level level]]

[defn int-to-type-var-name-word [i]
  [if [lt-s i [i32 26]]
    [char-code-to-word [add [i32 97] i]]
    [concat-words
      [int-to-type-var-name-word [i32.div-s i [i32 26]]]
      [char-code-to-word [add [i32 97] [i32.rem-s i [i32 26]]]]]]]

[defn make-type [type-name type-args] [kv-map-id type-name type-args]]
[defn is-type [t] [and [hasq t type-name]]]

[def type-i32 [make-type [word i32] [list]]]
[def type-word [make-type [word word] [list]]]
[def type-form [make-type [word form] [list]]]
[def type-transient-kv-map [make-type [word transient-kv-map] [list]]]
[def type-kv-map [make-type [word kv-map] [list]]]
[defn type-list [elem-type] [make-type [word list] [list elem-type]]]
[def type-empty-tuple [make-type [word tuple] [list]]]
[defn type-tuple [elem-types]
  [if [size elem-types]
    [make-type [word tuple] elem-types]
    type-empty-tuple]]
[defn type-func-no-rest [params result]
  [kv-mapq
    type-name [word func]
    params params
    result result]]

[defn type-func [params opt-rest-param result]
  [if-let [rest-param opt-rest-param]
    [kv-mapq
      type-name [word func]
      params params
      rest-param rest-param
      result result]
    [type-func-no-rest params result]]]

[defn report-fn [gctx message form]
  [push [getq gctx messages] [kv-map-id message form]]]

[defmacro report-when [cond form .. lmsg]
  [flist [quote when] cond
    [flist [quote report-fn] [quote gctx] [quote-list lmsg] form]]]

[defmacro report-when-not [cond form .. lmsg]
  [flist [quote when-not] cond
    [flist [quote report-fn] [quote gctx] [quote-list lmsg] form]]]

[defmacro report [form .. lmsg]
  [flist [quote report-fn] [quote gctx] [quote-list lmsg] form]]

[defn set-type-var-kind-to-type [type-var type]
  [set-type-var-kind type-var type]]

[comment normalize a type make type variable point directly to the linked type - if any]
[defn normalize-type [t0]
  [if [is-type-var t0]
    [let [kind [type-var-kind t0]]
      [if [is-word kind]
        t0
        [let-do [t2 [normalize-type kind]]
          [set-type-var-kind-to-type t0 t2]
          t2]]]
    t0]]

[defn member-type-var-list [set t]
  [[func member-type-var-list-go [i]
    [if [lt-s i [size set]]
      [if [is-identical [at set i] t]
        1
        [member-type-var-list-go [inc i]]]
      0]] 0]]

[defn free-type-vars-growable [set t]
  [let [nt [normalize-type t]]
    [if
      [is-type-var nt]
      [when-not [member-type-var-list set nt]
        [push set nt]]

      [if [eq-word [getq nt type-name] [word func]]
        [let-do
          [params [getq nt params]
           result [getq nt result]]
          [for-each param params [free-type-vars-growable set param]]
          [if-let [rest-param [try-getq nt rest-param]]
            [free-type-vars-growable set rest-param]
            [do]]
          [free-type-vars-growable set result]]
        [for-each arg [getq nt type-args]
          [free-type-vars-growable set arg]]]]]]

[defn free-type-vars [t]
  [let-do [set [growable-list]]
    [free-type-vars-growable set t]
    [clone-growable-to-frozen-list set]]]

[defn prune-level [max-level tvs]
  [for-each tv tvs
    [set-type-var-level tv [min [type-var-level tv] max-level]]]]

[defn link-var-to-type [type-var type]
  [let
    [level [type-var-level type-var]
     fvs [free-type-vars type]]
    [do
      [assert [not [member-type-var-list fvs type-var]] type-var occurs in type
        [list fvs type-var [member-type-var-list fvs type-var]]]
      [prune-level level fvs]
      [set-type-var-kind-to-type type-var type]]]]

[defn push-unify-error [errors msg]
  [push errors msg]]

[defexpr message [.. words]
  words]

[defn unify [errors t1 t2]
  [let [nt1 [normalize-type t1]
        nt2 [normalize-type t2]]
    [ifs
      [and [is-type-var nt1] [is-type-var nt2]]
      [when-not [is-identical nt1 nt2]
        [if [lt-s [type-var-level nt1] [type-var-level nt2]]
          [link-var-to-type nt1 nt2]
          [link-var-to-type nt2 nt1]]]

      [is-type-var nt1]
      [link-var-to-type nt1 nt2]

      [is-type-var nt2]
      [link-var-to-type nt2 nt1]

      [and [is-type nt1] [is-type nt2]]
      [let [type-name1 [getq nt1 type-name]
            type-name2 [getq nt2 type-name]]
        [ifs
          [not [eq-word type-name1 type-name2]]
          [push-unify-error errors [message not unifiable - different types]]

          [if [eq-word [word func] type-name1]
            [let-do
                 [params1 [getq nt1 params]
                  params2 [getq nt2 params]
                  arity1 [size params1]
                  arity2 [size params2]
                  opt-rest-param1 [try-getq nt1 rest-param]
                  opt-rest-param2 [try-getq nt2 rest-param]
                  result1 [getq nt1 result]
                  result2 [getq nt2 result]]
              [ifs
                [and [not opt-rest-param1] [not opt-rest-param2]]
                [if
                  [not [eq arity1 arity2]]
                  [push-unify-error errors [message not unifiable - different number of parameters]]

                  [for i 0 arity1
                    [unify errors [at params1 i] [at params2 i]]]]

                [and opt-rest-param1 [not opt-rest-param2]]
                [if
                  [lt-s arity2 arity1]
                  [push-unify-error errors [message not unifiable - insufficient number of parameters]]

                  [do
                    [for i 0 arity1
                      [unify errors [at params1 i] [at params2 i]]]
                    [for i arity1 arity2
                      [unify errors opt-rest-param1 [at params2 i]]]]]

                [logq-abort func unification not implemented]]
              [unify errors result1 result2]]

            [let [type-args1 [getq nt1 type-args]
                  type-args2 [getq nt2 type-args]
                  arity1 [size type-args1]]
              [if [not [eq arity1 [size type-args2]]]
                [push-unify-error errors [message not unifiable - different number of type arguments]]
                [[func unify-go [i]
                  [if [lt-s i arity1]
                    [if-let [msg [unify errors [at type-args1 i] [at type-args2 i]]]
                      msg
                      [unify-go [inc i]]]
                    0]] 0]]]]]]

      [logq-abort unify arguments not a type nor type variables [identity nt1] [identity nt2]]]]]

[defn unify-report [gctx t1 t2 .. forms]
  [let [errors [growable-list]
        form [first forms]]
    [do
      [unify errors t1 t2]
      [for-each error [clone-growable-to-frozen-list errors]
        [report-fn gctx error form]]]]]

[defn int-to-type-var-name [i]
  [if [lt-s i [i32 26]]
    [char-code-to-word [add [i32 97] i]]
    [concat-words
      [int-to-type-var-name [i32.div-s i [i32 26]]]
      [char-code-to-word [add [i32 97] [i32.rem-s i [i32 26]]]]]]]

[defn int-to-type-var [i]
  [form-word [int-to-type-var-name i]]]

[defn generate-fresh-type-var-atom [counter-atom level]
  [make-type-var [int-to-type-var [inc-atom counter-atom]] level]]

[defn generate-fresh-type-var [gctx level]
  [generate-fresh-type-var-atom [getq gctx type-var-counter] level]]

[defn unify-call [gctx level func-type arg-types form]
  [let [t-res [generate-fresh-type-var gctx level]
        t-func [type-func-no-rest arg-types t-res]]
    [unify-report gctx func-type t-func form]
    t-res]]

[defn mk-type-scheme [type-vars type] [list [quote type-scheme] type-vars type]]

[defn generalize [current-level type]
  [let [tvs [growable-list]]
    [do
      [for-each tv [free-type-vars type]
        [when [lt-s current-level [type-var-level tv]]
          [push tvs tv]]]
      [mk-type-scheme [clone-growable-to-frozen-list tvs] type]]]]

[defn try-get-assoc-identical [assoc-list var]
  [[func try-get-assoc-identical-go [i]
    [if [lt-s i [size assoc-list]]
      [let [pair [at assoc-list i]]
        [if [is-identical var [first pair]]
          [second pair]
          [try-get-assoc-identical-go [inc i]]]]
      0]] 0]]

[defn copy-type [subst-map t]
  [ifs
    [is-type-var t]
    [if-let [subst-type [try-get-assoc-identical subst-map t]]
      subst-type
      [let [kind [type-var-kind t]]
        [if [is-word kind]
          t
          [copy-type subst-map kind]]]]

    [let [type-name [getq t type-name]]
      [if [eq-word type-name [word func]]
        [let [params [getq t params]
              result [getq t result]
              cparams [list-map param params [copy-type subst-map param]]
              crest-param [if-let [rest-param [try-getq t rest-param]] [copy-type subst-map rest-param] 0]]
          [type-func cparams crest-param [copy-type subst-map result]]]
        [let [type-args [getq t type-args]
              cargs [list-map arg type-args [copy-type subst-map arg]]]
        [make-type type-name cargs]]]]]]

[defn specialize [gctx level type-vars type]
  [if [is-empty type-vars]
    type
    [let [subst-assoc-list [list-map tv type-vars [list tv [generate-fresh-type-var gctx level]]]]
      [copy-type subst-assoc-list type]]]]

[defn specialize-type-scheme [gctx level type-scheme]
  [let [type-vars [second type-scheme]
        type [third type-scheme]]
    [specialize gctx level type-vars type]]]

[defn mk-empty-type-scheme [type] [mk-type-scheme [list] type]]

[defn try-get-local-var-type [local-ctx var-name]
  [[func go [cur-ctx]
    [and cur-ctx
      [or
        [try-get [getq cur-ctx vars] var-name]
        [go [try-getq cur-ctx outer]]]]] local-ctx]]

[defn try-get-var-type [gctx local-ctx var-name]
  [if-let [ltype [try-get-local-var-type local-ctx var-name]]
    ltype
    [try-get [getq gctx def-var-types] var-name]]]

[defn params-to-map [params]
  [if [and [lt-s 1 [size params]] [eq-form-word [at params -2] [quote ..]]]
    [kv-mapq params [slice params 0 [sub [size params] 2]]
             rest-param [last params]]
    [kv-mapq params params]]]

[defn check-type-arity [gctx type-name n-of-given-type-args]
  [ifs
    [eq-form type-name [quote tuple]]
    [report-when [eq n-of-given-type-args 1] type-name tuple type expects zero or multiple arguments]

    [or
      [eq-form type-name [quote i32]]
      [eq-form type-name [quote word]]
      [eq-form type-name [quote form]]
      [eq-form type-name [quote transient-kv-map]]
      [eq-form type-name [quote kv-map]]
      ]
    [report-when [eq n-of-given-type-args 0] type-name atomic type expects no arguments]

    [or
      [eq-form type-name [quote list]]
      [eq-form type-name [quote mutable-list]]
      [eq-form type-name [quote growable-list]]
      [eq-form type-name [quote option]]
      [eq-form type-name [quote atom]]
      ]
    [report-when-not [eq n-of-given-type-args 1] type-name list type expects one argument]

    [eq-form type-name [quote func]]
    [report-when-not [eq n-of-given-type-args 3]
      type-name func type expects a parameter list a rest parameter list and a return type]

    [logq-abort check-builtin-type-arity type-name not a known builtin type [identity type-name]]]]

[comment given a type such as [func [i32 i32] i32] instantiates to a type-scheme]
[defn instantiate-annotated-type [gctx type-var-env type]
  [ifs
    [eq-form type [quote i32]]
    type-i32

    [eq-form type [quote word]]
    type-word

    [eq-form type [quote form]]
    type-form

    [eq-form type [quote transient-kv-map]]
    type-transient-kv-map

    [eq-form type [quote kv-map]]
    type-kv-map

    [is-word type]
    [let [w [form-to-word type]]
      [if-let [t [try-get type-var-env w]]
        t
        [logq-abort type could not be instantiated - not known - [identity type] [identity type-var-env]]]]

    [not [is-list type]]
    [logq-abort type expected word or list]

    [let [elements [form-to-list type]
          first-form [first elements]
          s-form [size elements]
          n-of-args [dec s-form]]
      [if [eq s-form 0]
        [logq-abort type expects a non-empty list]
        [ifs
          [not [is-word first-form]]
          [logq-abort type expects a word [identity first-form]]

          [eq-form first-form [quote func]]
          [do
            [report-when-not [eq n-of-args 2] type expects 2 arguments a parameter list and a return type]
            [let [params [second elements]
                  - [report-when-not [is-list params] type expects a list]
                  params-list [form-to-list params]
                  result [third elements]
                  params-map [params-to-map params-list]
                  reg-params [getq params-map params]
                  internal-params
                  [list-map param reg-params
                    [do
                      [report-when [eq-form param [quote ..]] param .. in wrong place]
                      [instantiate-annotated-type gctx type-var-env param]]]]
              [type-func
                internal-params
                [if-let [rest-param [try-getq params-map rest-param]]
                  [instantiate-annotated-type gctx type-var-env rest-param]
                  0]
                [instantiate-annotated-type gctx type-var-env result]]]]

          [eq-form first-form [quote type-scheme]]
          [do
            [report-when type-var-env type cannot have a type-scheme inside a type-scheme]
            [report-when-not [eq n-of-args 2] type type-scheme expects 2 arguments]
            [let-do [type-vars [second elements]
                     type [third elements]
                     type-var-env [transient-kv-map]]
              [report-when-not [is-list type-vars] type type-vars expects a list]
              [for-each tv [form-to-list type-vars]
                [report-when-not [is-word tv] type-vars expects a word]
                [set-kv-map type-var-env [form-to-word tv] [generate-fresh-type-var gctx 0]]]
              [instantiate-annotated-type gctx type-var-env type]]]

          [let-do [type-args [mutable-list-of-size n-of-args]]
            [check-type-arity gctx first-form n-of-args]
            [for i 0 n-of-args
              [set-array type-args i [instantiate-annotated-type gctx type-var-env [at elements [inc i]]]]]
            [make-type [form-to-word first-form] type-args]]]]]]]

[def try-get-macro [extern interpreter try-get-macro]]
[def apply [extern interpreter apply]]

[defn check [gctx level lctx form]
  [ifs
    [is-word form]
    [if-let [type-scheme [try-get-var-type gctx lctx [form-to-word form]]]
      [specialize-type-scheme gctx level type-scheme]
      [do
        [report form not found]
        [generate-fresh-type-var gctx level]]]

    [not [is-list form]]
    [logq-abort check input not a form [identity form]]

    [let [sub-forms [form-to-list form]
          s-form [size sub-forms]
          first-form [first sub-forms]
          n-of-args [dec s-form]]
      [ifs
        [eq-form [quote i32] first-form]
        [do
          [report-when-not [eq n-of-args 1] form expects 1 argument]
          type-i32]

        [eq-form [quote word] first-form]
        [do
          [report-when-not [eq n-of-args 1] form expects 1 argument]
          type-word]

        [eq-form [quote quote] first-form]
        [do
          [report-when-not [eq n-of-args 1] form expects 1 argument]
          type-form]

        [eq-form first-form [quote if]]
        [let-do
          [cond [second sub-forms]
           then-branch [third sub-forms]
           else-branch [fourth sub-forms]
           cond-type [check gctx level lctx cond]
           then-type [check gctx level lctx then-branch]
           else-type [check gctx level lctx else-branch]]
          [report-when-not [eq n-of-args 3] form expects 3 argument]
          [unify-report gctx cond-type type-i32 cond]
          [unify-report gctx then-type else-type then-branch else-branch]
          then-type]

        [eq-form first-form [quote do]]
        [if n-of-args
          [do
            [for i 1 n-of-args
              [check gctx level lctx [at sub-forms i]]]
            [check gctx level lctx [last sub-forms]]]
          type-empty-tuple]

        [eq-form first-form [quote let]]
        [let-do
          [var-values [transient-kv-map]
           let-ctx [kv-mapq vars var-values outer lctx first-form first-form]
           bindings
            [if [lt-s 1 s-form]
              [form-to-list [second sub-forms]]
              [do [report form expects bindings] [list]]]
           n-of-bindings [size bindings]
           level-1 [inc level]]
          [report-when-not [eq n-of-args 2] form expects two arguments]
          [when [lt-s 1 s-form]
            [for-pair i 0 [dec n-of-bindings]
              [let-do
                [var [form-to-word [at bindings i]]
                  value [at bindings [inc i]]
                  val-type [check gctx level-1 let-ctx value]
                  general-val-type [generalize level val-type]]
                [set-kv-map var-values var general-val-type]]]]
          [for i 2 [dec s-form]
            [check gctx level let-ctx [at sub-forms i]]]
          [if [lt-s 2 s-form]
            [check gctx level let-ctx [last sub-forms]]
            type-empty-tuple]]

        [or
          [eq-form first-form [quote func]]
          [eq-form first-form [quote macro]]
          [eq-form first-form [quote fexpr]]]
        [let-do
          [level-1 [inc level]
           func-name [second sub-forms]
           params-form [third sub-forms]
           body [fourth sub-forms]
           params [form-to-list params-form]
           param-ctx [transient-kv-map]
           parsed-params [params-to-map params]
           reg-params-parsed [getq parsed-params params]
           func-type [generate-fresh-type-var gctx level-1]
           func-ctx [kv-mapq vars param-ctx first-form first-form]
           reg-params [growable-list]
           takes-form-params [or [eq-form first-form [quote macro]] [eq-form first-form [quote fexpr]]]]
          [report-when-not [eq n-of-args 3] form expects 3 arguments]
          [set-kv-map param-ctx [form-to-word func-name] [mk-empty-type-scheme func-type]]
          [for-each param reg-params-parsed
            [let-do [tv [if takes-form-params type-form [generate-fresh-type-var gctx level-1]]]
              [set-kv-map param-ctx [form-to-word param] [mk-empty-type-scheme tv]]
              [push reg-params tv]]]
          [let-do
            [opt-rest-param
                [if-let [rest-param [try-getq parsed-params rest-param]]
                  [let-do [tv [if takes-form-params type-form [generate-fresh-type-var gctx level-1]]]
                    [set-kv-map param-ctx [form-to-word rest-param]
                      [mk-empty-type-scheme [type-list tv]]]
                    tv]
                  0]
                return-type [check gctx level-1 func-ctx body]]
            [unify-report gctx
              func-type
              [type-func
                [clone-growable-to-frozen-list reg-params]
                opt-rest-param
                return-type]
              form]
            [when [eq-form first-form [quote macro]]
              [unify-report gctx return-type type-form body]]]
          func-type]

        [eq-form first-form [quote def]]
        [let-do
          [name [second sub-forms]
           value-form [third sub-forms]
           value-type [check gctx [inc level] lctx value-form]
           general-val-type [generalize level value-type]]
          [report-when-not [eq n-of-args 2] form expects 2 arguments]
          [set-kv-map [getq gctx def-var-types] [form-to-word name] general-val-type]
          value-type]

        [eq-form first-form [quote extern]]
        [do
          [for i 1 s-form
            [let [sf [at sub-forms i]]
              [report-when-not [is-word sf] sf expects words]]]
          [generate-fresh-type-var gctx level]]

        [eq-form first-form [quote type-anno]]
        [let-do
          [value-form [second sub-forms]
           annotated-type [third sub-forms]
           value-type [check gctx level lctx value-form]
           inst-anno-type [instantiate-annotated-type gctx 0 annotated-type]]
          [report-when-not [eq n-of-args 2] form expects 2 arguments]
          [unify-report gctx inst-anno-type value-type form]
          value-type]

        [let [eval-context [getq gctx eval-context]]
          [if-let [mac [if-let [w [try-get-form-word first-form]]
                        [try-get-macro eval-context w]
                        0]]
            [let [expanded-form [apply eval-context mac [slice sub-forms 1 s-form]]]
              [check gctx level lctx expanded-form]]
            [let-do
              [func-type [check gctx level lctx first-form]
              arg-types [mutable-list-of-size n-of-args]]
              [for i 0 n-of-args
                [set-array arg-types i [check gctx level lctx [at sub-forms [inc i]]]]]
              [let-do
                [t-res [generate-fresh-type-var gctx level]
                t-func [type-func-no-rest arg-types t-res]]
                [unify-report gctx func-type t-func form]
                t-res]]]]]]]]

[def make-eval-context [extern interpreter make-context]]

[defn make-global-context []
  [kv-mapq
    messages [growable-list]
    def-var-types [transient-kv-map]
    type-var-counter [atom 0]
    eval-context [make-eval-context]]]

[def evaluate [extern interpreter evaluate]]

[defn check-top [gctx form]
  [logq form [identity form]]
  [evaluate [getq gctx eval-context] form]
  [check gctx 0 0 form]]

[defn check-top-forms [gctx forms]
  [assert [size forms] check-top-forms expects at least one form]
  [logq we are checking]
  [[func check-top-forms-go [i]
    [if [lt-s i [dec [size forms]]]
      [do
        [check-top gctx [at forms i]]
        [check-top-forms-go [inc i]]]
      [check-top gctx [at forms i]]]] 0]]

[defn internal-to-present-type [internal-type]
  [let [nt internal-type]
    [if [is-type-var nt]
      [let-do [kind [type-var-kind nt]]
        [assert [is-word kind] internal-to-present-type not word type var [identity nt]]
        kind]
      [let [type-name [getq nt type-name]]
        [if
          [eq-word type-name [word func]]
          [let [params [getq nt params]
                n-params [size params]
                opt-rest-param [try-getq nt rest-param]
                result [getq nt result]
                n-present-params [if opt-rest-param [add n-params 2] n-params]
                regular-present-params [list-map param params [internal-to-present-type param]]
                present-params
                [if opt-rest-param
                  [concat regular-present-params [list [quote ..] [internal-to-present-type opt-rest-param]]]
                  regular-present-params]]
              [flist [quote func] [form-list present-params] [internal-to-present-type result]]]

          [let [type-args [getq nt type-args]
                n-of-args [size type-args]
                present-type [mutable-list-of-size [inc n-of-args]]]
            [if n-of-args
              [let-do [present-type [mutable-list-of-size [inc n-of-args]]]
                [set-array present-type 0 [form-word type-name]]
                [for i 0 n-of-args
                  [set-array present-type [inc i] [internal-to-present-type [at type-args i]]]]
                [freeze-mutable-list present-type]
                [form-list present-type]]
              [if [eq-word type-name [word tuple]] [quote unit] [form-word type-name]]]]]]]]]

[defn normalize-deep [internal-type]
  [let-do [nt [normalize-type internal-type]]
    [if [is-type-var nt]
      [assert [is-word [type-var-kind nt]] normalize-deep expected a non-linked type var]
      [if [eq-word [getq nt type-name] [word func]]
        [do
          [for-each p [getq nt params] [normalize-deep p]]
          [if-let [rp [try-getq nt rest-param]]
            [normalize-deep rp]
            [do]]
          [normalize-deep [getq nt result]]]
        [for-each type-arg [getq nt type-args]
          [normalize-deep type-arg]]]]]]

[defn normalize-present-type-scheme [internal-type]
  [normalize-deep internal-type]
  [let-do
       [type-vars [free-type-vars internal-type]
        type-var-counter [atom 0]
        fresh-type-vars [list-map tv type-vars [generate-fresh-type-var-atom type-var-counter 0]]
        subst-assoc-list [mutable-list-of-size [size type-vars]]
        new-present-type-vars [list-map tv fresh-type-vars [internal-to-present-type tv]]]
    [for i 0 [size type-vars]
      [let [tv [at type-vars i]
            new-tv [at fresh-type-vars i]]
        [set-array subst-assoc-list i [list tv new-tv]]]]
    [if [is-empty new-present-type-vars]
      [internal-to-present-type [copy-type subst-assoc-list internal-type]]
      [flist [quote type-scheme]
        [form-list new-present-type-vars]
        [internal-to-present-type [copy-type subst-assoc-list internal-type]]]]]]
