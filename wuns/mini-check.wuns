[defn make-type-var [kind level]
  [let-do [tv [transient-kv-map]]
    [setq tv kind kind]
    [setq tv level level]
    tv]]

[defn is-type-var [v]
  [and [hasq v kind] [hasq v level]]]

[defn type-var-kind [t]
  [assert [is-type-var t] type-var-kind not a type var [identity t]]
  [getq t kind]]

[defn type-var-level [t]
  [assert [is-type-var t] type-var-level not a type var [identity t]]
  [getq t level]]

[defn set-type-var-kind [type-var kind]
  [assert [is-type-var type-var] set-type-var-kind not a type var [identity type-var]]
  [setq type-var kind kind]]

[defn set-type-var-level [type-var level]
  [assert [is-type-var type-var] set-type-var-level not a type var [identity type-var]]
  [setq type-var level level]]

[defn int-to-type-var-name-word [i]
  [if [lt-s i [i32 26]]
    [char-code-to-word [add [i32 97] i]]
    [concat-words
      [int-to-type-var-name-word [i32.div-s i [i32 26]]]
      [char-code-to-word [add [i32 97] [i32.rem-s i [i32 26]]]]]]]

[defn make-type [type-name type-args] [kv-map-id type-name type-args]]
[defn is-type [t] [and [hasq t type-name]]]

[def type-i32 [make-type [word i32] [list]]]
[def type-word [make-type [word word] [list]]]
[def type-form [make-type [word form] [list]]]
[defn type-list [elem-type] [make-type [word list] [list elem-type]]]
[def type-empty-tuple [make-type [word tuple] [list]]]
[defn type-tuple [elem-types]
  [if [size elem-types]
    [make-type [word tuple] elem-types]
    type-empty-tuple]]
[defn type-func-no-rest [params result]
  [kv-mapq
    type-name [word func]
    params params
    result result]]

[defn type-func [params opt-rest-param result]
  [if-let [rest-param opt-rest-param]
    [kv-mapq
      type-name [word func]
      params params
      rest-param rest-param
      result result]
    [type-func-no-rest params result]]]

[defn report-fn [gctx message form]
  [push [getq gctx messages] [kv-map-id message form]]]

[defmacro report-when [cond form .. lmsg]
  [flist [quote when] cond
    [flist [quote report-fn] [quote gctx] [quote-list lmsg] form]]]

[defmacro report-when-not [cond form .. lmsg]
  [flist [quote when-not] cond
    [flist [quote report-fn] [quote gctx] [quote-list lmsg] form]]]

[defmacro report [form .. lmsg]
  [flist [quote report-fn] [quote gctx] [quote-list lmsg] form]]

[defn set-type-var-kind-to-type [type-var type]
  [set-type-var-kind type-var type]]

[comment normalize a type make type variable point directly to the linked type - if any]
[defn normalize-type [t0]
  [if [is-type-var t0]
    [let [kind [type-var-kind t0]]
      [if [is-word kind]
        t0
        [let-do [t2 [normalize-type kind]]
          [set-type-var-kind-to-type t0 t2]
          t2]]]
    t0]]

[defn member-type-var-list [set t]
  [[func member-type-var-list-go [i]
    [if [lt-s i [size set]]
      [if [is-identical [at set i] t]
        1
        [member-type-var-list-go [inc i]]]
      0]] 0]]

[defn free-type-vars-growable [set t]
  [let [nt [normalize-type t]]
    [if
      [is-type-var nt]
      [when-not [member-type-var-list set nt]
        [push set nt]]

      [if [eq-word [getq nt type-name] [word func]]
        [let-do
          [params [getq nt params]
           result [getq nt result]]
          [for-each param params [free-type-vars-growable set param]]
          [if-let [rest-param [try-getq nt rest-param]]
            [free-type-vars-growable set rest-param]
            [do]]
          [free-type-vars-growable set result]]
        [for-each arg [getq nt type-args]
          [free-type-vars-growable set arg]]]]]]

[defn free-type-vars [t]
  [let-do [set [growable-list]]
    [free-type-vars-growable set t]
    [clone-growable-to-frozen-list set]]]

[defn prune-level [max-level tvs]
  [for-each tv tvs
    [set-type-var-level tv [min [type-var-level tv] max-level]]]]

[defn link-var-to-type [type-var type]
  [let
    [level [type-var-level type-var]
     fvs [free-type-vars type]]
    [do
      [assert [not [member-type-var-list fvs type-var]] type-var occurs in type
        [list fvs type-var [member-type-var-list fvs type-var]]]
      [prune-level level fvs]
      [set-type-var-kind-to-type type-var type]]]]

[defn push-unify-error [errors msg]
  [push errors msg]]

[defexpr message [.. words]
  words]

[defn unify [errors t1 t2]
  [let [nt1 [normalize-type t1]
        nt2 [normalize-type t2]]
    [ifs
      [and [is-type-var nt1] [is-type-var nt2]]
      [when-not [is-identical nt1 nt2]
        [if [lt-s [type-var-level nt1] [type-var-level nt2]]
          [link-var-to-type nt1 nt2]
          [link-var-to-type nt2 nt1]]]

      [is-type-var nt1]
      [link-var-to-type nt1 nt2]

      [is-type-var nt2]
      [link-var-to-type nt2 nt1]

      [and [is-type nt1] [is-type nt2]]
      [let [type-name1 [getq nt1 type-name]
            type-name2 [getq nt2 type-name]]
        [ifs
          [not [eq-word type-name1 type-name2]]
          [push-unify-error errors [message not unifiable - different types]]

          [if [eq-word [word func] type-name1]
            [let-do
                 [params1 [getq nt1 params]
                  params2 [getq nt2 params]
                  arity1 [size params1]
                  arity2 [size params2]
                  opt-rest-param1 [try-getq nt1 rest-param]
                  opt-rest-param2 [try-getq nt2 rest-param]
                  result1 [getq nt1 result]
                  result2 [getq nt2 result]]
              [ifs
                [and [not opt-rest-param1] [not opt-rest-param2]]
                [if
                  [not [eq arity1 arity2]]
                  [push-unify-error errors [message not unifiable - different number of parameters]]

                  [for i 0 arity1
                    [unify errors [at params1 i] [at params2 i]]]]

                [and opt-rest-param1 [not opt-rest-param2]]
                [if
                  [lt-s arity2 arity1]
                  [push-unify-error errors [message not unifiable - insufficient number of parameters]]

                  [do
                    [for i 0 arity1
                      [unify errors [at params1 i] [at params2 i]]]
                    [for i arity1 arity2
                      [unify errors opt-rest-param1 [at params2 i]]]]]

                [logq-abort func unification not implemented]]
              [unify errors result1 result2]]

            [let [type-args1 [getq nt1 type-args]
                  type-args2 [getq nt2 type-args]
                  arity1 [size type-args1]]
              [if [not [eq arity1 [size type-args2]]]
                [push-unify-error errors [message not unifiable - different number of type arguments]]
                [[func unify-go [i]
                  [if [lt-s i arity1]
                    [if-let [msg [unify errors [at type-args1 i] [at type-args2 i]]]
                      msg
                      [unify-go i [inc i]]]
                    0]] 0]]]]]]

      [logq-abort unify arguments not a type nor type variables [identity nt1] [identity nt2]]]]]

[defn unify-report [gctx t1 t2 .. forms]
  [let [errors [growable-list]
        form [first forms]]
    [do
      [unify errors t1 t2]
      [for-each error [clone-growable-to-frozen-list errors]
        [report-fn gctx error form]]]]]

[defn int-to-type-var-name [i]
  [if [lt-s i [i32 26]]
    [char-code-to-word [add [i32 97] i]]
    [concat-words
      [int-to-type-var-name [i32.div-s i [i32 26]]]
      [char-code-to-word [add [i32 97] [i32.rem-s i [i32 26]]]]]]]

[defn int-to-type-var [i]
  [form-word [int-to-type-var-name i]]]

[defn generate-fresh-type-var-atom [counter-atom level]
  [make-type-var [int-to-type-var [inc-atom counter-atom]] level]]

[defn generate-fresh-type-var [gctx level]
  [generate-fresh-type-var-atom [getq gctx type-var-counter] level]]

[defn unify-call [gctx level func-type arg-types form]
  [let [t-res [generate-fresh-type-var gctx level]
        t-func [type-func-no-rest arg-types t-res]]
    [unify-report gctx func-type t-func form]
    t-res]]

[defn mk-type-scheme [type-vars type] [list [quote type-scheme] type-vars type]]

[defn generalize [current-level type]
  [let [tvs [growable-list]]
    [do
      [for-each tv [free-type-vars type]
        [when [lt-s current-level [type-var-level tv]]
          [push tvs tv]]]
      [mk-type-scheme [clone-growable-to-frozen-list tvs] type]]]]

[defn try-get-assoc-identical [assoc-list var]
  [[func try-get-assoc-identical-go [i]
    [if [lt-s i [size assoc-list]]
      [let [pair [at assoc-list i]]
        [if [is-identical var [first pair]]
          [second pair]
          [try-get-assoc-identical-go [inc i]]]]
      0]] 0]]

[defn copy-type [subst-map t]
  [ifs
    [is-type-var t]
    [if-let [subst-type [try-get-assoc-identical subst-map t]]
      subst-type
      [let [kind [type-var-kind t]]
        [if [is-word kind]
          t
          [copy-type subst-map kind]]]]

    [let [type-name [getq t type-name]]
      [if [eq-word type-name [word func]]
        [let [params [getq t params]
              result [getq t result]
              cparams [list-map param params [copy-type subst-map param]]
              crest-param [if-let [rest-param [try-getq t rest-param]] [copy-type subst-map rest-param] 0]]
          [type-func cparams crest-param [copy-type subst-map result]]]
        [let [type-args [getq t type-args]
              cargs [list-map arg type-args [copy-type subst-map arg]]]
        [make-type type-name cargs]]]]]]

[defn specialize [gctx level type-vars type]
  [if [is-empty type-vars]
    type
    [let [subst-assoc-list [list-map tv type-vars [list tv [generate-fresh-type-var gctx level]]]]
      [copy-type subst-assoc-list type]]]]

[defn specialize-type-scheme [gctx level type-scheme]
  [let [type-vars [second type-scheme]
        type [third type-scheme]]
    [specialize gctx level type-vars type]]]

[defn mk-empty-type-scheme [type] [mk-type-scheme [list] type]]

[defn try-get-local-var-type [local-ctx var-name]
  [[func go [cur-ctx]
    [and cur-ctx
      [or
        [try-get [getq cur-ctx vars] var-name]
        [go [try-getq cur-ctx outer]]]]] local-ctx]]

[defn try-get-var-type [gctx local-ctx var-name]
  [if-let [ltype [try-get-local-var-type local-ctx var-name]]
    ltype
    [try-get [getq gctx def-var-types] var-name]]]

[defn params-to-map [params]
  [if [and [lt-s 1 [size params]] [eq-form-word [at params -2] [quote ..]]]
    [kv-mapq params [slice params 0 [sub [size params] 2]]
             rest-param [last params]]
    [kv-mapq params params]]]

[def try-get-macro [extern interpreter try-get-macro]]
[def apply [extern interpreter apply]]

[defn check [gctx level lctx form]
  [ifs
    [is-word form]
    [if-let [type-scheme [try-get-var-type gctx lctx [form-to-word form]]]
      [specialize-type-scheme gctx level type-scheme]
      [do
        [report form not found]
        [generate-fresh-type-var gctx level]]]

    [not [is-list form]]
    [logq-abort check input not a form [identity form]]

    [let [sub-forms [form-to-list form]
          s-form [size sub-forms]
          first-form [first sub-forms]
          n-of-args [dec s-form]]
      [ifs
        [eq-form [quote i32] first-form]
        [do
          [report-when-not [eq n-of-args 1] form expects 1 argument]
          type-i32]

        [eq-form [quote word] first-form]
        [do
          [report-when-not [eq n-of-args 1] form expects 1 argument]
          type-word]

        [eq-form [quote quote] first-form]
        [do
          [report-when-not [eq n-of-args 1] form expects 1 argument]
          type-form]

        [eq-form first-form [quote if]]
        [let-do
          [cond [second sub-forms]
           then-branch [third sub-forms]
           else-branch [fourth sub-forms]
           cond-type [check gctx level lctx cond]
           then-type [check gctx level lctx then-branch]
           else-type [check gctx level lctx else-branch]]
          [report-when-not [eq n-of-args 3] form expects 3 argument]
          [unify-report gctx cond-type type-i32 cond]
          [unify-report gctx then-type else-type then-branch else-branch]
          then-type]

        [eq-form first-form [quote do]]
        [if n-of-args
          [do
            [for i 1 n-of-args
              [check gctx level lctx [at sub-forms i]]]
            [check gctx level lctx [last sub-forms]]]
          type-empty-tuple]

        [eq-form first-form [quote let]]
        [let-do
          [var-values [transient-kv-map]
           let-ctx [kv-mapq vars var-values outer lctx first-form first-form]
           bindings
            [if [lt-s 1 s-form]
              [form-to-list [second sub-forms]]
              [do [report form expects bindings] [list]]]
           n-of-bindings [size bindings]
           level-1 [inc level]]
          [report-when-not [eq n-of-args 2] form expects two arguments]
          [when [lt-s 1 s-form]
            [for-pair i 0 [dec n-of-bindings]
              [let-do
                [var [form-to-word [at bindings i]]
                  value [at bindings [inc i]]
                  val-type [check gctx level-1 let-ctx value]
                  general-val-type [generalize level val-type]]
                [set-kv-map var-values var general-val-type]]]]
          [for i 2 [dec s-form]
            [check gctx level let-ctx [at sub-forms i]]]
          [if [lt-s 2 s-form]
            [check gctx level let-ctx [last sub-forms]]
            type-empty-tuple]]

        [or
          [eq-form first-form [quote func]]
          [eq-form first-form [quote macro]]
          [eq-form first-form [quote fexpr]]]
        [let-do
          [level-1 [inc level]
           func-name [second sub-forms]
           params-form [third sub-forms]
           body [fourth sub-forms]
           params [form-to-list params-form]
           param-ctx [transient-kv-map]
           parsed-params [params-to-map params]
           reg-params-parsed [getq parsed-params params]
           func-type [generate-fresh-type-var gctx level-1]
           func-ctx [kv-mapq vars param-ctx first-form first-form]
           reg-params [growable-list]
           takes-form-params [or [eq-form first-form [quote macro]] [eq-form first-form [quote fexpr]]]]
          [report-when-not [eq n-of-args 3] form expects 3 arguments]
          [set-kv-map param-ctx [form-to-word func-name] [mk-empty-type-scheme func-type]]
          [for-each param reg-params-parsed
            [let-do [tv [if takes-form-params type-form [generate-fresh-type-var gctx level-1]]]
              [set-kv-map param-ctx [form-to-word param] [mk-empty-type-scheme tv]]
              [push reg-params tv]]]
          [let-do
            [opt-rest-param
                [if-let [rest-param [try-getq parsed-params rest-param]]
                  [let-do [tv [if takes-form-params type-form [generate-fresh-type-var gctx level-1]]]
                    [set-kv-map param-ctx [form-to-word rest-param]
                      [mk-empty-type-scheme [type-list tv]]]
                    tv]
                  0]
                return-type [check gctx level-1 func-ctx body]]
            [unify-report gctx
              func-type
              [type-func
                [clone-growable-to-frozen-list reg-params]
                opt-rest-param
                return-type]
              form]
            [when [eq-form first-form [quote macro]]
              [unify-report gctx return-type type-form body]]]
          func-type]

        [eq-form first-form [quote def]]
        [let-do
          [name [second sub-forms]
           value-form [third sub-forms]
           value-type [check gctx [inc level] lctx value-form]
           general-val-type [generalize level value-type]]
          [report-when-not [eq n-of-args 2] form expects 2 arguments]
          [set-kv-map [getq gctx def-var-types] [form-to-word name] general-val-type]
          value-type]

        [eq-form first-form [quote extern]]
        [do
          [for i 1 s-form
            [let [sf [at sub-forms i]]
              [report-when-not [is-word sf] sf expects words]]]
          [generate-fresh-type-var gctx level]]

        [let [eval-context [getq gctx eval-context]]
          [if-let [mac [if-let [w [try-get-form-word first-form]]
                        [try-get-macro eval-context w]
                        0]]
            [let [expanded-form [apply eval-context mac [slice sub-forms 1 s-form]]]
              [check gctx level lctx expanded-form]]
            [let-do
              [func-type [check gctx level lctx first-form]
              arg-types [mutable-list-of-size n-of-args]]
              [for i 0 n-of-args
                [set-array arg-types i [check gctx level lctx [at sub-forms [inc i]]]]]
              [let-do
                [t-res [generate-fresh-type-var gctx level]
                t-func [type-func-no-rest arg-types t-res]]
                [comment
                  [if-let [annotated-type [try-get-def-var-annotated-type gctx first-form]]
                    [unify-report gctx [instantiate-annotated-type gctx 0 annotated-type] t-func form]
                    [do]]]
                [unify-report gctx func-type t-func form]
                t-res]]]]]]]]

[def make-eval-context [extern interpreter make-context]]

[defn make-global-context []
  [kv-mapq
    messages [growable-list]
    def-var-types [transient-kv-map]
    type-var-counter [atom 0]
    eval-context [make-eval-context]]]

[def evaluate [extern interpreter evaluate]]

[defn check-top [gctx form]
  [evaluate [getq gctx eval-context] form]
  [check gctx 0 0 form]]

[defn check-top-forms [gctx forms]
  [assert [size forms] check-top-forms expects at least one form]
  [logq we are checking [identity forms]]
  [[func check-top-forms-go [i]
    [if [lt-s i [dec [size forms]]]
      [do
        [check-top gctx [at forms i]]
        [check-top-forms-go [inc i]]]
      [check-top gctx [at forms i]]]] 0]]

[defn internal-to-present-type [internal-type]
  [let [nt internal-type]
    [if [is-type-var nt]
      [let-do [kind [type-var-kind nt]]
        [assert [is-word kind] internal-to-present-type not word type var [identity nt]]
        kind]
      [let [type-name [getq nt type-name]]
        [if
          [eq-word type-name [word func]]
          [let [params [getq nt params]
                n-params [size params]
                opt-rest-param [try-getq nt rest-param]
                result [getq nt result]
                n-present-params [if opt-rest-param [add n-params 2] n-params]
                regular-present-params [list-map param params [internal-to-present-type param]]
                present-params
                [if opt-rest-param
                  [concat regular-present-params [list [quote ..] [internal-to-present-type opt-rest-param]]]
                  regular-present-params]]
              [flist [quote func] [form-list present-params] [internal-to-present-type result]]]

          [let [type-args [getq nt type-args]
                n-of-args [size type-args]
                present-type [mutable-list-of-size [inc n-of-args]]]
            [if n-of-args
              [let-do [present-type [mutable-list-of-size [inc n-of-args]]]
                [set-array present-type 0 [form-word type-name]]
                [for i 0 n-of-args
                  [set-array present-type [inc i] [internal-to-present-type [at type-args i]]]]
                [freeze-mutable-list present-type]
                [form-list present-type]]
              [if [eq-word type-name [word tuple]] [quote unit] [form-word type-name]]]]]]]]]

[defn normalize-deep [internal-type]
  [let-do [nt [normalize-type internal-type]]
    [if [is-type-var nt]
      [assert [is-word [type-var-kind nt]] normalize-deep expected a non-linked type var]
      [if [eq-word [getq nt type-name] [word func]]
        [do
          [for-each p [getq nt params] [normalize-deep p]]
          [if-let [rp [try-getq nt rest-param]]
            [normalize-deep rp]
            [do]]
          [normalize-deep [getq nt result]]]
        [for-each type-arg [getq nt type-args]
          [normalize-deep type-arg]]]]]]

[defn normalize-present-type-scheme [internal-type]
  [normalize-deep internal-type]
  [let-do
       [type-vars [free-type-vars internal-type]
        type-var-counter [atom 0]
        fresh-type-vars [list-map tv type-vars [generate-fresh-type-var-atom type-var-counter 0]]
        subst-assoc-list [mutable-list-of-size [size type-vars]]
        new-present-type-vars [list-map tv fresh-type-vars [internal-to-present-type tv]]]
    [for i 0 [size type-vars]
      [let [tv [at type-vars i]
            new-tv [at fresh-type-vars i]]
        [set-array subst-assoc-list i [list tv new-tv]]]]
    [if [is-empty new-present-type-vars]
      [internal-to-present-type [copy-type subst-assoc-list internal-type]]
      [flist [quote type-scheme]
        [form-list new-present-type-vars]
        [internal-to-present-type [copy-type subst-assoc-list internal-type]]]]]]

[def tests-run-atom [atom 0]]

[defn test-ok-fn [expected-type forms]
  [let [gctx [make-global-context]
        res [check-top-forms gctx forms]
        present-type [normalize-present-type-scheme res]
        messages [getq gctx messages]]
    [do
      [when-not [is-empty messages]
        [for-each message messages
          [log message [meta [getq message form]]]]
        [logq-abort test-ok failed there were errors]]
      [assert [eq-form present-type expected-type] test-ok failed expected type [identity expected-type] but found [identity present-type]]
      [inc-atom tests-run-atom]]]]

[defexpr test-ok [expected-type .. forms]
  [test-ok-fn expected-type forms]]

[defn check1 [form]
  [let [gctx [make-global-context]
        res [check-top gctx form]]
    [do
      [for-each message-obj [getq gctx messages]
        [log [getq message-obj message]]]
      [normalize-present-type-scheme res]]]]

[defn eq-list-of-forms [l1 l2]
  [and [eq [size l1] [size l2]]
    [[func eq-list-of-forms-go [i]
      [if [lt-s i [size l1]]
        [if [eq-form [at l1 i] [at l2 i]]
          [eq-list-of-forms-go [inc i]]
          0]
        1]] 0]]]

[defn test-errors-fn [expected-type expected-messages forms]
  [let-do
   [gctx [make-global-context]
    res [check-top-forms gctx forms]
    present-type [normalize-present-type-scheme res]
    messages [getq gctx messages]]
    [if [is-empty messages]
      [logq-abort test-failed failed there were no errors]
      [when-not [eq [size expected-messages] [size messages]]
        [for-each message messages [log message]]
        [logq-abort test-failed failed expected [size expected-messages] messages but found [size messages]]]]
    [for i 0 [size messages]
      [let-do [expected-message [form-to-list [at expected-messages i]]
               message [getq [at messages i] message]]
        [assert [eq-list-of-forms expected-message message] test-failed failed expected message [identity expected-message] but found [identity message]]]]
    [assert [eq-form present-type expected-type] test-ok failed expected type [identity expected-type] but found [identity present-type]]
    [inc-atom tests-run-atom]]]

[defexpr test-errors [expected-type expected-messages .. forms]
  [test-errors-fn expected-type [form-to-list expected-messages] forms]]

[comment variable]
[test-errors [type-scheme [a] a] [[not found]] [do not-found]]

[comment i32]
[test-ok i32 [i32 42]]

[comment word]
[test-ok word [word a]]

[comment quote]
[test-ok form [quote a]]
[test-ok form [quote []]]
[test-ok form [quote [[]]]]
[test-ok form [quote [a []]]]

[comment if]
[test-errors i32 [[not unifiable - different types]] [if [quote ok] [i32 5] [i32 5]]]
[test-errors i32 [[not unifiable - different types]] [if [i32 5] [i32 5] [quote a]]]
[test-errors form [[not unifiable - different types]] [if [i32 5] [quote a] [i32 5]]]
[test-ok i32 [if [i32 5] [i32 6] [i32 7]]]
[test-ok i32 [quote a] [if [i32 5] [i32 6] [i32 7]]]
[test-ok form [if [i32 5] [quote a] [quote b]]]

[comment do]
[test-ok unit [do]]
[test-errors [type-scheme [a] a] [[not found]] [do v]]
[test-errors unit [[not found]] [do v [do]]]
[test-errors [type-scheme [a] a] [[not found]] [do [do] v]]
[test-ok form [do [quote a]]]
[test-ok i32 [do [quote a] [i32 3]]]

[comment let]
[test-errors unit [[expects two arguments]] [let []]]
[test-ok form [let [] [quote a]]]
[test-ok form [let [v [quote a]] v]]
[test-ok form [let [v [quote a] u v] u]]

[comment func]
[comment function parameters cannot be polymorphically instantiated]
[test-errors [type-scheme [a] [func [[func [i32] a]] a]] [[not unifiable  - different types]]
  [func f [i]
    [do
      [i [i32 5]]
      [i [quote a]]]]]
[test-ok [type-scheme [a] [func [[func [i32] a]] a]]
  [func f [i]
    [i [i32 5]]]]
[test-ok
  [type-scheme [a] [func [.. a] [list a]]]
  [func list [.. entries] entries]]
[test-ok
  [type-scheme [a b] [func [a b] i32]]
  [func f [x y] [i32 5]]]
[test-ok
  [type-scheme [a] [func [] a]]
  [func diverge [] [diverge]]]
[test-ok
  [func [i32] i32]
  [func f [p]
    [if p
      [i32 2]
      [f [i32 1]]]]]
[test-ok
  [type-scheme [a] [func [.. a] i32]]
  [func f [.. p] [i32 0]]]
[test-ok
  [type-scheme [a] [list a]]
  [[func f [.. p] p]]]
[test-ok
  [list i32]
  [[func f [.. p] p] [i32 5]]]
[test-ok
  [list i32]
  [[func f [.. p] p] [i32 5] [i32 6]]]
[test-errors
  [list i32]
  [[not unifiable - different types]]
  [[func f [.. p] p] [i32 5] [quote a]]]
[test-ok
  [type-scheme [a] [func [a] a]]
  [func id [x] x]]
[test-ok
  [func [i32] i32]
  [if [i32 5]
    [func id-i32 [x] [if x x x]]
    [func id [x] x]]]
[test-errors
  [func [form] i32]
  [[not unifiable - different types]]
  [macro mac-i32 [x] [i32 5]]]
[test-ok
  [func [form] form]
  [macro mac-id [x] x]]
[test-ok
  [func [form] form]
  [fexpr fexpr-id [x] x]]
[test-ok
  [func [form] i32]
  [fexpr fexpr-i32 [x] [i32 5]]]

[comment call]
[test-errors i32 [[not unifiable - different number of parameters]]
  [[func one-param [p] [i32 5]]]]
[test-errors i32 [[not unifiable - different number of parameters]]
  [[func zero-params [] [i32 5]] [quote extra-argument]]]
[test-ok form
  [[func f [i] [i [quote a]]] [func id [x] x]]]
[test-ok form [let [id [func id [x] x]] [do [id [i32 5]] [id [quote a]]]]]
[test-errors [type-scheme [a] a] [[not unifiable - different types]]
  [[i32 5] [i32 6]]]

[comment def]
[test-errors [type-scheme [a] a] [[not found]] [def a a]]
[test-errors [type-scheme [a] a] [[not found]] [def a [do a]]]
[test-errors [type-scheme [a] a] [[not found]] [def a [[func id [x] x] a]]]
[test-ok
  form
  [def d [quote a]]]
[test-ok
  form
  [def d [quote a]]
  d]
[test-ok
  i32
  [def f [func id [x] x]]
  [f [i32 5]]
  [f [i32 6]]]
[test-ok
  form
  [def f [func id [x] x]]
  [f [i32 5]]
  [f [quote a]]]
[test-ok
  [list i32]
  [def list [func list [.. entries] entries]]
  [def test [list [i32 1] [i32 2]]]
  test]
[test-ok form
  [def d [quote a]]
  [def d [quote b]]]
[test-ok [type-scheme [a] [func [.. a] [list a]]]
  [def list [func list [.. entries] entries]]]

[comment extern]
[test-ok [type-scheme [a] a] [extern host size]]

[comment macro expansion]
[test-ok i32
  [def m [macro m [] [quote [i32 5]]]]
  [m]]

[logq tests-run [atom-get tests-run-atom]]
