[load wat.wuns]

[type name []
  [record
    [word word]]]

[type local-context-kind []
  [union [func] [let] [loop]]]

[type primitive-type []
  [record
    [prefix word]
    [bits i32]
    [bytes i32]
    [name word]]]

[def primitive-types-by-name
  [let [m [transient-kv-map]]
    [for-each prefix-bits [list
        [pair [word i] [i32 8]]
        [pair [word u] [i32 8]]

        [pair [word i] [i32 16]]
        [pair [word u] [i32 16]]

        [pair [word i] [i32 32]]
        [pair [word u] [i32 32]]

        [pair [word i] [i32 64]]

        [pair [word f] [i32 32]]
        [pair [word f] [i32 64]]

        [pair [word v] [i32 128]]]
      [let [prefix [pair/fst prefix-bits]
            bits [pair/snd prefix-bits]
            bytes [i32.div-s bits [i32 8]]
            prim-name [concat-words prefix [int-to-word bits]]]
        [set-kv-map m prim-name [primitive-type prefix bits bytes prim-name]]]]
    m]]

[defn primitive-is-wasm-value-type [pt]
  [let
    [prefix [primitive-type/prefix pt] bits [primitive-type/bits pt]]
    [or
      [and [or [eq-word prefix [word i]] [eq-word prefix [word f]]] [or [eq bits [i32 32]] [eq bits [i32 64]]]]
      [eq-word [primitive-type/name pt] [word v128]]]]]

[defn primitive-type-is-integer [p]
  [let [prefix [primitive-type/prefix p]]
    [or [eq-word prefix [word u]] [eq-word prefix [word i]]]]]

[defn primitive-integer-type-min-max-range [pt]
  [switch [primitive-type/prefix pt]
    [[word i]]
    [let [bits [primitive-type/bits pt]
          pow2 [intrinsic i32.shl 1 [dec bits]]]
        [pair [sub 0 pow2] [dec pow2]]]

    [[word u]]
    [let [bits [primitive-type/bits pt]
          pow2 [intrinsic i32.shl 1 bits]]
        [pair 0 [dec pow2]]]

    [logq-abort unsupported literal type]]]

[defn get-primitive [n] [get primitive-types-by-name n]]

[type
  type []
  [union
    [primitive primitive-type]
    [tuple [list type]]
    [pointer name type]
    [array type [option exp]]

    [memory mem-type]
    [func [list type] type]
    [error]
    ]

  mem-type []
  [record [type type] [name name]]

  exp []
  [union
    [literal primitive-type name]
    [call exp [list exp]]

    [var name]
    [if exp exp exp]
    [cast type exp]
    [deref exp]
    [deref-to exp type]
    [assign exp exp]
    [intrinsic name [list exp]]
    [let-loop local-context-kind [list [pair name exp]] [list exp]]
    [continue [list [pair name exp]]]
    [do [list exp]]
    [size-of type]
    [index exp exp]
    [array type [list exp]]
    [tuple [list exp]]

    [import name name import-kind]
    ]

  import-kind []
  [union
    [memory type i32 [option i32]]
    [function [list type] type]]]

[defn may-side-effect [e]
  [match e
    [exp/literal - --] false
    [exp/var -] false
    [exp/cast - e] [may-side-effect e]
    true]]

[comment
    [field exp name]
]

[type exp-function []
  [record
    [name name]
    [params [list [pair name type]]]
    [return-type type]
    [bodies [list exp]]]]

[type top-exp []
  [union
    [constant name exp]
    [function exp-function]]]

[type local-context []
  [union
    [empty]
    [frame local-context [transient-kv-map word type] local-context-kind]]]

[defn local-context-make [outer vars kind]
  [local-context/frame outer vars kind]]

[defn local-context-make-top [vars kind]
  [local-context/frame [local-context/empty] vars kind]]

[defn try-get-local [lctx name]
  [loop [cur lctx]
    [match cur
      [local-context/empty]
      [option/none]

      [local-context/frame outer names kind]
      [if-let [v [try-get names name]]
        [option/some [pair v kind]]
        [continue cur outer]]]]]

[defn try-get-enclosing-loop-context [lctx]
  [loop [cur lctx]
    [match cur
      [local-context/empty]
      [option/none]

      [local-context/frame outer names kind]
      [match kind
        [local-context-kind/loop]
        [option/some names]

        [local-context-kind/let]
        [continue cur outer]

        [local-context-kind/func]
        [option/none]]]]]

[defn try-get-pointer-args [t]
  [match t
    [type/pointer m p]
    [option/some [pair m p]]

    [option/none]]]

[defn try-get-array-args [t]
  [match t
    [type/array et opt-size-exp]
    [option/some [pair et opt-size-exp]]

    [option/none]]]

[defn make-top-names []
  [let [top-names [transient-kv-map]]
    top-names]]

[def type-primitive-i32 [get-primitive [word i32]]]
[def type-primitive-i64 [get-primitive [word i64]]]

[def type-i32 [type/primitive type-primitive-i32]]
[def type-i64 [type/primitive type-primitive-i64]]
[def type-f64 [type/primitive [get-primitive [word f64]]]]
[def type-empty-tuple [type/tuple [list]]]

[defn try-get-primitive [t]
  [match t
    [type/primitive p]
    [option/some p]
    [option/none]]]

[defn option-get [opt]
  [match opt
    [option/some v] v
    [option/none] [logq-abort option-get none]]]

[defn option-pair [opt1 opt2]
  [match opt1
    [option/some v1]
    [match opt2
      [option/some v2]
      [option/some [pair v1 v2]]
      [option/none]]
    [option/none]]]

[load interpreter-externs.wuns]

[type top-desc-kind []
  [union
    [constant]
    [function]]]

[type desc-kind []
  [union
    [local local-context-kind]
    [top top-desc-kind]]]

[defmacro error [form .. message]
  [flist [quote error-form-fn] form [quote-list message]]]

[defmacro error-exp [exp .. message]
  [flist [quote error-exp-fn] exp [quote-list message]]]

[defn translate-literal [pt]
  [switch [primitive-type/name pt]
    [[word i32]] wat-inst/i32.const
    [[word i64]] wat-inst/i64.const
    [[word f32]] wat-inst/f32.const
    [[word f64]] wat-inst/f64.const
    [if [or [eq-word [primitive-type/prefix pt] [word u]] [eq-word [primitive-type/prefix pt] [word i]]]
      wat-inst/i64.const
      [logq-abort translate-literal not implemented [identity pt]]]]]

[defn const-exp-to-inst [e]
  [match e
    [exp/literal pt n] [option/some [[translate-literal pt] [name/word n]]]
    [exp/cast t e] [const-exp-to-inst e]

    [option/none]]]

[defn prim-types-to-load-inst-name [dst src]
  [let [prefix [concat-words [primitive-type/name dst] [word .load]]]
    [if [is-identical dst src]
      prefix
      [do
        [assert [primitive-type-is-integer src] load expected integer type source]
        [concat-words prefix
          [concat-words [int-to-word [primitive-type/bits src]]
            [concat-words [word -] [if [eq-word [primitive-type/prefix src] [word u]] [word u] [word s]]]]]]]]]

[defn prim-types-to-store-inst-name [target-prim value-prim]
  [if [and [is-identical target-prim value-prim] [primitive-is-wasm-value-type target-prim]]
    [concat-words [primitive-type/name target-prim] [word .store]]
    [if-not [or [is-identical value-prim type-primitive-i32]
                [is-identical value-prim type-primitive-i64]]
      [concat-words
        [word i64.store]
        [int-to-word [primitive-type/bits target-prim]]]
      [do
        [assert [primitive-type-is-integer target-prim] store expected integer type]
        [concat-words
          [concat-words [primitive-type/name value-prim] [word .store]]
          [int-to-word [primitive-type/bits target-prim]]]]]]]

[defn bind [evaluator errors top-names]
  [let
    [name-to-desc [transient-kv-map]]
    [letfn [
[func error-form-fn [form message-form]
  [push errors [pair form message-form]]]

[func error-exp-fn [exp message-form]
  [logq-abort error-exp [identity exp] [identity message-form]]]

[func get-word [f]
  [if-let [w [try-get-word f]]
    w
    [do
      [error f expected word]
      [word --not-a-word--]]]]
[func get-list [f]
  [if-let [w [try-get-list f]]
    w
    [do
      [error f expected list]
      [list]]]]
[func form-to-name [f]
  [if-let [w [try-get-word f]]
    [name w]
    [logq-abort expected word [identity f]]]]

[func try-lookup-bind-name [lctx name]
  [let
    [name-word [name/word name]
     opt-desc
     [if-let [ldesc [try-get-local lctx name-word]]
      [option/some [pair [pair/fst ldesc] [desc-kind/local [pair/snd ldesc]]]]
      [if-let [td [try-get top-names name-word]]
        [option/some [pair [pair/fst td] [desc-kind/top [pair/snd td]]]]
        [option/none]]]]
    [when-let [desc opt-desc]
      [set-kv-map name-to-desc name desc]]
    opt-desc]]

[func form-to-type [lctx form]
  [match form
    [form/word w]
    [type/primitive [get-primitive w]]

    [form/list l]
  [do
    [when [is-empty l] [log-location form]]

    [assert-not [is-empty l] form-to-type expected non-empty list]
    [switch [form-to-word [first l]]
      [[word tuple]]
      [type/tuple [list-map t [slice l 1 [size l]] [form-to-type lctx t]]]

      [[word pointer]]
      [let [mem-name [form-to-name [second l]]]
        [if-let [desc [try-lookup-bind-name lctx mem-name]]
          [match [pair/fst desc]
            [type/memory -]
            [match [pair/snd desc]
              [desc-kind/local -]
              [error [second l] locally defined memory not allowed]

              [desc-kind/top -]
              [do]]

            [logq-abort not a memory type]]
          [logq-abort memory not bound]]
        [type/pointer
          mem-name
          [form-to-type lctx [third l]]]]

      [[word array]]
      [ifs
        [eq [size l] 2]
        [type/array [form-to-type lctx [second l]] [option/none]]

        [eq [size l] 3]
        [type/array [form-to-type lctx [second l]] [option/some [form-to-exp lctx [third l]]]]

        [logq-abort array expected 2 or 3 elements]]

      [logq-abort not implemented type [identity form]]]]]]

[func form-to-import-kind [lctx form]
  [let [l [get-list form]]
    [logq form-to-import-kind [identity l]]
    [assert-not [is-empty l] form-to-import-kind expected non-empty list]
    [switch [form-to-word [first l]]
      [[word memory]]
      [let [mt [form-to-type lctx [second l]]]
        [assert [or [eq [size l] 3] [eq [size l] 4]] import memory expected 3 or 4 elements]
        [logq mt [identity mt]]
        [import-kind/memory
          mt
          [word-to-int [form-to-word [third l]]]
          [if [eq [size l] 3]
            [option/none]
            [option/some [word-to-int [form-to-word [fourth l]]]]]]]

      [[word func]]
      [do
        [assert [eq [size l] 2] import func expected 2 elements]
        [import-kind/function
          [list-map param [get-list [second l]] [form-to-type lctx param]]
          [form-to-type lctx [third l]]]]

      [logq-abort not implemented import-kind [first l]]]]]

[func form-special-to-exp [lctx fw l]
  [switch fw
    [[word if]]
    [exp/if
      [form-to-exp lctx [second l]]
      [form-to-exp lctx [third l]]
      [form-to-exp lctx [fourth l]]]

    [[word cast]]
    [exp/cast
      [form-to-type lctx [second l]]
      [form-to-exp lctx [third l]]]

    [[word import]]
    [exp/import
      [form-to-name [second l]]
      [form-to-name [third l]]
      [form-to-import-kind lctx [fourth l]]]

    [[word deref]]
    [exp/deref [form-to-exp lctx [second l]]]

    [[word deref-to]]
    [exp/deref-to
      [form-to-exp lctx [second l]]
      [form-to-type lctx [third l]]]

    [[word assign]]
    [exp/assign
      [form-to-exp lctx [second l]]
      [form-to-exp lctx [third l]]]

    [[word intrinsic]]
    [exp/intrinsic
      [form-to-name [second l]]
      [list-map arg [slice l 2 [size l]] [form-to-exp lctx arg]]]

    [[word let] [word loop]]
    [let
      [vars [transient-kv-map]
       ll-kind [if [eq-word fw [word let]] [local-context-kind/let] [local-context-kind/loop]]
       let-loop-ctx [local-context-make lctx vars ll-kind]]
      [exp/let-loop ll-kind
        [list-map p [pairwise-pairs [get-list [second l]]]
          [let [pname [form-to-name [pair/fst p]]
                pexp [form-to-exp let-loop-ctx [pair/snd p]]]
            [set-kv-map vars [name/word pname] [type-of pexp]]
            [pair pname pexp]]]
        [list-map b [slice l 2 [size l]] [form-to-exp let-loop-ctx b]]]]

    [[word continue]]
    [if-let [loop-vars [try-get-enclosing-loop-context lctx]]
      [exp/continue
        [list-map p [pairwise-pairs [rest l]]
          [let [n [form-to-name [pair/fst p]]
                e [form-to-exp lctx [pair/snd p]]]
            [if-let [t [try-get loop-vars [name/word n]]]
              [assert [type-equals t [type-of e]] continue expected same type [identity n]]
              [logq-abort continue not a loop var]]
            [pair n e]]]]
      [logq-abort continue not in loop]]

    [[word do]]
    [exp/do [list-map b [rest l] [form-to-exp lctx b]]]

    [[word size-of]]
    [exp/size-of [form-to-type lctx [second l]]]

    [[word index]]
    [exp/index
      [form-to-exp lctx [second l]]
      [form-to-exp lctx [third l]]]

    [[word array]]
    [exp/array
      [form-to-type lctx [second l]]
      [list-map e [slice l 2 [size l]] [form-to-exp lctx e]]]

    [[word tuple]]
    [exp/tuple
      [list-map e [rest l] [form-to-exp lctx e]]]

    [if-let [pt [try-get primitive-types-by-name fw]]
      [let [n [form-to-name [second l]]]
        [switch [primitive-type/prefix pt]
          [[word i] [word u]]
          [let [i [word-to-int [name/word n]]
                range [primitive-integer-type-min-max-range pt]]
            [todo there are issues with word-to-int when integer is greater than 2 to the 31 power]
            [when [lt-s i [pair/fst range]] [error [second l] literal below min]]
            [when [lt-s [pair/snd range] i] [error [second l] literal above max]]]

          [[word f]] [do [word-to-f64 [name/word n]] [do]]

          [logq-abort unsupported literal type]]
        [exp/literal pt n]]
      [logq-abort form-special-to-exp not impl [identity fw]]]]]

[func form-to-exp [lctx f]
  [match f
    [form/word w]
    [let [n [form-to-name f]]
      [if-let [desc [try-lookup-bind-name lctx n]]
        [do]
        [error f not bound]]
      [exp/var n]]

    [form/list l]
    [let [ff [first l]
          args [rest l]]
      [if-let [fw [try-get-word ff]]
        [let [fn [form-to-name ff]]
          [if-let [desc [try-lookup-bind-name lctx fn]]
            [match [pair/fst desc]
              [type/func ps rt]
              [let [cargs [list-map arg args [form-to-exp lctx arg]]]
                [assert [eq [size ps] [size args]] call expected same number of arguments
                  [identity fn] [size ps] [size args]]
                [for i 0 [min [size ps] [size args]]
                  [assert [type-equals [at ps i] [type-of [at cargs i]]]
                    call expected same type [identity fn] [at ps i] [type-of [at cargs i]]]]
                [exp/call [exp/var fn] cargs]]
              [logq-abort not a function type]]
            [if-let [macro-func [try-get-macro evaluator fw]]
              [form-to-exp lctx [apply macro-func args]]
              [form-special-to-exp lctx fw l]]]]
        [logq-abort form-to-exp not a word [identity ff]]]]]]

[func name-to-type [n] [pair/fst [get name-to-desc n]]]

[func exp-equals [e1 e2]
  [match e1
    [exp/literal pt1 n1]
    [match e2
      [exp/literal pt2 n2]
      [do
        [todo normalize here ...]
        [and [is-identical pt1 pt2] [eq-word [name/word n1] [name/word n2]]]]
      false]

    false]]

[func type-equals [t1 t2]
  [match t1
    [type/primitive p1]
    [match t2
      [type/primitive p2]
      [is-identical p1 p2]
      false]

    [type/tuple ts1]
    [match t2
      [type/tuple ts2]
      [and
        [eq [size ts1] [size ts2]]
        [loop [i 0 n [size ts1]]
          [if [lt-s i n]
            [if [type-equals [at ts1 i] [at ts2 i]]
              [continue i [inc i]]
              false]
            true]]]
      false]

    [type/pointer m1 t1]
    [match t2
      [type/pointer m2 t2]
      [and
        [type-equals [name-to-type m1] [name-to-type m2]]
        [type-equals t1 t2]]
      false]

    [type/memory m1]
    [match t2
      [type/memory m2]
      [and
        [type-equals [mem-type/type m1] [mem-type/type m2]]
        [eq-word [name/word [mem-type/name m1]] [name/word [mem-type/name m2]]]]
      false]

    [type/array t1 opt-s1]
    [match t2
      [type/array t2 opt-s2]
      [and
        [type-equals t1 t2]
        [match opt-s1
          [option/none]
          [match opt-s2
            [option/none]
            true

            [option/some s2]
            false]

          [option/some s1]
          [match opt-s2
            [option/none]
            false

            [option/some s2]
            [exp-equals s1 s2]]]]
      false]

    [logq-abort type-equals [identity t1] [identity t2]]]]

[func type-of [exp]
  [match exp
    [exp/literal pt n]
    [type/primitive pt]

    [exp/if c t e]
    [do
      [when-not [type-equals [type-of c] type-i32] [logq-abort eval exp condition not i32]]
      [let [tt [type-of t]]
        [when-not [type-equals tt [type-of e]] [logq-abort eval exp branches not same type]]
        tt]]

    [exp/call f args]
    [match [type-of f]
      [type/func - rt]
      rt

      [logq-abort not a function type]]

    [exp/import n m ik]
    [match ik
      [import-kind/memory et s os]
      [type/memory [mem-type et m]]

      [import-kind/function ps rt]
      [type/func ps rt]

      [logq-abort not implemented type-of import]]

    [exp/cast t e]
    [do
      [if-let [ptp [try-get-pointer-args t]]
        [let [mt [name-to-type [pair/fst ptp]]]
          [match mt
            [type/memory mk]
            [assert [type-equals [mem-type/type mk] [type-of e]]
              cast expected pointer to point to same type [identity mt] [type-of e]]

            [logq-abort not implemented type-of cast]]]
        [logq-abort not implemented type-of cast]]
      t]

    [exp/var n]
    [name-to-type n]

    [exp/intrinsic intrinsic-name args]
    [switch [name/word intrinsic-name]
      [[word i32.add] [word i32.sub] [word i32.mul] [word i32.eq] [word i32.lt-s]]
      [do
        [assert [eq [size args] 2] intrinsic expected 2 arguments]
        [assert [type-equals [type-of [at args 0]] type-i32] intrinsic expected i32 ]
        [assert [type-equals [type-of [at args 1]] type-i32] intrinsic expected i32]
        type-i32]

      [[word unreachable]]
      type-empty-tuple

      [logq-abort not implemented type-of intrinsic [name/word intrinsic-name]]]

    [exp/deref target]
    [if-let [p [try-get-pointer-args [type-of target]]]
      [let [tt [pair/snd p]]
        [if-let [prim [try-get-primitive tt]]
          [if [primitive-is-wasm-value-type prim]
            tt
            [do
              [assert [primitive-type-is-integer prim] deref expected i32 or i64]
              type-i64]]
          tt]]
      [type/error]]

    [exp/deref-to pointer-exp target-type]
    [do
      [if-let [target-prim [try-get-primitive target-type]]
        [if-not [or [is-identical target-prim type-primitive-i32]
                    [is-identical target-prim type-primitive-i64]]
          [error-exp exp only i32 and i64 targets supported for deref-to]
          [if-let [p [try-get-pointer-args [type-of pointer-exp]]]
            [if-let [pointer-prim [try-get-primitive [pair/snd p]]]
              [assert
                [and
                  [primitive-type-is-integer pointer-prim]
                  [lt-s [primitive-type/bits pointer-prim] [primitive-type/bits target-prim]]]
                can only convert to smaller integer type]
                [logq-abort expected primitive types]]
            [error-exp exp not a pointer]]]
        [error-exp exp target-type not a primitive type]]
      target-type]

    [exp/assign dst src]
    [let [tsrc [type-of src]]
      [if-let [pp [try-get-pointer-args [type-of dst]]]
        [let [tdst [pair/snd pp]]
          [when-not [type-equals tdst tsrc]
            [if-let [src-prim [try-get-primitive tsrc]]
              [if-not [or [is-identical src-prim type-primitive-i32] [is-identical src-prim type-primitive-i64]]
                [error-exp exp only i32 and i64 sources supported for heterogenous assign]
                [if-let [dst-prim [try-get-primitive tdst]]
                  [when-not
                    [and
                      [primitive-type-is-integer dst-prim]
                      [lt-s [primitive-type/bits dst-prim] [primitive-type/bits src-prim]]]
                    [error-exp exp can only assign to smaller integer type]]
                  [error-exp exp source-type not a primitive type]]]
              [error-exp exp eval exp expected primitive types]]]]
        [error-exp exp not a pointer]]
      type-empty-tuple]

    [exp/let-loop ll-kind bindings bodies]
    [do
      [for-each binding bindings
        [type-of [pair/snd binding]]]
      [type-ofs bodies]]

    [exp/continue bindings]
    [do
      [for-each binding bindings [type-of [pair/snd binding]]]
      type-empty-tuple]

    [exp/do bodies]
    [type-ofs bodies]

    [exp/size-of t]
    type-i32

    [exp/index a i]
    [if-let [p [try-get-pointer-args [type-of a]]]
      [if-let [par [try-get-array-args [pair/snd p]]]
        [do
          [when-not [type-equals type-i32 [type-of i]] [logq-abort eval exp expected type got]]
          [type/pointer [pair/fst p] [pair/fst par]]]
        [logq-abort not implemented type-of index]]
      [logq-abort not a pointer]]

    [exp/array elem-type elems]
    [do
      [for-each elem elems
        [when-not [type-equals elem-type [type-of elem]] [logq-abort eval exp expected type got]]]
      [type/array elem-type [option/some [exp/literal type-primitive-i32 [name [int-to-word [size elems]]]]]]]

    [exp/tuple elems]
    [if [eq [size elems] 1]
      [type-of [first elems]]
      [type/tuple [list-map e elems [type-of e]]]]

    [logq-abort not implemented type-of [identity exp]]]]

[func type-ofs [bodies]
  [if [is-empty bodies]
    type-empty-tuple
    [type-of [last bodies]]]]

[func bind-top [name-form desc]
  [let [n [get-word name-form]]
    [when [has top-names n]
      [error name-form name already defined]]
    [set-kv-map top-names n desc]]]

[func top-form-to-top-exp [form]
  [let [l [get-list form]]
    [if [is-empty l]
      [do
        [error form expected non-empty list]
        [option/none]]
      [let [f [first l]
            fw [get-word f]]
        [when [has top-names fw]
          [error f top-level calls not yet implemented]]
        [switch fw
          [[word def]]
          [do
            [when-not [eq [size l] 3] [error form expected def name exp-form]]
            [let
              [be [form-to-exp [local-context/empty] [third l]]
               type [type-of be]
               bt [top-exp/constant [form-to-name [second l]] be]]
              [bind-top [second l] [pair type [top-desc-kind/constant]]]
              [option/some bt]]]

          [[word defn]]
          [do
            [when [lt-s [size l] 3]
              [error form function expected name params return-type bodies]]
            [let
              [params-list [get-list [third l]]
               return-type-form [fourth l]
               param-ctx [transient-kv-map]
               lctx [local-context-make-top param-ctx [local-context-kind/func]]
               parameters
               [list-map p [pairwise-pairs params-list]
                 [let [pname [form-to-name [pair/fst p]]
                       ptype [form-to-type lctx [pair/snd p]]]
                  [set-kv-map param-ctx [name/word pname] ptype]
                  [pair pname ptype]]]
               return-type [form-to-type lctx return-type-form]]
              [bind-top [second l]
                [pair
                  [type/func
                    [list-map p parameters [pair/snd p]] return-type] [top-desc-kind/function]]]
              [let
                [cbodies [list-map body [slice l 4 [size l]] [form-to-exp lctx body]]
                 inferred-return-type [type-ofs cbodies]]
                [when-not [type-equals return-type inferred-return-type]
                  [logq-abort return type mismatch [identity return-type] [identity inferred-return-type]]]
                [option/some
                  [top-exp/function
                    [exp-function
                      [form-to-name [second l]]
                      parameters
                      return-type
                      cbodies]]]]]]
          [logq-abort not implemented [identity fw]]]]]]]

[func type-to-wat-type [t]
  [match t
    [type/primitive p]
    [primitive-type/name p]

    [type/pointer mem-name -]
    [match [name-to-type mem-name]
      [type/memory mk]
      [type-to-wat-type [mem-type/type mk]]

      [logq-abort not a memory type]]

    [logq-abort type-to-wat-type [identity t]]]]

[func type-to-wat-types [type]
  [match type
    [type/tuple types]
    [list-map t types [type-to-wat-type t]]

    [list [type-to-wat-type type]]]]

[func type-to-size-of-exp [t]
  [match t
    [type/primitive p]
    [exp/literal type-primitive-i32 [name [int-to-word [primitive-type/bytes p]]]]

    [type/pointer mem-name t]
    [match [name-to-type mem-name]
      [type/memory mk]
      [type-to-size-of-exp [mem-type/type mk]]]

    [type/array et opt-s]
    [if-let [s opt-s]
      [exp/intrinsic [name [word i32.mul]] [list [type-to-size-of-exp et] s]]
      [logq-abort type-to-size-of-exp no size given [identity t]]]

    [type/tuple types]
    [loop [i 0 n [size types] sum [exp/literal type-primitive-i32 [name [int-to-word 0]]]]
      [if [lt-s i n]
        [continue
          sum [exp/intrinsic [name [word i32.add]] [list sum [type-to-size-of-exp [at types i]]]]
          i [inc i]]
        sum]]

    [logq-abort not implemented type-to-size-of-exp [identity t]]]]

[func make-forms-to-inst [glocals]
[letfn [
[func form-to-inst [f]
  [match f
    [exp/import mod-name name ik] [logq-abort inline imports not implemented]
    [exp/cast t e] [form-to-inst e]
    [exp/literal pt n] [[translate-literal pt] [name/word n]]
    [exp/deref target]
    [let
      [pt [type-of target]
       ppt [if-let [p [try-get-pointer-args pt]] p [logq-abort not a pointer]]
       target-prim [option-get [try-get-primitive [pair/snd ppt]]]]
      [wat-inst/load
        [wasm-name-to-wat-byte-array
          [prim-types-to-load-inst-name
            [if [primitive-is-wasm-value-type target-prim] target-prim type-primitive-i64]
            target-prim]]
        [wat-inst-memargs
          [name/word [pair/fst ppt]]
          [word 0]
          [word 1]]
        [form-to-inst target]]]

    [exp/deref-to pexp ttarget]
    [let
      [prim-target [option-get [try-get-primitive ttarget]]
       ppt [option-get [try-get-pointer-args [type-of pexp]]]
       texp [pair/snd ppt]
       prim-exp [option-get [try-get-primitive texp]]
       inst
        [if [or [is-identical prim-target type-primitive-i32] [is-identical prim-target type-primitive-i64]]
          [prim-types-to-load-inst-name prim-target prim-exp]
          [logq-abort not implemented deref-to [primitive-type/name prim-target]]]]
      [wat-inst/load
        [wasm-name-to-wat-byte-array inst]
        [wat-inst-memargs
          [name/word [pair/fst ppt]]
          [word 0]
          [word 1]]
        [form-to-inst pexp]]]

    [exp/assign target value]
    [let
      [ppt [if-let [p [try-get-pointer-args [type-of target]]] p [logq-abort not a pointer]]
       mem-name-word [name/word [pair/fst ppt]]
       go
        [func go [target-inst ttarget value]
          [match ttarget
            [type/primitive pttarget]
            [match [type-of value]
              [type/primitive ptvalue]
              [wat-inst/store
                [wasm-name-to-wat-byte-array [prim-types-to-store-inst-name pttarget ptvalue]]
                [wat-inst-memargs mem-name-word [word 0] [word 1]]
                target-inst
                [form-to-inst value]]

              [logq-abort not implemented assign primitive types]]

            [type/array ttarget-elem ttarget-size-exp-opt]
            [match value
              [exp/array tvalue-elem elems]
              [do
                [assert-not [may-side-effect target] assign target cannot have side effects when assigning arrays]
                [let
                  [size-of-value [type-to-size-of-exp tvalue-elem]
                   size-of-inst [form-to-inst size-of-value]
                   ginsts [growable-list]]
                  [loop [i 0 n [size elems]]
                    [when [lt-s i n]
                      [let
                        [offset-target
                          [wat-inst/inst-word [word i32.add]
                            [list target-inst
                              [wat-inst/inst-word [word i32.mul] [list [wat-inst/i32.const [int-to-word i]] size-of-inst]]]]]
                        [push ginsts [go offset-target ttarget-elem [at elems i]]]
                        [continue i [inc i]]]]]
                  [wat-inst/instructions [clone-growable-to-frozen-list ginsts]]]]

                [logq-abort not implemented assign array types]]

            [type/tuple types]
            [match value
              [exp/tuple elems]
              [do
                [assert-not [may-side-effect target] assign target cannot have side effects when assigning tuples]
                [let
                  [ginsts [growable-list]]
                  [loop [i 0 n [size elems]]
                    [when [lt-s i n]
                      [let
                        [telem [at types i]
                         offset-target
                          [wat-inst/inst-word [word i32.add]
                            [list target-inst [form-to-inst [type-to-size-of-exp telem]]]]]
                        [push ginsts [go offset-target telem [at elems i]]]
                        [continue i [inc i]]]]]
                  [wat-inst/instructions [clone-growable-to-frozen-list ginsts]]]]
              [logq-abort not implemented assign tuple types]]

            [logq-abort not implemented assign type [identity ttarget]]]]]
        [go [form-to-inst target] [pair/snd ppt] value]]

    [exp/intrinsic n args] [wat-inst/inst [wasm-name-to-wat-byte-array [name/word n]] [list-map arg args [form-to-inst arg]]]

    [exp/var n]
    [match [pair/snd [get name-to-desc n]]
      [desc-kind/top td]
      [match td
        [top-desc-kind/constant]
        [wat-inst/global.get [name/word n]]

        [top-desc-kind/function]
        [logq-abort function as value not implemented]]

      [desc-kind/local ld]
      [wat-inst/local.get [name/word n]]]

    [exp/call fexp args]
    [match fexp
      [exp/var fn]
      [wat-inst/call [name/word fn] [list-map arg args [form-to-inst arg]]]
      [logq-abort not implemented call on non-var]]

    [exp/if c t e]
    [wat-inst/if
      [type-to-wat-types [type-of t]]
      [form-to-inst c] [form-to-inst t] [form-to-inst e]]

    [exp/do es]
    [forms-to-inst es]

    [exp/let-loop ll-kind bindings bodies]
    [let
      [bind-insts
       [list-map b bindings
        [let [n [name/word [pair/fst b]]
              e [pair/snd b]]
          [push glocals [pair n [type-to-wat-type [type-of e]]]]
          [wat-inst/local.set n [form-to-inst e]]]]]
      [match ll-kind
        [local-context-kind/let]
        [wat-inst/instructions
          [concat bind-insts [list [forms-to-inst bodies]]]]

        [local-context-kind/loop]
        [wat-inst/instructions
          [concat bind-insts
            [list
              [wat-inst/loop
                [word loop-label]
                [type-to-wat-types [type-ofs bodies]]
                [forms-to-inst bodies]]]]]]]

    [exp/continue assignments]
    [wat-inst/instructions
      [concat
        [list-map a assignments
          [wat-inst/local.set [name/word [pair/fst a]] [form-to-inst [pair/snd a]]]]
        [list [wat-inst/br [word loop-label]]]]]

    [exp/size-of t]
    [form-to-inst [type-to-size-of-exp t]]

    [exp/index a i]
    [if-let [p [try-get-pointer-args [type-of a]]]
      [if-let [par [try-get-array-args [pair/snd p]]]
        [form-to-inst [type-to-size-of-exp [type/array [pair/fst par] [option/some i]]]]
        [logq-abort not implemented type-of index]]
      [logq-abort not a pointer]]

    [exp/tuple elems]
    [wat-inst/instructions [list-map elem elems [form-to-inst elem]]]

    [logq-abort form-to-inst not implemented [identity f]]]]

[func forms-to-inst [forms]
  [wat-inst/instructions
    [if [is-empty forms]
      [list]
      [concat
        [list-map form [slice forms 0 [dec [size forms]]]
          [loop [res [form-to-inst form] i [size [type-to-wat-types [type-of form]]]]
              [if i
                [continue
                  res [wat-inst-word [word drop] res]
                  i [dec i]]
                res]]]
        [list [form-to-inst [last forms]]]]]]]
]
  forms-to-inst]]

[func wuns-to-wat-func [f]
  [let
    [glocals [growable-list]
     body-inst [[make-forms-to-inst glocals] [exp-function/bodies f]]]
    [wat-func
      [name/word [exp-function/name f]]
      [list-map p [exp-function/params f]
        [pair
          [name/word [pair/fst p]]
          [type-to-wat-type [pair/snd p]]]]
      [clone-growable-to-frozen-list glocals]
      [type-to-wat-types [exp-function/return-type f]]
      body-inst]]]

[func compile [tops]
  [let
    [imports [growable-list]
     memories [growable-list]
     globals [growable-list]
     funcs [growable-list]
     exports [growable-list]
     datas [growable-list]]
    [for-each top tops
      [match top
        [top-exp/constant n e]
        [match e
          [exp/import mod-name name ik]
          [push
            imports
            [pair
              [pair [name/word mod-name] [name/word name]]
              [match ik
                [import-kind/function ps rt]
                [wat-import-kind/func
                  [name/word name]
                  [list-map p ps [type-to-wat-type p]]
                  [type-to-wat-types rt]]

                [import-kind/memory mk s os]
                [wat-import-kind/memory
                  [match mk
                    [type/primitive p]
                    [ifs
                      [is-identical p type-primitive-i32] [memory-kind/i32]
                      [is-identical p type-primitive-i64] [memory-kind/i64]
                      [logq-abort not implemented memory-kind [identity p]]]
                    [logq-abort not implemented memory-kind [identity mk]]]
                  s
                  os]]]]

          [if-let [inst [const-exp-to-inst e]]
            [push
              globals
              [wat-global
                [name/word n]
                [type-to-wat-type [type-of e]]
                inst]]
            [logq-abort not a const exp]]]

        [top-exp/function f]
        [push
          funcs
          [wuns-to-wat-func f]]]]

    [wat-output
      imports
      memories
      globals
      funcs
      exports
      datas]]]
]
    [pair
      top-form-to-top-exp
      compile]]]]

[defexpr qlist [.. fs] fs]

[defn make-init-evaluator-async []
  [let [evaluator [make-evaluator]]
    [promise-then
      [evaluate-top-async evaluator [quote [load llmacro.wuns]]]
      [func t [-] evaluator]]]]

[import ./runtime-lib/wabt.js wat-to-wasm-byte-array [func [byte-array] byte-array]]

[type wasm-module [] [union]]

[import ./runtime-lib/wasm.js byte-array-to-wasm-module [func [byte-array] wasm-module]]

[defn forms-to-output [forms]
  [promise-then
    [make-init-evaluator-async]
    [func then [evaluator]
      [let
        [gerrors [growable-list]
         top-names [make-top-names]
         binder-compiler [bind evaluator gerrors top-names]
         top-form-to-top-exp [pair/fst binder-compiler]
         compile-tops [pair/snd binder-compiler]
         top-forms [growable-list]]
        [for-each form forms
          [if-let [top [top-form-to-top-exp form]]
            [push top-forms top]
            [logq-abort no top form for [identity form]]]]
        [let [tops [clone-growable-to-frozen-list top-forms]
              output [compile-tops tops]
              errors [clone-growable-to-frozen-list gerrors]]
          [when-not [is-empty errors]
            [logq there were errors]
            [log errors]
            [for-each e errors
              [logq error [identity e]]]
            [logq-abort errors]]
          [comment [for-each top-form tops [log top-form]]]
          output]]]]]

[defn output-to-module [output]
  [let [wat-string [wat-to-wat-bytes [output-to-wat output]]]
    [comment [byte-array-log-as-string wat-string] ]
    [byte-array-to-wasm-module [wat-to-wasm-byte-array wat-string]]]]

[def prog1 [qlist
[def mem [import env mem [memory i32 1]]]
[defn empty [] [tuple]]
[def bump-top [cast [pointer mem i32] [i32 0]]]
[defn get-top [] i32
  [deref bump-top]]
[defn set-top [new-top i32] [tuple]
  [assign bump-top new-top]]
[def 0 [i32 0]]
[def 1 [i32 1]]
[defn alloc-init [] [tuple]
  [set-top [add [get-top] [i32 16]]]]

[defn alloc-n [n-bytes i32] i32
  [let [top-val [get-top]]
    [when [eq top-val 0] [intrinsic unreachable]]
    [set-top [add top-val n-bytes]]
    top-val]]

[defn inc [x i32] i32 [add x 1]]
[defn dec [x i32] i32 [sub x 1]]

[defn array-f64 [s i32] [pointer mem [array f64]]
  [cast
    [pointer mem [array f64]]
    [alloc-n [size-of [array f64 s]]]]]

[defn array-f64-get [p [pointer mem [array f64]] i i32] f64
  [deref [index p i]]]

[defn array-u8-get [p [pointer mem [array u8]] i i32] i32
  [deref-to [index p i] i32]]

[defn array-i8-get [p [pointer mem [array i8]] i i32] i64
  [deref-to [index p i] i64]]

[defn array-u8-get2 [p [pointer mem [array u8]] i i32] i64
  [deref [index p i]]]

[defn array-i8-get2 [p [pointer mem [array i8]] i i32] i64
  [deref [index p i]]]

[defn array-u8 [s i32] [pointer mem [array u8]]
  [let
    [par
      [cast
        [pointer mem [array u8]]
        [alloc-n [size-of [array u8 s]]]]]
    [loop [i 0]
      [when [lt-s i s]
        [assign [index par i] [u8 0]]]
        [continue i [inc i]]]
    par]]


[defn array-i8 [s i32] [pointer mem [array i8]]
  [let
    [par
      [cast
        [pointer mem [array i8]]
        [alloc-n [size-of [array i8 s]]]]]
    [loop [i 0]
      [when [lt-s i s]
        [assign [index par i] [i8 0]]]
        [continue i [inc i]]]
    par]]

[defn assign-array-test [] [tuple]
  [let
    [par [alloc mem [array i8 [i32 3]]]]
    [assign par [array i8 [i8 11] [i8 12] [i8 13]]]]]

[defn assign-array-test2 [] [tuple]
  [let
    [par [alloc mem [array i32 [i32 3]]]
     22 [i32 22]]
    [assign par [array i32 0 1 22]]]]

[defn assign-array-test3 [] [tuple]
  [let
    [parar [alloc mem [array [array i32 [i32 2]] [i32 2]]]]
    [assign parar
      [array
        [array i32 [i32 2]]
        [array i32 0 1]
        [array i32 1 0]]]]]

[defn assign-tuple [] [tuple]
  [let
    [ptup [alloc mem [tuple f64 i32]]]
    [assign ptup [tuple [f64 1.1] [i32 2]]]]]

[defn mk-2-tup [x i32 y i32] [tuple i32 i32]
  [tuple x y]]
]]

[defn test []
  [promise-then
    [forms-to-output prog1]
    output-to-module]]

[comment
  [bind-forms [def mem [import env mem [memory i32 1]]]]

  ]
