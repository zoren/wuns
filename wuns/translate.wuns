[load wat.wuns]

[defn align [p x]
  [intrinsic i32.and
    [add x [dec p]]
    [intrinsic i32.xor [i32 -1] [dec p]]]]

[type name []
  [record
    [word word]]]

[type local-context-kind []
  [union [func] [let] [loop]]]

[type primitive-type []
  [record
    [prefix word]
    [bytes i32]
    [name word]]]

[defn primitive-type/bits [pt]
  [mul 8 [primitive-type/bytes pt]]]

[def primitive-types-by-name
  [let [m [transient-kv-map]]
    [for-each prefix-bits [list
        [pair [word i] 1]
        [pair [word u] 1]

        [pair [word i] 2]
        [pair [word u] 2]

        [pair [word i] 4]
        [pair [word u] 4]

        [pair [word i] 8]

        [pair [word f] 4]
        [pair [word f] 8]

        [pair [word v] [i32 16]]]
      [let [prefix [pair/fst prefix-bits]
            bytes [pair/snd prefix-bits]
            bits [mul 8 bytes]
            prim-name [concat-words prefix [int-to-word bits]]]
        [set-kv-map m prim-name [primitive-type prefix bytes prim-name]]]]
    m]]

[defn primitive-is-wasm-value-type [pt]
  [let
    [prefix [primitive-type/prefix pt] bits [primitive-type/bits pt]]
    [or
      [and [or [eq-word prefix [word i]] [eq-word prefix [word f]]] [or [eq bits [i32 32]] [eq bits [i32 64]]]]
      [eq-word [primitive-type/name pt] [word v128]]]]]

[defn primitive-type-is-integer [p]
  [let [prefix [primitive-type/prefix p]]
    [or [eq-word prefix [word u]] [eq-word prefix [word i]]]]]

[defn primitive-integer-type-min-max-range [pt]
  [switch [primitive-type/prefix pt]
    [[word i]]
    [let [bits [primitive-type/bits pt]
          pow2 [intrinsic i32.shl 1 [dec bits]]]
        [pair [sub 0 pow2] [dec pow2]]]

    [[word u]]
    [let [bits [primitive-type/bits pt]
          pow2 [intrinsic i32.shl 1 bits]]
        [pair 0 [dec pow2]]]

    [logq-abort unsupported literal type]]]

[defn get-primitive [n] [get primitive-types-by-name n]]

[type
  type []
  [union
    [primitive primitive-type]
    [var name]
    [wildcard name]
    [apply-custom name [list type]]
    [exp exp]
    [tuple [list type]]
    [pointer type type]
    [array type [option type]]
    [record [list [pair name type]]]
    [union [list type]]

    [memory memory-type]
    [func [list type] type]
    [error]
    [empty]
    ]

  memory-type []
  [record [type primitive-type] [name name]]

  exp []
  [union
    [i32 i32]
    [literal primitive-type name]
    [call exp [list exp]]

    [var name]
    [if exp exp exp]
    [switch exp [list [pair [list exp] exp]] exp]
    [cast type exp]
    [deref exp]
    [deref-to exp type]
    [assign exp exp]
    [assign-mutable name exp]
    [intrinsic name [list exp]]
    [let-loop local-context-kind [list [pair name exp]] [list exp]]
    [continue [list [pair name exp]]]
    [do [list exp]]
    [size-of type]
    [index exp exp]
    [field exp name]
    [array type [list exp]]
    [tuple [list exp]]
    [record [list [pair name exp]]]
    [data name exp]
    [memory-static-top name]
    ]]

[defn option-map [f opt]
  [if-let [v opt]
    [option/some [f v]]
    [option/none]]]

[defn type-substitute [type-env outer-t]
  [[func go [t]
    [match t
      [type/var tv]
      [if-let [subst-t [try-get type-env [name/word tv]]]
        subst-t
        [logq-abort type-substitute var not found [identity tv]]]

      [type/wildcard -] t
      [type/primitive -] t
      [type/exp -] t

      [type/apply-custom tn args]
      [type/apply-custom tn [list-map a args [go a]]]

      [type/tuple ts]
      [type/tuple [list-map a ts [go a]]]

      [type/pointer mt pt]
      [type/pointer [go mt] [go pt]]

      [type/array at opt-et]
      [type/array [go at] [option-map go opt-et]]

      [type/record fs]
      [type/record [list-map f fs [pair [pair/fst f] [go [pair/snd f]]]]]

      [type/union ts]
      [type/union [list-map a ts [go a]]]

      [logq-abort type-substitute not implemented [identity t]]]]
    outer-t]]

[type exp-function []
  [record
    [name name]
    [params [list [pair name type]]]
    [return-type type]
    [bodies [list exp]]]]

[type top-value-kind [] [union [constant] [variable]]]

[def top-value-kind-constant [top-value-kind/constant]]
[def top-value-kind-variable [top-value-kind/variable]]

[type
  type-kind []
  [union
    [datatype]
    [exp type]]]

[def type-kind-datatype [type-kind/datatype]]

[type
  top-decl []
  [union
    [value top-value-kind name exp]
    [function exp-function]
    [import name [list [pair name import-kind-exp]]]
    [memory name memory-exp]
    [export [list name]]
    ]

  memory-exp []
  [record
    [type primitive-type]
    [init-size name]
    [max-size [option name]]]

  import-kind-exp []
  [union
    [memory memory-exp]
    [function [list [pair name type]] type]]]

[type local-context []
  [union
    [empty]
    [frame local-context [transient-kv-map word type] local-context-kind]]]

[defn may-side-effect [e]
  [match e
    [exp/i32 -] false
    [exp/literal - --] false
    [exp/var -] false
    [exp/cast - e] [may-side-effect e]
    [exp/field t -] [may-side-effect t]
    [exp/index t i] [or [may-side-effect t] [may-side-effect i]]
    [exp/intrinsic n args]
    [or
      [eq-word [name/word n] [word unreachable]]
      [exists args may-side-effect]]
    true]]

[defn local-context-make [outer vars kind]
  [local-context/frame outer vars kind]]

[def local-context-empty [local-context/empty]]

[defn local-context-make-top [vars kind]
  [local-context/frame local-context-empty vars kind]]

[defn try-get-local [lctx name]
  [loop [cur lctx]
    [match cur
      [local-context/empty]
      [option/none]

      [local-context/frame outer names kind]
      [if-let [v [try-get names name]]
        [option/some [pair v kind]]
        [continue cur outer]]]]]

[defn try-get-enclosing-loop-context [lctx]
  [loop [cur lctx]
    [match cur
      [local-context/empty]
      [option/none]

      [local-context/frame outer names kind]
      [match kind
        [local-context-kind/loop]
        [option/some names]

        [local-context-kind/let]
        [continue cur outer]

        [local-context-kind/func]
        [option/none]]]]]

[def type-primitive-i32 [get-primitive [word i32]]]
[def type-primitive-i64 [get-primitive [word i64]]]

[def type-i32 [type/primitive type-primitive-i32]]
[def type-i64 [type/primitive type-primitive-i64]]
[def type-f64 [type/primitive [get-primitive [word f64]]]]
[def type-empty-tuple [type/tuple [list]]]
[def type-empty [type/empty]]

[defn option-get [opt]
  [match opt
    [option/some v] v
    [option/none] [logq-abort option-get none]]]

[defn option-pair [opt1 opt2]
  [match opt1
    [option/some v1]
    [match opt2
      [option/some v2]
      [option/some [pair v1 v2]]
      [option/none]]
    [option/none]]]

[load interpreter-externs.wuns]

[type
  top-desc-kind []
  [union
    [value top-value-kind exp]
    [function]
    [import import-kind-desc]
    [memory memory-desc]]

  memory-desc []
  [record
    [type primitive-type]
    [init-size i32]
    [max-size [option i32]]]

  import-kind-desc []
  [union
    [memory memory-desc]
    [function [list [pair name type]] type]]]

[type desc-kind []
  [union
    [local local-context-kind]
    [top top-desc-kind]]]

[defmacro error [form .. message]
  [flist [quote error-form-fn] form [quote-list message]]]

[defmacro error-exp [exp .. message]
  [flist [quote error-exp-fn] exp [quote-list message]]]

[defn translate-literal [pt]
  [switch [primitive-type/name pt]
    [[word i32]] wat-inst/i32.const
    [[word i64]] wat-inst/i64.const
    [[word f32]] wat-inst/f32.const
    [[word f64]] wat-inst/f64.const
    [if [or [eq-word [primitive-type/prefix pt] [word u]] [eq-word [primitive-type/prefix pt] [word i]]]
      wat-inst/i64.const
      [logq-abort translate-literal not implemented [identity pt]]]]]

[defn prim-types-to-load-inst-name [dst src]
  [let [prefix [concat-words [primitive-type/name dst] [word .load]]]
    [if [is-identical dst src]
      prefix
      [do
        [assert [primitive-type-is-integer src] load expected integer type source]
        [concat-words prefix
          [concat-words [int-to-word [primitive-type/bits src]]
            [concat-words [word -] [if [eq-word [primitive-type/prefix src] [word u]] [word u] [word s]]]]]]]]]

[defn prim-types-to-store-inst-name [target-prim value-prim]
  [if [and [is-identical target-prim value-prim] [primitive-is-wasm-value-type target-prim]]
    [concat-words [primitive-type/name target-prim] [word .store]]
    [if-not [or [is-identical value-prim type-primitive-i32]
                [is-identical value-prim type-primitive-i64]]
      [concat-words
        [word i64.store]
        [int-to-word [primitive-type/bits target-prim]]]
      [do
        [assert [primitive-type-is-integer target-prim] store expected integer type]
        [concat-words
          [concat-words [primitive-type/name value-prim] [word .store]]
          [int-to-word [primitive-type/bits target-prim]]]]]]]

[defn try-get-int-const [e]
  [match e
    [exp/i32 i] [option/some i]
    [exp/literal pt n]
    [if [is-identical pt type-primitive-i32]
      [option/some [word-to-int [name/word n]]]
      [option/none]]
    [option/none]]]

[defn mk-exp-i32-add [a b]
  [exp/intrinsic [name [word i32.add]] [list a b]]]

[defn int-exp-add [a b]
  [if-let [i [try-get-int-const a]]
    [if [eq i 0]
      b
      [if-let [j [try-get-int-const b]]
        [exp/i32 [add i j]]
        [mk-exp-i32-add a b]]]
    [if-let [j [try-get-int-const b]]
      [if [eq j 0]
        a
        [mk-exp-i32-add a b]]
      [mk-exp-i32-add a b]]]]

[def int-const-0 [exp/i32 0]]
[def int-const-1 [exp/i32 1]]

[defn mk-exp-i32-mul [a b]
  [exp/intrinsic [name [word i32.mul]] [list a b]]]

[defn int-exp-mul [a b]
  [if-let [i [try-get-int-const a]]
    [ifs
      [eq i 0] int-const-0
      [eq i 1] b
      [if-let [j [try-get-int-const b]]
        [exp/i32 [mul i j]]
        [mk-exp-i32-mul a b]]]
    [if-let [j [try-get-int-const b]]
      [ifs
        [eq j 0] int-const-0
        [eq j 1] a
        [mk-exp-i32-mul a b]]
      [mk-exp-i32-mul a b]]]]

[defn try-get-type-exp [t]
  [match t
    [type/exp e]
    [option/some e]
    [option/none]]]

[defn try-get-type-memory [t]
  [match t
    [type/memory mt]
    [option/some mt]
    [option/none]]]

[defn lift-literal-type [t]
  [match t
    [type/exp e]
    [match e
      [exp/i32 -] type-i32
      [exp/literal pt -] [type/primitive pt]
      t]

    t]]

[defn starts-with-dash [w]
  [eq [char-code-at w 0] [word-to-char-code -]]]

[type type-signature []
  [record
    [kind type-kind]
    [params [list [pair name type-kind]]]]]

[defn intrinsic-type-from-name [n]
  [switch n
    [[word i32.add] [word i32.sub] [word i32.mul]
     [word i32.and] [word i32.or] [word i32.xor]
     [word i32.shl] [word i32.shr-s] [word i32.shr-u]
     [word i32.eq]
     [word i32.lt-s] [word i32.le-s]
     [word i32.gt-s] [word i32.ge-s]]
    [pair [list type-i32 type-i32] type-i32]

    [[word i64.add] [word i64.sub] [word i64.mul]
     [word i64.and] [word i64.or] [word i64.xor]]
    [pair [list type-i64 type-i64] type-i64]

    [[word i64.eq]
     [word i64.lt-s] [word i64.le-s]
     [word i64.gt-s] [word i64.ge-s]]
    [pair [list type-i64 type-i64] type-i32]

    [[word unreachable]]
    [pair [list] type-empty]

    [logq-abort not implemented intrinsic [identity n]]]]

[defn make-forms-to-output [evaluator]
  [let
    [gerrors [growable-list]
     top-names [transient-kv-map]
     name-to-desc [transient-kv-map]
     custom-type-signatures [transient-kv-map]
     custom-types [transient-kv-map]
     active-data-map [transient-kv-map]
     datas [growable-list]]
    [letfn [
[func error-form-fn [form message-form]
  [push gerrors [pair form message-form]]]

[func error-exp-fn [exp message-form]
  [logq-abort error-exp [identity exp] [identity message-form]]]

[func get-word [f]
  [if-let [w [try-get-word f]]
    w
    [do
      [error f expected word]
      [word --not-a-word--]]]]
[func get-list [f]
  [if-let [w [try-get-list f]]
    w
    [do
      [error f expected list]
      [list]]]]
[func form-to-name [f]
  [if-let [w [try-get-word f]]
    [name w]
    [logq-abort expected word [identity f]]]]

[func try-lookup-bind-name [lctx name]
  [let
    [name-word [name/word name]
     opt-desc
     [if-let [ldesc [try-get-local lctx name-word]]
      [option/some [pair [pair/fst ldesc] [desc-kind/local [pair/snd ldesc]]]]
      [if-let [td [try-get top-names name-word]]
        [option/some [pair [pair/fst td] [desc-kind/top [pair/snd td]]]]
        [option/none]]]]
    [when-let [desc opt-desc]
      [set-kv-map name-to-desc name desc]]
    opt-desc]]

[func lookup-bind-name [lctx name]
  [if-let [desc [try-lookup-bind-name lctx name]]
    desc
    [logq-abort not bound [identity name]]]]

[func get-memory-type-from-type [mt]
  [if-let [mem-exp [try-get-type-exp mt]]
    [if-let [mem-type [try-get-type-memory [type-of mem-exp]]]
      mem-type
      [logq-abort expected memory type exp [identity mem-exp]]]
    [logq-abort expected memory type [identity mt]]]]

[func form-to-type [lctx outer-form]
  [letfn [
  [func go [form]
    [match form
    [form/word w]
    [if [starts-with-dash w]
      [type/wildcard [form-to-name form]]
      [type/var [form-to-name form]]]

    [form/list l]
    [let [type-name-word [form-to-word [first l]]
          n-of-args [dec [size l]]]
      [assert-not [is-empty l] form-to-type expected non-empty list]
      [switch type-name-word
        [[word tuple]]
        [type/tuple [list-map t [rest l] [go t]]]

        [[word record]]
        [type/record
          [list-map pf [rest l]
            [let [p [get-list pf]]
              [pair [form-to-name [first p]] [go [second p]]]]]]

        [[word union]]
        [type/union [list-map a [rest l] [go a]]]

        [[word pointer]]
        [do
          [assert [eq n-of-args 2] form-to-type expected 2 elements
            [identity type-name-word] [identity n-of-args]]
          [let [mt [go [second l]]
                target-type [go [third l]]]
            [get-memory-type-from-type mt]
            [type/pointer mt target-type]]]

        [[word exp]]
        [type/exp [const-eval [form-to-exp lctx [second l]]]]

        [[word array]]
        [ifs
          [eq [size l] 2]
          [type/array [go [second l]] [option/none]]

          [eq [size l] 3]
          [type/array [go [second l]] [option/some [go [third l]]]]

          [logq-abort array expected 2 or 3 elements]]

        [if-let [custom-type-signature [try-get custom-type-signatures type-name-word]]
          [let [type-params [type-signature/params custom-type-signature]]
            [assert [eq n-of-args [size type-params]] form-to-type expected same number of arguments
              [identity type-name-word] [size type-params] [identity n-of-args]]
            [type/apply-custom [form-to-name [first l]] [list-map a [rest l] [go a]]]]
          [if-let [p [try-get primitive-types-by-name type-name-word]]
            [do
              [assert [eq n-of-args 0] form-to-type primitive takes no arguments [identity type-name-word]]
              [type/primitive p]]
            [logq-abort not implemented form-to-type [identity form]]]]]]]]]
    [go outer-form]]]

[func type-to-type-kind-opt [arg]
  [match arg
    [type/wildcard wcn] [option/none]
    [type/exp e] [option/some [type-kind/exp [type-of e]]]
    [type/apply-custom tn -args] [option/some [type-signature/kind [get custom-type-signatures [name/word tn]]]]
    [type/primitive -] [option/some type-kind-datatype]
    [type/pointer - --] [option/some type-kind-datatype]
    [type/tuple -] [option/some type-kind-datatype]
    [type/record -] [option/some type-kind-datatype]
    [type/union -] [option/some type-kind-datatype]
    [type/array - --] [option/some type-kind-datatype]
    [logq-abort type-to-type-kind [identity arg]]]]

[func instantiate-custom-type [type-name-word args]
  [if-let [custom-type-signature [try-get custom-type-signatures type-name-word]]
    [let [type-params [type-signature/params custom-type-signature]]
      [assert [eq [size args] [size type-params]] form-to-type expected same number of arguments
        [identity type-name-word] [size type-params] [identity [size args]]]
      [let [tenv [transient-kv-map]]
        [for i 0 [size args]
          [let [param-pair [at type-params i]
                param-kind [pair/snd param-pair]
                arg [at args i]
                arg-kind-opt
                [match arg
                  [type/var tvn] [logq-abort not implemented instantiate-custom-type type-var [identity tvn]]
                  [type-to-type-kind-opt arg]]]
            [when-let [arg-kind arg-kind-opt]
              [assert [type-kind-equals param-kind arg-kind] form-to-type expected same type kind
                [identity type-name-word] [identity param-kind] [identity arg-kind]]]
            [set-kv-map tenv [name/word [pair/fst param-pair]] arg]]]
        [type-substitute tenv [get custom-types type-name-word]]]]
    [logq-abort instantiate-custom-type type not found [identity type-name-word]]]]

[func expand-custom [t]
  [match t
    [type/apply-custom tn args]
    [expand-custom [instantiate-custom-type [name/word tn] args]]

    t]]

[func form-list-to-mem-exp [l]
  [assert [or [eq [size l] 3] [eq [size l] 4]] memory expected 3 or 4 elements]
  [let
    [mt [form-to-type local-context-empty [second l]]
     init-size-name [form-to-name [third l]]
     init-size [word-to-int [name/word init-size-name]]
     - [assert [lt-s 0 init-size] memory init-size must be greater than or equal to 0]
     opt-max
     [if [eq [size l] 3]
       [option/none]
       [let [n [form-to-name [fourth l]] ms [word-to-int [name/word n]]]
        [assert [lt-s init-size ms] memory max-size must be greater than init-size]
        [option/some n]]]]
    [todo check type and size parse and are consistent]
    [match mt
      [type/primitive mpt]
      [do
        [assert [or [type-equals mt type-i32] [type-equals mt type-i64]] memory expected i32 or i64]
        [memory-exp mpt init-size-name opt-max]]
      [logq-abort not implemented memory type [identity mt]]]]]

[func form-to-import-kind [form]
  [let [l [get-list form]]
    [assert-not [is-empty l] form-to-import-kind expected non-empty list]
    [switch [form-to-word [first l]]
      [[word memory]]
      [import-kind-exp/memory [form-list-to-mem-exp l]]

      [[word func]]
      [do
        [assert [eq [size l] 3] import func expected 2 elements]
        [import-kind-exp/function
          [list-map pp [pairwise-pairs [get-list [second l]]]
            [pair [form-to-name [pair/fst pp]] [form-to-type local-context-empty [pair/snd pp]]]]
          [form-to-type local-context-empty [third l]]]]

      [logq-abort not implemented import-kind [first l]]]]]

[func try-get-pointer-args [t]
  [match [expand-custom t]
    [type/pointer m p]
    [option/some [pair m p]]

    [option/none]]]

[func try-get-primitive-exp [e]
  [match e
    [exp/i32 n] [option/some type-primitive-i32]
    [exp/literal pt -] [option/some pt]
    [option/none]]]

[func try-get-primitive [t]
  [match t
    [type/exp e] [try-get-primitive-exp e]
    [type/primitive p] [option/some p]
    [type/apply-custom - --] [try-get-primitive [expand-custom t]]
    [type/pointer mt -] [option/some [get-memory-pointer-type mt]]
    [option/none]]]

[func calc-field-offset [rec-union-type field-name-word]
  [match [expand-custom rec-union-type]
    [type/record field-types]
    [loop [i 0
           res int-const-0
           n [size field-types]]
      [if [lt-s i n]
        [let [fp [at field-types i]
              ft [pair/snd fp]
              fn [name/word [pair/fst fp]]]
          [if [eq-word fn field-name-word]
            [pair res ft]
            [continue res [int-exp-add res [type-to-size-of-integer-exp ft]]
                      i [inc i]]]]
        [logq-abort field not found [identity field-name-word]]]]

    [type/union utypes]
    [if [is-empty utypes]
      [logq-abort union type empty does not allow field access]
      [let [first-pair [calc-field-offset [first utypes] field-name-word]
            first-offset [pair/fst first-pair]]
        [loop [i 1 n [size utypes] field-type [pair/snd first-pair]]
          [if [lt-s i n]
            [let [fp [calc-field-offset [at utypes i] field-name-word]]
              [when-not [exp-equals first-offset [pair/fst fp]]
                [logq-abort union type field offsets do not match]]
              [continue i [inc i] field-type [common-super-type field-type [pair/snd fp]]]]
            [pair first-offset field-type]]]]]

    [logq-abort field type not a pointer]]]

[func common-super-type [pt1 pt2]
  [let [t1 [expand-custom pt1] t2 [expand-custom pt2]]
    [ifs
    [type-assignable t1 t2] t1
    [type-assignable t2 t1] t2
    [match t1
      [type/exp e1]
      [if-let [p1 [try-get-primitive-exp e1]]
        [match t2
          [type/exp e2]
          [if-let [p2 [try-get-primitive-exp e2]]
            [if [is-identical p1 p2]
              [type/primitive p1]
              [logq-abort common-super-type exp types do not match [identity e1] [identity e2]]]
            [logq-abort common-super-type not implemented [identity t2]]]]
          [logq-abort common-super-type not implemented [identity t2]]]

      [logq-abort common-super-type not implemented [identity t1]]]]]]

[func form-special-to-exp [lctx fw l]
  [switch fw
    [[word if]]
    [let [c [form-to-exp lctx [second l]]
          t [form-to-exp lctx [third l]]
          e [form-to-exp lctx [fourth l]]
          tt [type-of t]
          te [type-of e]]
      [when-not [type-assignable type-i32 [type-of c]] [logq-abort if condition not i32]]
      [if [type-equals tt type-empty]
        [do]
        [if [type-equals te type-empty]
          [do]
          [do
            [common-super-type tt te]
            [do]]]]

      [exp/if c t e]]

    [[word switch]]
    [let [disc [form-to-exp lctx [second l]]
          cases
          [list-map c [pairwise-pairs [slice l 3 [dec [size l]]]]
            [pair
              [list-map e [get-list [pair/fst c]]
                [let [v [form-to-exp lctx e]]
                  [assert [type-assignable type-i32 [type-of v]] values should be i32]
                  v]]
              [form-to-exp lctx [pair/snd c]]]]
          default-case [form-to-exp lctx [last l]]]
      [when-not [type-assignable type-i32 [type-of disc]] [logq-abort switch discriminator not i32]]
      [exp/switch disc cases default-case]]

    [[word cast]]
    [let [t [form-to-type lctx [second l]]
          e [form-to-exp lctx [third l]]]
      [if-let [ptp [try-get-pointer-args t]]
        [get-memory-type-from-type [pair/fst ptp]]
        [logq-abort not implemented cast]]
      [exp/cast t e]]

    [[word deref]]
    [exp/deref [form-to-exp lctx [second l]]]

    [[word deref-to]]
    [let [pointer-exp [form-to-exp lctx [second l]]
          target-type [form-to-type lctx [third l]]]
      [if-let [target-prim [try-get-primitive target-type]]
        [if-not [or [is-identical target-prim type-primitive-i32]
                    [is-identical target-prim type-primitive-i64]]
          [error-exp pointer-exp only i32 and i64 targets supported for deref-to]
          [if-let [p [try-get-pointer-args [type-of pointer-exp]]]
            [if-let [pointer-prim [try-get-primitive [pair/snd p]]]
              [assert
                [and
                  [primitive-type-is-integer pointer-prim]
                  [lt-s [primitive-type/bits pointer-prim] [primitive-type/bits target-prim]]]
                can only convert to smaller integer type]
                [logq-abort expected primitive types [identity p]]]
            [error-exp pointer-exp not a pointer]]]
        [error-exp pointer-exp target-type not a primitive type]]
      [exp/deref-to pointer-exp target-type]]

    [[word assign]]
    [let [dst [form-to-exp lctx [second l]]
          src [form-to-exp lctx [third l]]]
      [match [expand-custom [type-of dst]]
        [type/pointer - tdst-orig]
        [let [tdst [expand-custom tdst-orig]
              tsrc [expand-custom [type-of src]]]
          [when-not [type-assignable tdst tsrc]
            [if-let [src-prim [try-get-primitive tsrc]]
              [if-not [or [is-identical src-prim type-primitive-i32] [is-identical src-prim type-primitive-i64]]
                [error [second l] only i32 and i64 sources supported for heterogenous assign]
                [if-let [dst-prim [try-get-primitive tdst]]
                  [when-not
                    [and
                      [primitive-type-is-integer dst-prim]
                      [le-s [primitive-type/bits src-prim] [primitive-type/bits dst-prim]]]
                    [do
                      [log-location [second l]]
                      [logq-abort can only assign to smaller integer type [primitive-type/name dst-prim] [primitive-type/name src-prim]]
                      [error [second l] can only assign to smaller integer type]]]
                  [error [second l] source-type not a primitive type]]]
              [do]]]]
        [logq-abort not a pointer]]
      [exp/assign dst src]]

    [[word assign-mutable]]
    [let [dst-name [form-to-name [second l]]
          desc [lookup-bind-name lctx dst-name]
          src [form-to-exp lctx [third l]]]
      [when-not [type-assignable [name-to-type dst-name] [type-of src]]
        [logq-abort typing assign-mutable failed [name-to-type dst-name] [type-of src]]]
      [match [pair/snd desc]
        [desc-kind/top td]
        [match td
          [top-desc-kind/value v -exp]
          [assert [is-identical v top-value-kind-variable] assign-mutable expected variable]

          [logq-abort not implemented assign-mutable top-desc-kind]]
        [logq-abort not implemented assign-mutable top-desc-kind]]
      [exp/assign-mutable dst-name src]]

    [[word intrinsic]]
    [let [intrinsic-name [form-to-name [second l]]
          args [list-map arg [slice l 2 [size l]] [form-to-exp lctx arg]]
          it [intrinsic-type-from-name [name/word intrinsic-name]]
          params [pair/fst it]]
      [assert [eq [size params] [size args]] intrinsic
        [identity intrinsic-name] expected [size params] arguments but got [size args]]
      [for i 0 [size params]
        [let [p [at params i]
              ta [type-of [at args i]]]
          [assert [type-assignable p ta] intrinsic [identity intrinsic-name] expected [identity p] but got [identity ta]]]]
      [exp/intrinsic intrinsic-name args]]

    [[word let] [word loop]]
    [let
      [vars [transient-kv-map]
       is-let [eq-word fw [word let]]
       ll-kind [if is-let [local-context-kind/let] [local-context-kind/loop]]
       let-loop-ctx [local-context-make lctx vars ll-kind]]
      [exp/let-loop ll-kind
        [list-map p [pairwise-pairs [get-list [second l]]]
          [let [pname [form-to-name [pair/fst p]]
                pexp [form-to-exp let-loop-ctx [pair/snd p]]
                pt [type-of pexp]]
            [set-kv-map vars [name/word pname] [if is-let pt [lift-literal-type pt]]]
            [pair pname pexp]]]
        [list-map b [slice l 2 [size l]] [form-to-exp let-loop-ctx b]]]]

    [[word continue]]
    [if-let [loop-vars [try-get-enclosing-loop-context lctx]]
      [exp/continue
        [list-map p [pairwise-pairs [rest l]]
          [let [n [form-to-name [pair/fst p]]
                e [form-to-exp lctx [pair/snd p]]]
            [if-let [t [try-get loop-vars [name/word n]]]
              [assert [type-assignable t [type-of e]] continue expected same type [identity n]]
              [logq-abort continue not a loop var]]
            [pair n e]]]]
      [logq-abort continue not in loop]]

    [[word do]]
    [exp/do [list-map b [rest l] [form-to-exp lctx b]]]

    [[word size-of]]
    [exp/size-of [form-to-type lctx [second l]]]

    [[word index]]
    [exp/index
      [form-to-exp lctx [second l]]
      [form-to-exp lctx [third l]]]

    [[word field]]
    [let [pexp [form-to-exp lctx [second l]]
          field-name [form-to-name [third l]]
          field-name-word [name/word field-name]
          ppt [if-let [p [try-get-pointer-args [type-of pexp]]] p [logq-abort not a pointer]]]
      [calc-field-offset [pair/snd ppt] field-name-word]
      [exp/field pexp field-name]]

    [[word array]]
    [let [telem [form-to-type lctx [second l]]]
      [exp/array
        telem
        [list-map ef [slice l 2 [size l]]
          [let [ee [form-to-exp lctx ef]
                t-cur-elem [type-of ee]]
            [when-not [type-assignable telem t-cur-elem]
              [logq-abort array expected assignable type
                [identity telem]
                [identity t-cur-elem]
                [type-equals telem t-cur-elem]
                ]]
            ee]]]]

    [[word tuple]]
    [exp/tuple
      [list-map e [rest l] [form-to-exp lctx e]]]

    [[word record]]
    [exp/record
      [list-map p [pairwise-pairs [rest l]]
        [pair [form-to-name [pair/fst p]] [form-to-exp lctx [pair/snd p]]]]]

    [[word data]]
    [let
      [mem-name [form-to-name [second l]]
       data-exp [form-to-exp lctx [third l]]
       mem-desc
        [match [pair/snd [lookup-bind-name lctx mem-name]]
          [desc-kind/local ld] [logq-abort not implemented]

          [desc-kind/top td]
          [match td
            [top-desc-kind/memory md] md
            [top-desc-kind/import id]
            [match id
              [import-kind-desc/memory md] md
              [logq-abort not implemented data import]]
            [logq-abort not implemented data import]]]
       pt [memory-desc/type mem-desc]
       mem-name-word [name/word mem-name]
       offset-atom [get-offset-atom mem-name-word]
       bytes [exp-to-bytes data-exp]
       current-offset [atom-get offset-atom]
       offset-word [int-to-word current-offset]
       n-of-bytes [byte-array-size bytes]
       tpointer [type/pointer [type/exp [exp/var mem-name]] [type-of data-exp]]]
      [atom-set offset-atom [add current-offset [align [i32 16] n-of-bytes]]]
      [push
        datas
        [wat-data/active
          mem-name-word
          [[translate-literal pt] offset-word]
          bytes]]
      [exp/cast
        tpointer
        [if [is-identical pt type-primitive-i32]
          [exp/i32 current-offset]
          [exp/literal pt [name offset-word]]]]]

    [[word memory-static-top]]
    [let [mem-name [form-to-name [second l]]]
      [let [desc [lookup-bind-name lctx mem-name]]
        [match [pair/fst desc]
          [type/memory -]
          [do]

          [logq-abort not a memory type]]]
      [exp/memory-static-top mem-name]]

    [if-let [pt [try-get primitive-types-by-name fw]]
      [let [n [form-to-name [second l]]]
        [switch [primitive-type/prefix pt]
          [[word i] [word u]]
          [let [i [word-to-int [name/word n]]
                range [primitive-integer-type-min-max-range pt]]
            [todo there are issues with word-to-int when integer is greater than 2 to the 31 power]
            [when [lt-s i [pair/fst range]] [error [second l] literal below min]]
            [when [lt-s [pair/snd range] i] [error [second l] literal above max]]]

          [[word f]] [do [word-to-f64 [name/word n]] [do]]

          [logq-abort unsupported literal type]]
        [if [eq-word [word i32] fw]
          [exp/i32 [word-to-int [name/word n]]]
          [exp/literal pt n]]]
      [logq-abort form-special-to-exp not impl [identity fw]]]]]

[func form-to-exp [lctx f]
  [match f
    [form/word w]
    [let [n [form-to-name f]
          desc [lookup-bind-name lctx n]]
      [exp/var n]]

    [form/list l]
    [let [ff [first l]
          args [rest l]]
      [if-let [fw [try-get-word ff]]
        [let [fn [form-to-name ff]]
          [if-let [desc [try-lookup-bind-name lctx fn]]
            [match [pair/fst desc]
              [type/func ps rt]
              [let [cargs [list-map arg args [form-to-exp lctx arg]]]
                [assert [eq [size ps] [size args]] call expected same number of arguments
                  [identity fn] [size ps] [size args]]
                [for i 0 [min [size ps] [size args]]
                  [assert [type-assignable [at ps i] [type-of [at cargs i]]]
                    call expected same type [identity fn] [at ps i] [type-of [at cargs i]]]]
                [exp/call [exp/var fn] cargs]]
              [logq-abort not a function type]]
            [if-let [macro-func [try-get-macro evaluator fw]]
              [form-to-exp lctx [apply macro-func args]]
              [form-special-to-exp lctx fw l]]]]
        [logq-abort form-to-exp not a word [identity ff]]]]]]

[func name-to-type [n]
  [if-let [desc [try-get name-to-desc n]]
    [pair/fst desc]
    [logq-abort name-to-type not found [identity n]]]]

[func get-desc-from-name [n] [pair/snd [get name-to-desc n]]]

[func exp-equals [e1 e2]
  [todo consider const evaling the two expressions]
  [match e1
    [exp/i32 i1]
    [match e2
      [exp/i32 i2]
      [eq i1 i2]

      false]

    [exp/literal pt1 n1]
    [match e2
      [exp/literal pt2 n2]
      [do
        [todo normalize here ...]
        [and [is-identical pt1 pt2] [eq-word [name/word n1] [name/word n2]]]]
      false]

    [exp/var n1]
    [match e2
      [exp/var n2]
      [and
        [eq-word [name/word n1] [name/word n2]]
        [do
          [todo we could allow locally bound variables also...]
          [is-identical [get top-names [name/word n1]] [get top-names [name/word n2]]]]]
        false]
      false]]

[func types-assignable [dargs sargs]
  [and
    [eq [size dargs] [size sargs]]
    [loop [i 0 n [size dargs]]
      [if [lt-s i n]
        [if [type-assignable [at dargs i] [at sargs i]]
          [continue i [inc i]]
          false]
        true]]]]

[func type-assignable [tdst tsrcp]
  [let [tsrc [expand-custom tsrcp]]
    [or
    [match tdst
      [type/wildcard -]
      true

      [type/apply-custom dtn dargs]
      [match tsrc
        [type/apply-custom stn sargs]
        [if
          [eq-word [name/word dtn] [name/word stn]]
          [types-assignable dargs sargs]
          [type-assignable [expand-custom tdst] [expand-custom tsrc]]]

        [type-assignable [expand-custom tdst] tsrc]]

      [type/primitive dpt]
      [match [expand-custom tsrc]
        [type/pointer mt t]
        [is-identical dpt [get-memory-pointer-type mt]]

        [type/exp e]
        [match e
          [exp/i32 -]
          [is-identical dpt type-primitive-i32]

          [exp/literal pt l]
          [is-identical dpt pt]

          [type-equals tdst tsrc]]

        [type-equals tdst tsrc]]

      [type/tuple dts]
      [match tsrc
        [type/tuple sts]
        [types-assignable dts sts]

        [type-equals tdst tsrc]]

      [type/record dfs]
      [match tsrc
        [type/record sfs]
        [and
          [eq [size dfs] [size sfs]]
          [loop [i 0 n [size dfs]]
            [if [lt-s i n]
              [if [let [df [at dfs i] sf [at sfs i]]
                    [and [eq-word [name/word [pair/fst df]] [name/word [pair/fst sf]]]
                         [type-assignable [pair/snd df] [pair/snd sf]]]]
                [continue i [inc i]]
                false]
              true]]]

        [type-equals tdst tsrc]]

      [type/pointer dmem dtarget]
      [match tsrc
        [type/pointer smem starget]
        [and
          [type-equals dmem smem]
          [type-assignable dtarget starget]]

        [type-equals tdst tsrc]]

      [type/array det dopts]
      [match tsrc
        [type/array set sopts]
        [and
          [type-assignable det set]
          [match dopts
            [option/none]
            true

            [option/some dopt]
            [match sopts
              [option/none]
              false

              [option/some sopt]
              [type-assignable dopt sopt]]]]

        [type-equals tdst tsrc]]

      [type-equals tdst tsrc]]]]]

[func types-equal [ts1 ts2]
  [and
    [eq [size ts1] [size ts2]]
    [loop [i 0 n [size ts1]]
      [if [lt-s i n]
        [if [type-equals [at ts1 i] [at ts2 i]]
          [continue i [inc i]]
          false]
        true]]]]

[func type-equals [t1 t2]
  [or [is-identical t1 t2]
    [match t1
    [type/primitive p1]
    [match t2
      [type/primitive p2]
      [is-identical p1 p2]
      false]

    [type/tuple ts1]
    [match t2
      [type/tuple ts2]
      [types-equal ts1 ts2]
      false]

    [type/record ps1]
    [match t2
      [type/record ps2]
      [and
        [eq [size ps1] [size ps2]]
        [loop [i 0 n [size ps1]]
          [if [lt-s i n]
            [if [let [p1 [at ps1 i] p2 [at ps2 i]]
                  [and [eq-word [name/word [pair/fst p1]] [name/word [pair/fst p2]]]
                       [type-equals [pair/snd p1] [pair/snd p2]]]]
              [continue i [inc i]]
              false]
            true]]]

      false]

    [type/union ts1]
    [match t2
      [type/union ts2]
      [and
        [eq [size ts1] [size ts2]]
        [loop [i 0 n [size ts1]]
          [if [lt-s i n]
            [if [type-equals [at ts1 i] [at ts2 i]]
              [continue i [inc i]]
              false]
            true]]]
      false]

    [type/pointer m1 t1]
    [match t2
      [type/pointer m2 t2]
      [and
        [type-equals m1 m2]
        [type-equals t1 t2]]
      false]

    [type/exp e1]
    [match t2
      [type/exp e2]
      [exp-equals e1 e2]
      false]

    [type/memory m1]
    [match t2
      [type/memory m2]
      [and
        [is-identical [memory-type/type m1] [memory-type/type m2]]
        [eq-word [name/word [memory-type/name m1]] [name/word [memory-type/name m2]]]]
      false]

    [type/array t1 opt-s1]
    [match t2
      [type/array t2 opt-s2]
      [and
        [type-equals t1 t2]
        [match opt-s1
          [option/none]
          [match opt-s2
            [option/none]
            true

            [option/some s2]
            false]

          [option/some s1]
          [match opt-s2
            [option/none]
            false

            [option/some s2]
            [type-equals s1 s2]]]]
      false]

    [type/apply-custom tn1 args1]
    [match t2
      [type/apply-custom tn2 args2]
      [if [eq-word [name/word tn1] [name/word tn2]]
        [types-equal args1 args2]
        [type-equals [expand-custom t1] [expand-custom t2]]]
      false]

    [logq-abort type-equals [identity t1] [identity t2]]]]]

[func type-kind-equals [tk1 tk2]
  [or [is-identical tk1 tk2]
    [match tk1
      [type-kind/datatype]
      [match tk2
        [type-kind/datatype]
        true
        false]

      [type-kind/exp e1]
      [match tk2
        [type-kind/exp e2]
        [type-equals e1 e2]

        false]

      [logq-abort type-kind-equals [identity tk1] [identity tk2]]]]]

[func type-of [exp]
  [match exp
    [exp/i32 n]
    [type/exp exp]

    [exp/literal pt n]
    [type/exp exp]

    [exp/if c t e]
    [let [tt [type-of t]
          te [type-of e]]
      [ifs
        [type-equals tt type-empty]
        te

        [type-equals te type-empty]
        tt

        tt]]

    [exp/call f args]
    [match [type-of f]
      [type/func - rt]
      rt

      [logq-abort not a function type]]

    [exp/cast t e]
    t

    [exp/var n]
    [name-to-type n]

    [exp/intrinsic intrinsic-name args]
    [pair/snd [intrinsic-type-from-name [name/word intrinsic-name]]]

    [exp/deref target]
    [if-let [p [try-get-pointer-args [type-of target]]]
      [pair/snd p]
      [logq-abort not a pointer]]

    [exp/deref-to pointer-exp target-type]
    target-type

    [exp/assign dst src]
    type-empty-tuple

    [exp/assign-mutable dst-name src]
    type-empty-tuple

    [exp/let-loop ll-kind bindings bodies]
    [type-ofs bodies]

    [exp/continue bindings]
    type-empty

    [exp/do bodies]
    [type-ofs bodies]

    [exp/size-of t]
    type-i32

    [exp/index a i]
    [do
      [when-not [type-assignable type-i32 [type-of i]] [logq-abort type-of index expected index i32]]
      [if-let [p [try-get-pointer-args [type-of a]]]
        [type/pointer [pair/fst p]
          [match [expand-custom [pair/snd p]]
            [type/array et opt-size-exp]
            et

            [type/tuple ts]
            [match i
              [exp/i32 ii]
              [do
                [assert-not [is-negative ii] index expected non-negative integer]
                [assert [lt-s ii [size ts]] index expected less than tuple size]
                [at ts ii]]

              [logq-abort index on tuple only allowed with constants [identity i]]]

            [logq-abort not implemented type-of index [pair/snd p]]]]
        [logq-abort not a pointer]]]

    [exp/field pexp field-name]
    [let
      [field-name-word [name/word field-name]
       ppt [if-let [p [try-get-pointer-args [type-of pexp]]] p [logq-abort not a pointer]]]
      [type/pointer [pair/fst ppt] [pair/snd [calc-field-offset [pair/snd ppt] field-name-word]]]]

    [exp/array elem-type elems]
    [type/array
      elem-type
      [option/some [type/exp [exp/i32 [size elems]]]]]

    [exp/tuple elems]
    [if [eq [size elems] 1]
      [type-of [first elems]]
      [type/tuple [list-map e elems [type-of e]]]]

    [exp/record pairs]
    [type/record [list-map p pairs [pair [pair/fst p] [type-of [pair/snd p]]]]]

    [exp/data mem-name data-exp]
    [type/pointer [type/exp [exp/var mem-name]] [type-of data-exp]]

    [exp/memory-static-top mem-name]
    [do
      [type/primitive type-primitive-i32]]

    [logq-abort not implemented type-of [identity exp]]]]

[func type-ofs [bodies]
  [if [is-empty bodies]
    type-empty-tuple
    [type-of [last bodies]]]]

[func bind-top [name-form desc]
  [let [n [get-word name-form]]
    [when [has top-names n]
      [error name-form name already defined]]
    [set-kv-map top-names n desc]]]

[func mem-exp-to-mem-kind [mem-exp]
  [memory-desc
    [memory-exp/type mem-exp]
    [word-to-int [name/word [memory-exp/init-size mem-exp]]]
    [if-let [max [memory-exp/max-size mem-exp]]
      [option/some [word-to-int [name/word max]]]
      [option/none]]]]

[func top-form-to-top-decl [form]
  [let [l [get-list form]]
    [if [is-empty l]
      [do
        [error form expected non-empty list]
        [option/none]]
      [let [f [first l]
            fw [get-word f]]
        [when [has top-names fw]
          [error f top-level calls not yet implemented]]
        [switch fw
          [[word def] [word mutable]]
          [do
            [when-not [eq [size l] 3] [error form expected def name exp-form]]
            [let
              [be [form-to-exp local-context-empty [third l]]
               type [type-of be]
               is-mutable [eq-word fw [word mutable]]
               kind [if is-mutable top-value-kind-variable top-value-kind-constant]
               bt [top-decl/value kind [form-to-name [second l]] be]]
              [bind-top [second l] [pair [if is-mutable [lift-literal-type type] type] [top-desc-kind/value kind be]]]
              [option/some bt]]]

          [[word memory]]
          [let [mem-name [form-to-name [second l]]
                mem-exp [form-list-to-mem-exp [rest l]]
                t [type/memory [memory-type [memory-exp/type mem-exp] mem-name]]]
            [bind-top [second l] [pair t [top-desc-kind/memory [mem-exp-to-mem-kind mem-exp]]]]
            [option/some [top-decl/memory [form-to-name [second l]] mem-exp]]]

          [[word export]]
          [option/some
            [top-decl/export
              [list-map fe [rest l]
                [let [n [form-to-name fe]]
                  [lookup-bind-name local-context-empty n]
                  n]]]]

          [[word type]]
          [do
            [for-3 i 1 [size l]
              [let
                [type-name [form-to-word [at l i]]
                 type-params
                 [list-map param-pair [pairwise-pairs [get-list [at l [inc i]]]]
                  [let
                    [pname [form-to-name [pair/fst param-pair]]
                     kind
                      [match [pair/snd param-pair]
                        [form/word w]
                        [switch w
                          [[word datatype]] type-kind-datatype
                          [logq-abort type unknown kind]]

                        [form/list ll]
                        [switch [form-to-word [first ll]]
                          [[word exp]] [type-kind/exp [form-to-type local-context-empty [second ll]]]
                          [logq-abort type unknown kind]]]]
                    [pair pname kind]]]]
              [set-kv-map custom-type-signatures type-name [type-signature type-kind-datatype type-params]]]]
            [for-3 i 1 [size l]
              [let
                [type-name [form-to-word [at l i]]
                 type [form-to-type local-context-empty [at l [add 2 i]]]]
                [set-kv-map custom-types type-name type]]]
          [option/none]]

          [[word import]]
          [let
            [mod-name [form-to-name [second l]]
             import-exps
              [list-map import [slice l 2 [size l]]
                [let [
                  import-list [get-list import]
                  m [form-to-name [first import-list]]
                  ik [form-to-import-kind [second import-list]]
                  t
                  [match ik
                    [import-kind-exp/function ps rt]
                    [type/func [list-map p ps [pair/snd p]] rt]

                    [import-kind-exp/memory mem-exp]
                    [type/memory [memory-type [memory-exp/type mem-exp] m]]

                    [logq-abort not implemented type-of import]]
                  ikd
                  [match ik
                    [import-kind-exp/function ps rt]
                    [import-kind-desc/function ps rt]

                    [import-kind-exp/memory mem-exp]
                    [import-kind-desc/memory [mem-exp-to-mem-kind mem-exp]]

                    [logq-abort not implemented type-of import]]]
                  [bind-top [first import-list] [pair t [top-desc-kind/import ikd]]]
                  [pair m ik]]]]
            [option/some [top-decl/import mod-name import-exps]]]

          [[word defn]]
          [do
            [when [lt-s [size l] 3]
              [error form function expected name params return-type bodies]]
            [let
              [params-list [get-list [third l]]
               return-type-form [fourth l]
               param-ctx [transient-kv-map]
               lctx [local-context-make-top param-ctx [local-context-kind/func]]
               parameters
               [list-map p [pairwise-pairs params-list]
                 [let [pname [form-to-name [pair/fst p]]
                       ptype [form-to-type lctx [pair/snd p]]]
                  [set-kv-map param-ctx [name/word pname] ptype]
                  [pair pname ptype]]]
               return-type [form-to-type lctx return-type-form]]
              [bind-top [second l]
                [pair
                  [type/func
                    [list-map p parameters [pair/snd p]] return-type] [top-desc-kind/function]]]
              [let
                [cbodies [list-map body [slice l 4 [size l]] [form-to-exp lctx body]]
                 inferred-return-type [type-ofs cbodies]]
                [when-not [type-assignable [expand-custom return-type] [expand-custom inferred-return-type]]
                  [log return-type]
                  [log [expand-custom return-type]]
                  [log inferred-return-type]
                  [log [expand-custom inferred-return-type]]
                  [logq-abort return type mismatch [form-to-word [second l]]]]
                [option/some
                  [top-decl/function
                    [exp-function
                      [form-to-name [second l]]
                      parameters
                      return-type
                      cbodies]]]]]]
          [logq-abort not implemented [identity fw]]]]]]]

[func get-memory-pointer-type [mt] [memory-type/type [get-memory-type-from-type mt]]]

[func type-to-wat-type [t]
  [match [expand-custom t]
    [type/primitive p]
    [if [and [primitive-type-is-integer p] [lt-s [primitive-type/bits p] [i32 32]]]
      [word i64]
      [primitive-type/name p]]

    [type/exp e]
    [match e
      [exp/i32 -]
      [word i32]

      [exp/literal pt n]
      [primitive-type/name pt]

      [logq-abort not implemented type-to-wat-type [identity e]]]

    [type/pointer mt -]
    [primitive-type/name [get-memory-pointer-type mt]]

    [logq-abort type-to-wat-type [identity t]]]]

[func type-to-wat-types [type]
  [match type
    [type/tuple types]
    [list-map t types [type-to-wat-type t]]

    [type/empty]
    [list]

    [list [type-to-wat-type type]]]]

[func type-to-size-of-integer-exp [t]
  [match [lift-literal-type [expand-custom t]]
    [type/primitive p]
    [exp/i32 [primitive-type/bytes p]]

    [type/exp e]
    [type-to-size-of-integer-exp [type-of e]]

    [type/pointer mt t]
    [exp/i32 [primitive-type/bytes [get-memory-pointer-type mt]]]

    [type/array et opt-st]
    [if-let [size-type opt-st]
      [match size-type
        [type/exp size-exp]
        [int-exp-mul [type-to-size-of-integer-exp et] [const-eval size-exp]]]
      [logq-abort type-to-size-of-integer-exp no size given [identity t]]]

    [type/tuple types]
    [loop [i 0
           n [size types]
           sum int-const-0]
      [if [lt-s i n]
        [continue
          sum [int-exp-add sum [type-to-size-of-integer-exp [at types i]]]
          i [inc i]]
        sum]]

    [type/record fields]
    [loop [i 0
           n [size fields]
           sum int-const-0]
      [if [lt-s i n]
        [continue
          sum [int-exp-add sum [type-to-size-of-integer-exp [pair/snd [at fields i]]]]
          i [inc i]]
        sum]]

    [logq-abort not implemented type-to-size-of-integer-exp [expand-custom t] [identity t]]]]

[func const-eval [exp]
  [match exp
    [exp/var var-name]
    [match [get-desc-from-name var-name]
      [desc-kind/local ld] exp
      [desc-kind/top td]
      [match td
        [top-desc-kind/value value-kind desc-exp]
        [if [is-identical value-kind top-value-kind-constant]
          desc-exp
          exp]
        exp]]

    [exp/size-of t]
    [type-to-size-of-integer-exp t]

    [exp/cast t e]
    [const-eval e]

    exp]]

[func get-offset-atom [mem-name-word]
  [if-let [offset-atom [try-get active-data-map mem-name-word]]
  offset-atom
  [let [oa [atom [i32 16]]]
    [set-kv-map active-data-map mem-name-word oa]
    oa]]]

[func type-to-primitive [t]
  [if-let [pt [try-get-primitive t]]
    pt
    [logq-abort not a primitive type [identity t]]]]

[func exp-to-bytes [e]
  [let
    [bprinter [empty-printer]
     print-int32 [func pi [n-bytes n]
      [loop
        [i 0
         cur n]
        [when [lt-s i n-bytes]
          [print-byte bprinter [intrinsic i32.and [i32 0xff] cur]]
          [continue
            i [inc i]
            cur [intrinsic i32.shr-s cur [i32 8]]]]]]
     go
     [func go [e]
      [match [const-eval e]
        [exp/i32 n]
        [print-int32 4 n]

        [exp/literal pt value-name]
        [let [n-bytes [primitive-type/bytes pt]]
          [assert [eq [intrinsic i32.rem-s [printer-index bprinter] n-bytes] [i32 0]]
            exp-to-bytes expected natural alignment [identity pt]]
          [switch [primitive-type/prefix pt]
            [[word i] [word u]]
            [print-int32 n-bytes [word-to-int [name/word value-name]]]

            [[word f]]
            [loop
              [i 0
               fba [f64-to-byte-array [word-to-f64 [name/word value-name]]]]
              [when [lt-s i n-bytes]
                [print-byte bprinter [byte-array-get fba i]]
                [continue i [inc i]]]]

            [logq-abort not implemented exp-to-bytes literal [identity e]]]]

        [exp/array - es]
        [for-each elem es [go elem]]

        [exp/tuple es]
        [for-each elem es [go elem]]

        [exp/record fields]
        [for-each field fields [go [pair/snd field]]]

        [logq-abort not implemented exp-to-bytes [identity e]]]]]
    [go e]
    [printer-to-byte-array bprinter]]]

[func compile [tops]
  [let
    [imports [growable-list]
     memories [growable-list]
     globals [growable-list]
     funcs [growable-list]
     exports [growable-list]
     glocals-atom [atom [growable-list]]
     type-to-mem-kind
     [func ttmk [p]
      [ifs
        [is-identical p type-primitive-i32] [memory-kind/i32]
        [is-identical p type-primitive-i64] [memory-kind/i64]
        [logq-abort not implemented memory-kind [identity p]]]]]
    [letfn [
[func exp-to-inst [f]
  [match f
    [exp/deref target]
    [let
      [pt [type-of target]
       ppt [if-let [p [try-get-pointer-args pt]] p [logq-abort not a pointer]]
       mt [get-memory-type-from-type [pair/fst ppt]]
       target-prim [type-to-primitive [pair/snd ppt]]]
      [wat-inst/load
        [wasm-name-to-wat-byte-array
          [prim-types-to-load-inst-name
            [if [primitive-is-wasm-value-type target-prim] target-prim type-primitive-i64]
            target-prim]]
        [wat-inst-memargs
          [name/word [memory-type/name mt]]
          [word 0]
          [word 1]]
        [exp-to-inst target]]]

    [exp/deref-to pexp ttarget]
    [let
      [prim-target [option-get [try-get-primitive ttarget]]
       ppt [option-get [try-get-pointer-args [type-of pexp]]]
       mt [get-memory-type-from-type [pair/fst ppt]]
       texp [pair/snd ppt]
       prim-exp [option-get [try-get-primitive texp]]
       inst
        [if [or [is-identical prim-target type-primitive-i32] [is-identical prim-target type-primitive-i64]]
          [prim-types-to-load-inst-name prim-target prim-exp]
          [logq-abort not implemented deref-to [primitive-type/name prim-target]]]]
      [wat-inst/load
        [wasm-name-to-wat-byte-array inst]
        [wat-inst-memargs
          [name/word [memory-type/name mt]]
          [word 0]
          [word 1]]
        [exp-to-inst pexp]]]

    [exp/assign target value]
    [let
      [ppt [if-let [p [try-get-pointer-args [type-of target]]] p [logq-abort not a pointer]]
       mt [get-memory-type-from-type [pair/fst ppt]]
       assign-pointer
       [func assign-pointer [target-int-exp ttarget value]
        [match [lift-literal-type [expand-custom ttarget]]
          [type/primitive pttarget]
          [let
            [normed-t [lift-literal-type [expand-custom [type-of value]]]
             ptvalue [type-to-primitive normed-t]]
            [wat-inst/store
              [wasm-name-to-wat-byte-array [prim-types-to-store-inst-name pttarget ptvalue]]
              [wat-inst-memargs [name/word [memory-type/name mt]] [word 0] [word 1]]
              [exp-to-inst target-int-exp]
              [exp-to-inst value]]]

          [type/pointer tmem ttarget]
          [assign-pointer target-int-exp [type/primitive [get-memory-pointer-type tmem]] value]

          [type/array ttarget-elem ttarget-size-exp-opt]
          [match value
            [exp/array tvalue-elem elems]
            [do
              [assert-not [may-side-effect target] assign target cannot have side effects when assigning arrays]
              [let
                [size-of-int-exp [type-to-size-of-integer-exp tvalue-elem]
                 ginsts [growable-list]]
                [loop [i 0 n [size elems]]
                  [when [lt-s i n]
                    [let
                      [offset-target
                        [int-exp-add
                          target-int-exp
                          [int-exp-mul [exp/i32 i] size-of-int-exp]]]
                      [push ginsts [assign-pointer offset-target ttarget-elem [at elems i]]]
                      [continue i [inc i]]]]]
                [wat-inst/instructions [clone-growable-to-frozen-list ginsts]]]]
              [logq-abort not implemented assign array types]]

          [type/tuple types]
          [match value
            [exp/tuple elems]
            [do
              [assert-not [may-side-effect target] assign target cannot have side effects when assigning tuples]
              [let
                [ginsts [growable-list]]
                [loop [i 0 n [size elems] acc int-const-0]
                  [when [lt-s i n]
                    [let
                      [telem [at types i]
                       offset-target [int-exp-add acc [type-to-size-of-integer-exp telem]]]
                      [push ginsts
                        [assign-pointer [int-exp-add target-int-exp acc] telem [at elems i]]]
                      [continue i [inc i] acc offset-target]]]]
                [wat-inst/instructions [clone-growable-to-frozen-list ginsts]]]]
            [logq-abort not implemented assign tuple types]]

          [type/record field-types]
          [match value
            [exp/record fields]
            [do
              [assert-not [may-side-effect target] assign target cannot have side effects when assigning record]
              [let
                [ginsts [growable-list]]
                [loop [i 0 n [size fields] acc int-const-0]
                  [when [lt-s i n]
                    [let
                      [telem [pair/snd [at field-types i]]
                       offset-target [int-exp-add acc [type-to-size-of-integer-exp telem]]]
                      [push ginsts
                        [assign-pointer [int-exp-add target-int-exp acc] telem [pair/snd [at fields i]]]]
                      [continue i [inc i] acc offset-target]]]]
                [wat-inst/instructions [clone-growable-to-frozen-list ginsts]]]]
            [logq-abort not implemented assign tuple types]]

          [type/union types]
          [logq-abort not implemented assign union types]

          [logq-abort not implemented assign type [identity ttarget] [lift-literal-type [expand-custom ttarget]]]]]]
       [assign-pointer [const-eval target] [pair/snd ppt] value]]

    [exp/assign-mutable dst-name value]
    [wat-inst/global.set [name/word dst-name] [exp-to-inst value]]

    [exp/intrinsic n args]
    [wat-inst/inst [wasm-name-to-wat-byte-array [name/word n]] [list-map arg args [exp-to-inst arg]]]

    [exp/var n]
    [match [get-desc-from-name n]
      [desc-kind/top td]
      [match td
        [top-desc-kind/value - --]
        [wat-inst/global.get [name/word n]]

        [top-desc-kind/function]
        [logq-abort function as value not implemented]]

      [desc-kind/local ld]
      [wat-inst/local.get [name/word n]]]

    [exp/call fexp args]
    [match fexp
      [exp/var fn]
      [wat-inst/call [name/word fn] [list-map arg args [exp-to-inst arg]]]
      [logq-abort not implemented call on non-var]]

    [exp/if c t e]
    [wat-inst/if
      [type-to-wat-types [type-of f]]
      [exp-to-inst c] [exp-to-inst t] [exp-to-inst e]]

    [exp/do es]
    [exps-to-inst es]

    [exp/let-loop ll-kind bindings bodies]
    [let
      [bind-insts
       [list-map b bindings
        [let [n [name/word [pair/fst b]]
              e [pair/snd b]]
          [push [atom-get glocals-atom] [pair n [type-to-wat-type [type-of e]]]]
          [wat-inst/local.set n [exp-to-inst e]]]]]
      [match ll-kind
        [local-context-kind/let]
        [wat-inst/instructions
          [concat bind-insts [list [exps-to-inst bodies]]]]

        [local-context-kind/loop]
        [wat-inst/instructions
          [concat bind-insts
            [list
              [wat-inst/loop
                [word loop-label]
                [type-to-wat-types [type-ofs bodies]]
                [exps-to-inst bodies]]]]]]]

    [exp/continue assignments]
    [wat-inst/instructions
      [concat
        [list-map a assignments
          [wat-inst/local.set [name/word [pair/fst a]] [exp-to-inst [pair/snd a]]]]
        [list [wat-inst/br [word loop-label]]]]]

    [exp/index a index-exp]
    [let [offset
      [if-let [p [try-get-pointer-args [type-of a]]]
        [match [pair/snd p]
          [type/array et opt-size-exp]
          [int-exp-mul [type-to-size-of-integer-exp et] [const-eval index-exp]]

          [type/tuple ts]
          [match index-exp
            [exp/i32 ii]
            [loop [i 0
                   res int-const-0]
              [if [lt-s i ii]
                [continue res [int-exp-add res [type-to-size-of-integer-exp [at ts i]]]
                          i [inc i]]
                res]]

            [logq-abort index on tuple only allowed with constants]]
          [logq-abort not implemented exp-to-inst index]]
        [logq-abort not a pointer]]]
      [exp-to-inst [int-exp-add [const-eval a] offset]]]

    [exp/field a field-name]
    [let
      [field-name-word [name/word field-name]
       offset
       [if-let [p [try-get-pointer-args [type-of a]]]
        [pair/fst [calc-field-offset [pair/snd p] field-name-word]]
        [logq-abort not a pointer]]]
      [exp-to-inst [int-exp-add [const-eval a] offset]]]

    [exp/tuple elems]
    [wat-inst/instructions [list-map elem elems [exp-to-inst elem]]]

    [exp/record fields]
    [logq-abort top-level record not allowed]

    [exp/literal pt n]
    [[translate-literal pt] [name/word n]]

    [exp/i32 n]
    [wat-inst/i32.const [int-to-word n]]

    [exp/cast -t -e]
    [exp-to-inst [const-eval f]]

    [exp/size-of -t]
    [exp-to-inst [const-eval f]]

    [exp/data -mem-name -data-exp]
    [exp-to-inst [const-eval f]]

    [exp/memory-static-top mem-name]
    [wat-inst/i32.const
      [if-let [offset-atom [try-get active-data-map [name/word mem-name]]]
        [int-to-word [atom-get offset-atom]]
        [word 16]]]

    [logq-abort exp-to-inst not implemented [identity f]]]]

[func exps-to-inst [forms]
  [wat-inst/instructions
    [if [is-empty forms]
      [list]
      [concat
        [list-map form [slice forms 0 [dec [size forms]]]
          [loop [res [exp-to-inst form] i [size [type-to-wat-types [type-of form]]]]
              [if i
                [continue
                  res [wat-inst-word [word drop] res]
                  i [dec i]]
                res]]]
        [list [exp-to-inst [last forms]]]]]]]

    ]
    [for-each top tops
      [match top
        [top-decl/memory n mem-exp]
        [push memories
          [wat-memory
            [type-to-mem-kind [memory-exp/type mem-exp]]
            [name/word n]
            [word-to-int [name/word [memory-exp/init-size mem-exp]]]
            [if-let [max [memory-exp/max-size mem-exp]]
              [option/some [word-to-int [name/word max]]]
              [option/none]]]]

        [top-decl/import mod-name exp-imports]
        [let [mod-name-word [name/word mod-name]]
          [for-each import-pair exp-imports
            [let [n [pair/fst import-pair]
                  nw [name/word n]
                  ik [pair/snd import-pair]]
              [push
                imports
                [pair
                  [pair mod-name-word nw]
                  [match ik
                    [import-kind-exp/function ps rt]
                    [wat-import-kind/func
                      nw
                      [list-map p ps [type-to-wat-type [pair/snd p]]]
                      [type-to-wat-types rt]]

                    [import-kind-exp/memory mem-exp]
                    [wat-import-kind/memory
                      nw
                      [type-to-mem-kind [memory-exp/type mem-exp]]
                      [word-to-int [name/word [memory-exp/init-size mem-exp]]]
                      [if-let [max [memory-exp/max-size mem-exp]]
                        [option/some [word-to-int [name/word max]]]
                        [option/none]]]]]]]]]

        [top-decl/export names]
        [for-each n names
          [push exports
            [let [nw [name/word n]
                  ekind
                  [match [get-desc-from-name n]
                    [desc-kind/local -] [logq-abort unreachable export local]
                    [desc-kind/top td]
                    [match td
                      [top-desc-kind/value - --] [export-kind/global]
                      [top-desc-kind/function] [export-kind/func]
                      [top-desc-kind/import -] [logq-abort not implemented export-kind/import]
                      [top-desc-kind/memory -] [export-kind/memory]]]]
              [pair nw [pair ekind nw]]]]]

        [top-decl/value k def-name e]
        [push
          globals
          [wat-global
            [name/word def-name]
            [if [is-identical k top-value-kind-constant] [mut/const] [mut/var]]
            [type-to-wat-type [type-of e]]
            [exp-to-inst e]]]

        [top-decl/function f]
        [let
          [body-inst [exps-to-inst [exp-function/bodies f]]
           locals [clone-growable-to-frozen-list [atom-get glocals-atom]]]
          [atom-set glocals-atom [growable-list]]
          [push
            funcs
            [wat-func
              [name/word [exp-function/name f]]
              [list-map p [exp-function/params f]
                [pair [name/word [pair/fst p]] [type-to-wat-type [pair/snd p]]]]
              locals
              [type-to-wat-types [exp-function/return-type f]]
              body-inst]]]]]

    [wat-output
      imports
      memories
      globals
      funcs
      exports
      datas]]]]
]
    [func f2o [forms]
      [let
        [top-exps [growable-list]]
        [for-each form forms
          [when-let [top [top-form-to-top-decl form]]
            [push top-exps top]]]
        [let [tops [clone-growable-to-frozen-list top-exps]
              output [compile tops]
              errors [clone-growable-to-frozen-list gerrors]]
          [when-not [is-empty errors]
            [logq listing errors]
            [log errors]
            [for-each e errors
              [logq error [identity e]]]
            [logq-abort aborting because of errors]]
          [comment [for-each top-form tops [log top-form]]]
          output]]]]]]
