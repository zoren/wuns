[def - [quote -]]
[def .. [quote ..]]

[defmacro report-when [cond form .. lmsg]
  [list [quote when] cond
    [list [quote report-error] [mk-quote lmsg] form]]]

[defmacro report-when-not [cond form .. lmsg]
  [list [quote when-not] cond
    [list [quote report-error] [mk-quote lmsg] form]]]

[defmacro report [form .. lmsg]
  [list [quote report-error] [mk-quote lmsg] form]]

[defn is-decimal [dw]
  [let [s [size dw]]
    [loop [i [if [eq [at-word dw 0] [quote 45]] 1 0]]
      [if [lt i s]
        [let [c [at-word dw i]]
          [if [and [le [quote 48] c] [le c [quote 57]]]
            [continue i [inc i]]
            0]]
        1]]]]

[defn is-non-negative-decimal [dw]
  [let [s [size dw]]
    [loop [i 0]
      [if [lt i s]
        [let [c [at-word dw i]]
          [if [and [le [quote 48] c] [le c [quote 57]]]
            [continue i [inc i]]
            0]]
        1]]]]

[def type-word [quote word]]
[def type-i32 [quote i32]]
[def type-f64 [quote f64]]
[def type-form [quote form]]
[def type-any [quote any]]
[def type-error [quote type-error]]

[defn is-word-type [t] [or [eq-form t type-word] [eq-form t type-i32]]]

[defn type-list [element-type] [list [quote list] element-type]]
[defn type-tuple [.. types] [concat [quote [tuple]] types]]
[def type-empty [type-tuple]]

[defn is-atomic-type [t]
  [or
    [eq-form t type-form]
    [eq-form t type-word]
    [eq-form t type-i32]
    [eq-form t type-f64]
    [eq-form t type-any]
    [eq-form t type-error]]]

[defn is-mutable-list-type [t] [and [is-list t] [eq [size t] 2] [eq-word [first t] [quote mutable-list]] [is-atomic-type [second t]]]]
[defn is-tuple-type [t] [and [is-list t] [gt [size t] 0] [eq-form [first t] [quote tuple]]]]

[defn is-type [t]
  [or
    [is-atomic-type t]
    [and [is-list t] [eq [size t] 2]
      [or [eq-word [first t] [quote list]] [eq-word [first t] [quote mutable-list]]]
      [is-type [second t]]]
    [and [is-list t] [ge [size t] 1]
      [eq-word [first t] [quote tuple]]
      [loop [i 1]
        [if [lt i [size t]]
          [if [is-type [at t i]]
            [continue i [inc i]]
            0]
          1]]]]]

[defn is-list-or-mut-list-type [t]
  [and [is-list t] [eq [size t] 2]
    [or [eq-word [first t] [quote list]] [eq-word [first t] [quote mutable-list]]]
    [is-type [second t]]]]

[defn is-list-type [t]
  [and [is-list t] [eq [size t] 2]
    [eq-word [first t] [quote list]]
    [is-type [second t]]]]

[defn is-type-list [ts]
  [loop [i 0]
    [if [lt i [size ts]]
      [if [is-type [at ts i]]
        [continue i [inc i]]
        0]
      1]]]

[defn is-pointer-type [t]
  [or [eq-form t type-word] [eq-form t type-form] [is-list-type t]]]

[def errors [mutable-list]]

[defn report-error [msg form]
  [push errors [kv-map message msg form form]]]

[defn check-type [t]
  [report-when-not [is-type t] t not a type]]

[defn check-type-list [ts]
  [loop [i 0]
    [when [lt i [size ts]]
      [let [t [at ts i]]
        [check-type t]
        [continue i [inc i]]]]]
  ts]

[defn check-param-arg-conform [param-type arg-t]
  [or
    [eq-form param-type type-any]
    [eq-form param-type arg-t]
    [and [eq-word param-type type-i32] [is-pointer-type arg-t]]
    [and [eq-word param-type type-form]
      [or [is-word-type arg-t] [is-list-type arg-t]]]
    [and [is-list-type param-type] [is-list-or-mut-list-type arg-t]]
    [and [is-list-type param-type] [is-list-type arg-t]
         [eq [size param-type] [size arg-t]]
         [gt [size param-type] 0]
         [eq-word [first param-type] [first arg-t]]
         [loop [i 1]
           [if [lt i [size param-type]]
             [if [check-param-arg-conform [second param-type] [second arg-t]]
               [continue i [inc i]]
               0]
             1]]]]]

[def global-ctx [transient-kv-map]]

[defn add-sig [name sig-obj]
  [if [has global-ctx name]
    [report name function already defined]
    [set global-ctx name sig-obj]]]

[defn try-get-global-sig [name]
  [if [has global-ctx name]
    [get global-ctx name]
    0]]

[def node-types [transient-kv-map]]

[defn get-node-id [node]
  [getq [meta node] node-id]]

[defn push-node-type [node type]
  [set node-types [get-node-id node] type]
  type]

[defn try-get-node-type [node]
  [let [node-id [get-node-id node]]
    [if [has node-types node-id]
      [get node-types node-id]
      type-error]]]

[def default-memargs [kv-map mem 0 offset 0 align 0]]

[defn check-memargs [form]
  [report-when-not [is-list form] form expects a list]
  [report-when-not [is-odd [size form]] form expects an odd number of elements]
  [let [f [first form]
        tkvm [transient-kv-map]]
    [report-when-not [eq-word f [quote memarg]] f expects a memarg]
    [for-inc i 1 2 [size form]
      [let [k [at form i]
            v [at form [inc i]]]
        [if [is-word k]
          [do
            [report-when-not [has default-memargs k] k unknown memarg key]
            [if [is-non-negative-decimal v]
              [do
                [report-when [has tkvm k] k duplicate memarg key will use last value]
                [set tkvm k v]]
              [report v memarg expects a non-negative decimal]]]
          [report k memarg expects a word]]]]
    [push-node-type form [persistent-kv-map tkvm]]]]

[defn check-form [local-ctx tail-pos form]
  [ifs
    [is-word form]
    [loop [cur-ctx local-ctx]
      [if [eq [size cur-ctx] 1]
        [let [param-ctx [first cur-ctx]]
          [if [has param-ctx form]
            [push-node-type form [get param-ctx form]]
            [let [sig [try-get-global-sig form]]
              [if sig
                [if [eq-word [getq sig def] [quote constant]]
                  [push-node-type form [getq sig constant]]
                  [do
                    [report form not a constant]
                    [log [list [quote c] form [quote not a constant]]]
                    [log global-ctx]
                    type-error]]
                [do
                  [report form symbol not found]
                  type-error]]]]]
        [let [vars [first cur-ctx]]
          [if [has vars form]
            [push-node-type form [get vars form]]
            [continue cur-ctx [second cur-ctx]]]]]]

    [eq-form [size form] 0]
    [do
      [report form empty form]
      type-empty]

    [let [first-form [first form]
          s-form [size form]
          n-of-args [dec s-form]]
      [assert [is-word first-form] expected a word first [identity form]]
      [ifs
        [eq-form first-form [quote tuple]]
        [let
          [res-types [mutable-list]]
          [report-when [eq n-of-args 1] form tuple expects zero or at least two arguments]
          [push res-types [quote tuple]]
          [loop [i 1]
            [when [lt i s-form]
              [push res-types [check-form local-ctx 0 [at form i]]]
              [continue i [inc i]]]]
          res-types]

        [eq-form first-form [quote quote]]
        [do
          [comment todo check if integer or word or list]
          [push-node-type form type-form]
          [if [eq n-of-args 1]
            [let [f [second form]]
              [if [is-list f]
                [type-list type-any]
                type-word]]
            [type-list type-any]]]

        [eq-form first-form [quote if]]
        [do
          [when [gt n-of-args 0]
            [let [c [second form]
                  ct [check-form local-ctx 0 c]]
              [report-when-not [eq-form ct [quote i32]] c condition not i32]]]
          [loop [i 4]
            [when [lt i s-form]
              [check-form local-ctx 1 [at form i]]
              [report [at form i] if extra forms ignored]
              [continue i [inc i]]]]
          [if [gt n-of-args 1]
            [let [tt [check-form local-ctx tail-pos [third form]]
                  ft [if [eq n-of-args 2] type-empty [check-form local-ctx tail-pos [fourth form]]]]
              [push-node-type form
                [if [eq-form tt type-any]
                  ft
                  [if [eq-form ft type-any]
                    tt
                    [do
                      [report-when-not [eq-form tt ft] form if branches must have same type]
                      tt]]]]]]]

        [or
          [eq-form first-form [quote let]]
          [eq-form first-form [quote loop]]]
        [let
          [var-values [transient-kv-map]
           let-loop-ctx [list var-values local-ctx first-form]
           bindings [if [gt s-form 1] [second form] [do [report form expects bindings] []]]
           n-of-bindings [size bindings]]
          [when [lt 1 s-form]
            [let
              [sec [second form]
               bindings [if [is-list sec] sec [do [report sec expects a list of bindings] []]]
               n-of-bindings [size bindings]]
              [report-when-not [is-even n-of-bindings] [last bindings] expects an even number of bindings]
              [loop [i 0]
                [when [lt i [dec n-of-bindings]]
                  [let
                    [var [at bindings i]
                     value [at bindings [inc i]]
                     val-type [check-form let-loop-ctx 0 value]]
                    [set var-values var val-type]
                    [continue i [add i 2]]]]]]]
          [loop [i 2]
            [when [lt i [dec s-form]]
              [check-form let-loop-ctx 0 [at form i]]
              [continue i [inc i]]]]
          [push-node-type form
            [if [lt 2 s-form]
              [check-form let-loop-ctx [if [eq-form first-form [quote loop]] 1 tail-pos] [last form]]
              type-empty]]]

        [eq-form first-form [quote continue]]
        [do
          [loop [cur-ctx local-ctx]
            [if [eq [size cur-ctx] 1]
              [report form continue not inside loop]
              [if [eq-form [quote loop] [third cur-ctx]]
                [let [loop-vars [first cur-ctx]]
                  [report-when-not
                    [is-even n-of-args]
                    form
                    continue takes a list of pairs of bindings]
                  [loop [i 1]
                    [when [lt i n-of-args]
                      [let [var [at form i]
                            value [at form [inc i]]
                            val-type [check-form cur-ctx 0 value]]
                        [if-not [hasq loop-vars var]
                          [report var loop var not found]
                          [let [type [get loop-vars var]]
                            [report-when-not [eq-form type val-type] value type mismatch]]]
                      [continue i [add i 2]]]]]]
                [report-when-not tail-pos form continue not at tail position of loop]
                [continue cur-ctx [second cur-ctx]]]]]
          type-any]

        [eq-form first-form [quote import]]
        [let [module-name [at form 1]
              name [at form 2]
              t [at form 3]]
            [ifs
              [eq-word [first t] [quote func]]
              [let [rs [at t 2]]
                [add-sig name [kv-map
                                parameters [check-type-list [at t 1]]
                                results [if [is-empty rs] type-empty [check-type [first rs]]]
                                def first-form]]]

              []]]

        [eq-form first-form [quote constant]]
        [let [name [second form]
              value [third form]
              value-type [check-form local-ctx 0 value]]
          [add-sig name [kv-map constant value-type
                                def first-form]]]

        [or [eq-form first-form [quote defn]]]
        [let [params
              [if [gt s-form 2]
                [let [l [third form]]
                  [if [is-list l]
                    l
                    [do
                      [report l expected a list of parameters]
                      []]]]
                [do
                  [report form function expects a list of parameters]
                  []]]
              param-ctx [transient-kv-map]
              mut-parameter-type-list [mutable-list]
              n-of-param-words [size params]
              has-rest-param [and [lt 1 n-of-param-words] [eq-form [at params -2] ..]]
              n-of-regular-params [if has-rest-param [sub n-of-param-words 2] n-of-param-words]
              type-annotation
              [if [gt s-form 3]
                [let [anno [fourth form]]
                  [if [and [is-list anno] [eq [size anno] 3]
                        [eq-word [first anno] [quote type]]]
                    [let [anno-params [second anno]
                          anno-results [third anno]]
                      [report-when-not [eq [size anno-params] n-of-param-words] anno-params wrong number of types]
                      [for i 0 n-of-regular-params
                        [check-type [at anno-params i]]]
                      [when [and has-rest-param [lt 1 [size anno-params]]]
                        [let [dd [at anno-params -2]]
                          [report-when-not [eq-word dd ..] dd expected ..]
                          [check-type [last anno-params]]]]
                      [check-type anno-results]
                      [list anno-params anno-results]]
                    [list]]]
                [list]]
              anno-params [if [size type-annotation] [first type-annotation] 0]
              anno-results [if [size type-annotation] [second type-annotation] 0]
              -
              [loop [i 0]
                [when [lt i n-of-regular-params]
                  [let [p [at params i]
                        pt [if anno-params [at anno-params i] [quote i32]]]
                    [report-when [eq-form p ..] p .. must be at second last position]
                    [when-not [eq-form p -]
                      [report-when [has param-ctx p] p duplicate parameter]
                      [push-node-type p pt]
                      [set param-ctx p pt]]
                    [comment todo use a preallocated array instead we know the size in advance]
                    [push mut-parameter-type-list pt]
                    [continue i [inc i]]]]]
              rest-param-element-type
              [if has-rest-param
                [let [p [last params]
                      pt [if anno-params [last anno-params] type-any]]
                  [report-when-not [is-word p] p not a word]
                  [when-not [eq-form p -]
                    [report-when [has param-ctx p] p duplicate parameter]
                    [set param-ctx p [type-list pt]]]
                  pt]
                0]
              func-ctx [list param-ctx [list [kv-map]] first-form]
              parameter-type-list [persistent-array mut-parameter-type-list]
              locals [mutable-list]
              sig-object
              [transient-kv-map [quote parameters] parameter-type-list
                                [quote results] type-any
                                [quote def] first-form]]
            [when rest-param-element-type
              [setq sig-object rest-param-element-type rest-param-element-type]]
            [if [gt s-form 1]
              [let [name [second form]]
                [if [is-word name]
                  [add-sig name sig-object]
                  [report name expected a word here]]]]
            [loop [i 3]
              [when [lt i [dec [size form]]]
                [comment remember to check type is empty maybe even drop unused and warn instead]
                [check-form func-ctx 0 [at form i]]
                [continue i [inc i]]]]
            [let [
              result-type
              [if [gt [size form] 3]
                [check-form func-ctx 0 [last form]]
                type-error]]
              [setq sig-object results result-type]
                ]
[comment
            [when [size type-annotation]
              [when-not [eq-form anno-results result-type]
                [report-error [list [quote func mismatch] result-type anno-results] [last form]]]]]
            ]

        [let [sig [try-get-global-sig first-form]
              sig-def [if [hasq sig def] [getq sig def] 0]]
          [if [not sig]
            [let [instruction [try-get-instruction first-form]]
              [if instruction
                [let [imm-parameters [getq instruction immediate-parameters]
                      parameters [getq instruction parameters]
                      n-of-parameters [add [size imm-parameters] [size parameters]]
                      results [getq instruction results]]
                  [report-when-not [eq n-of-args n-of-parameters] form wrong number of arguments]
                  [for i 0 [size imm-parameters]
                    [let [imm-p [at imm-parameters i]
                          arg [at form [inc i]]]
                      [ifs
                        [eq-word imm-p immediate-s32]
                        [report-when-not [is-decimal arg] arg expects a decimal]

                        [eq-word imm-p immediate-u32]
                        [report-when-not [is-decimal arg] arg expects a decimal]

                        [eq-word imm-p immediate-s64]
                        [report-when-not [is-decimal arg] arg expects a decimal]

                        [eq-word imm-p imm-memarg]
                        [let []
                          [check-memargs arg]
                          ]

                        [assert 0 unknown immediate parameter type [identity imm-p]]]]]
                  [for i 0 [size parameters]
                    [let [arg [at form [inc [add i [size imm-parameters]]]]
                          arg-t [check-form local-ctx 0 arg]
                          pt [at parameters i]]
                        [when-not [check-param-arg-conform pt arg-t]
                          [report-error [concat [quote parameter does not match] [list pt arg-t]] arg]]]]
                  [push-node-type form results]]
                [report form function not found]]]
            [let [parameters [getq sig parameters]
                  n-of-parameters [size parameters]]
              [report-when-not [ge n-of-args n-of-parameters] form
                missing arguments]
              [if [eq-word sig-def [quote macro]]
                []
                [do
                  [loop [i 1]
                    [when [lt i s-form]
                      [let [arg [at form i]
                            arg-t [check-form local-ctx 0 arg]
                            p-index [dec i]]
                        [when [lt p-index n-of-parameters]
                          [let [pt [at parameters p-index]]
                            [when-not [check-param-arg-conform pt arg-t]
                              [report-error [concat [quote parameter does not match] [list pt arg-t]] arg]]]]
                        [continue i [inc i]]]]]
                  [when [hasq sig rest-param-element-type]
                    [loop [i [inc n-of-parameters]]
                      [when [lt i s-form]
                        [report [at form i] extra arguments ignored]
                        [continue i [inc i]]]]
                    [let [rest-param-element-type [getq sig rest-param-element-type]]
                      [loop [i [inc n-of-parameters]]
                        [when [lt i s-form]
                          [let [arg [at form i]
                                arg-t [check-form local-ctx 0 arg]]
                            [report-when-not [check-param-arg-conform rest-param-element-type arg-t] arg
                              rest parameter type mismatch]]
                          [continue i [inc i]]]]]]
                  [push-node-type form [getq sig results]]]]]]]]]]]

[defn check-top-form [form]
  [check-form [list []] 0 form]
  ]

[defn delete-all-keys [o]
  [for-each k [keys o]
    [delete-key o k]]]

[defn check-top-forms [forms]
  [add-sig [quote wuns-active-mem-top] [kv-map constant type-i32 def [quote constant]]]
  [for-each form forms
    [check-top-form form]]
  [when-not [is-empty errors]
    [for-each err errors
      [log [list [getq err message] [getq err form] [getq [meta [getq err form]] range]]]]
    ]
  [let [res
        [kv-map
          errors [persistent-array errors]
          global-ctx [persistent-kv-map global-ctx]
          node-types [persistent-kv-map node-types]]]
      [delete-all-keys global-ctx]
    res]]

[comment
  [check-forms
    [quote
      [defn f [x y] [add x y]]
      [defn g [x y] [sub x y]]]]
  [check-forms [quote [defn f [x y] [add x y]] [defn g [x y] [sub x y]]]]

  [check-forms
    [quote
      [defn f [x y] [add x y]]
      [defn g [x y] [sub x y]]]]
]
