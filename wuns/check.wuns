[def type-word [quote word]]
[def type-form [quote form]]

[def type-i32 i32]
[def type-i64 i64]
[def type-any [quote any]]
[def type-bottom [quote bottom]]
[def type-error [quote type-error]]
[def type-pointer [quote i32]]

[defn is-word-type [t] [eq-form t type-word]]

[defn type-list [element-type] [list [quote list] element-type]]
[defn type-tuple [.. types] [concat [quote [tuple]] types]]
[def type-empty [type-tuple]]

[def atomic-types [quote form word i32 i64 any error]]

[defn is-atomic-type [t]
  [loop [i 0]
    [if [lt-s i [size atomic-types]]
      [if [eq-word t [at atomic-types i]]
        1
        [continue i [inc i]]]
      0]]]

[defn is-mutable-list-type [t] [and [is-list t] [eq [size t] 2] [eq-word [first t] [quote mutable-list]] [is-atomic-type [second t]]]]
[defn is-tuple-type [t] [and [is-list t] [lt-s 0 [size t]] [eq-form [first t] [quote tuple]]]]

[defn is-type [t]
  [or
    [is-atomic-type t]
    [and [is-list t] [eq [size t] 2]
      [or [eq-word [first t] [quote list]] [eq-word [first t] [quote mutable-list]]]
      [recur [second t]]]
    [and [is-list t] [le-s 1 [size t]]
      [eq-word [first t] [quote tuple]]
      [loop [i 1]
        [if [lt-s i [size t]]
          [if [recur [at t i]]
            [continue i [inc i]]
            0]
          1]]]
    [and [is-list t] [eq [size t] 3]
      [eq-word [first t] [quote func]]
      [let [param-types [second t]]
        [and
          [is-list param-types]
          [let [parsed-params [params-to-map param-types]
                regular-params [getq parsed-params params]]
            [and
              [loop [i 1]
                [if [lt-s i [size regular-params]]
                  [if [recur [at regular-params i]]
                    [continue i [inc i]]
                    0]
                  1]]
              [if-let [rest-param [try-getq parsed-params rest-param]]
                [recur rest-param]
                1]]]
          [recur [third t]]]]]]]

[defn is-func-type [t]
  [and [is-list t] [eq [size t] 3]
    [eq-word [first t] [quote func]]
    [is-list [second t]]
    [is-type [third t]]]]

[defn is-list-or-mut-list-type [t]
  [and [is-list t] [eq [size t] 2]
    [or [eq-word [first t] [quote list]] [eq-word [first t] [quote mutable-list]]]
    [is-type [second t]]]]

[defn is-list-type [t]
  [and [is-list t] [eq [size t] 2]
    [eq-word [first t] [quote list]]
    [is-type [second t]]]]

[defn is-form-type [t]
  [or
    [eq-form t type-form]
    [is-word-type t]
    [and [is-list-type t] [recur [second t]]]]]

[comment
  when a varargs function is called we have to find the greatest common type of all the arguments
  and then check that against the parameter type
]

[defn type-less-than-equal [t1 t2]
  [ifs
    [eq-form t1 t2]
    1

    [eq-form t2 type-any]
    1

    [and [eq-form t1 type-bottom] [not [eq-form t2 type-bottom]]]
    1

    [eq-form t2 type-form]
    [is-form-type t1]

    0]]

[defn check-param-arg-conform [param-type arg-t]
  [or
    [type-less-than-equal arg-t param-type]
    [and [is-list-type param-type] [is-list-or-mut-list-type arg-t]]
    [and [is-list-type param-type] [is-list-type arg-t]
      [recur [second param-type] [second arg-t]]]]]

[defn make-check-global-context []
  [kv-map
    messages [growable-list]
    def-var-types [transient-kv-map]]]

[defn set-node-type [gctx node type]
  [comment to do add to map inside gctx]
  type]

[defn set-def-var-type [gctx var type]
  [let [def-var-types [getq gctx def-var-types]]
    [assert [not [has def-var-types var]] [list [quote set-def-var-type] var type]]
    [set def-var-types var type]
    type]]

[defn try-get-local-var-type [local-ctx var-name]
  [loop [cur-ctx local-ctx]
    [if cur-ctx
      [if-let [type [try-get [getq cur-ctx vars] var-name]]
        type
        [if-let [outer [try-getq cur-ctx outer]]
          [if outer
            [continue cur-ctx outer]
            0]
          0]]
      0]]]

[defn try-get-var-type [gctx local-ctx var-name]
  [if-let [ltype [try-get-local-var-type local-ctx var-name]]
    ltype
    [try-get [getq gctx def-var-types] var-name]]]

[defn check-form [gctx local-ctx form]
  [ifs
    [is-word form]
    [if-let [type [try-get-var-type gctx local-ctx form]]
      [do
        [comment we could check for this as it will make compilation difficult
          [report-when-not [is-func-type type] form defed func used as value]]
        [set-node-type gctx form type]]
      [do
        [report form not found]
        [set-node-type gctx form type-any]]]

    [not [is-list form]]
    [logq-abort form expects a list [identity form]]

    [is-empty form]
    [logq-abort form expects a non-empty list [identity form]]

    [let [first-form [first form]
          s-form [size form]
          n-of-args [dec s-form]]
      [ifs
        [eq-form first-form [quote i32]]
        [set-node-type gctx form type-i32]

        [eq-form first-form [quote quote]]
        [do
          [set-node-type gctx form type-form]
          [if [eq n-of-args 1]
            [let [f [second form]]
              [if [is-list f]
                [type-list type-form]
                type-word]]
            [type-list type-form]]]

        [eq-form first-form [quote if]]
        [do
          [when [lt-s 0 n-of-args]
            [let [c [second form]]
              [report-when-not [eq-word [recur gctx local-ctx c] i32] c condition not i32]]]

          [if [lt-s 1 n-of-args]
            [let [tt [recur gctx local-ctx [third form]]
                  ft [if [eq n-of-args 2] type-empty [recur gctx local-ctx [fourth form]]]]
              [set-node-type gctx form
                [ifs
                  [type-less-than-equal tt ft]
                  ft

                  [type-less-than-equal ft tt]
                  tt

                  [and [type-less-than-equal tt type-form] [type-less-than-equal ft type-form]]
                  type-form

                  [do
                    [report-when-not [eq-form tt ft] form if branches must have same type]
                    ft]]]]]]

        [or
          [eq-form first-form [quote let]]
          [eq-form first-form [quote loop]]]
        [let
          [var-values [transient-kv-map]
           let-loop-ctx [kv-map vars var-values outer local-ctx first-form first-form]
           bindings [if [lt-s 1 s-form] [second form] [do [report form expects bindings] [list]]]
           n-of-bindings [size bindings]]
          [when [lt-s 1 s-form]
            [let
              [sec [second form]
               bindings [if [is-list sec] sec [do [report sec expects a list of bindings] [list]]]
               n-of-bindings [size bindings]]
              [report-when-not [is-even n-of-bindings] [last bindings] expects an even number of bindings]
              [for-pair i 0 [dec n-of-bindings]
                [let
                  [var [at bindings i]
                   value [at bindings [inc i]]
                   val-type [recur gctx let-loop-ctx value]]
                  [set var-values var val-type]]]]]
          [for i 2 [dec s-form]
            [recur gctx let-loop-ctx [at form i]]]
          [set-node-type gctx form
            [if [lt-s 2 s-form]
              [recur gctx let-loop-ctx [last form]]
              type-empty]]]

        [eq-form first-form [quote continue]]
        [do
          [loop [cur-ctx local-ctx]
            [if-not cur-ctx
              [report form continue not inside loop]
              [if [eq-form [quote loop] [getq cur-ctx first-form]]
                [let [loop-vars [getq cur-ctx vars]]
                  [report-when-not
                    [is-even n-of-args]
                    form
                    expected a list of pairs of bindings]
                  [for-pair i 1 n-of-args
                    [let [var [at form i]
                          value [at form [inc i]]
                          val-type [recur gctx cur-ctx value]]
                      [if [is-word var]
                        [if [has loop-vars var]
                          [let [type [get loop-vars var]]
                            [report-when-not [eq-form type val-type] value type mismatch]]
                          [report var loop var not found]]
                        [report var expected a loop variable here]]]]]
                [continue cur-ctx [getq cur-ctx outer]]]]]
          type-bottom]

        [eq-form first-form [quote extern]]
        [let [module-name [second form]
              name [third form]
              syntax-type [fourth form]]
          [if [is-type syntax-type]
            syntax-type
            [do
              [report syntax-type not a type]
              type-error]]]

        [or [eq-form first-form [quote func]]]
        [let [params [third form]
              param-ctx [transient-kv-map]
              n-of-param-words [size params]
              has-rest-param [has-rest-param params]
              n-of-regular-params [if has-rest-param [sub n-of-param-words 2] n-of-param-words]
              parameter-type-list [mutable-list-of-size n-of-regular-params]
              -
              [for i 0 n-of-regular-params
                [let [p [at params i]
                      pt [quote i32]]
                  [when-not [eq-form p -]
                    [set-node-type gctx p pt]
                    [set param-ctx p pt]]
                  [set-array parameter-type-list i pt]]]
              rest-param-element-type
              [if has-rest-param
                [let [p [last params]
                      pt type-any]
                  [report-when-not [is-word p] p not a word]
                  [when-not [eq-form p -]
                    [report-when [has param-ctx p] p duplicate parameter]
                    [set param-ctx p [type-list pt]]]
                  pt]
                0]
              func-ctx [kv-map vars param-ctx first-form first-form]
              sig-object [transient-kv-map]]
            [comment if this is a macro we should check it returns a form]
            [freeze-mutable-list parameter-type-list]
            [setq sig-object parameters parameter-type-list]
            [setq sig-object results type-any]
            [setq sig-object def first-form]
            [when rest-param-element-type
              [setq sig-object rest-param-element-type rest-param-element-type]]
            [when [lt-s 2 s-form]
              [for i 3 [dec [size form]]
                [comment remember to check type is empty maybe even drop unused and warn instead]
                [recur gctx func-ctx [at form i]]]]
            [let [result-type
                  [if [lt-s 3 [size form]]
                    [recur gctx func-ctx [last form]]
                    type-empty]]
              [set-node-type gctx form [list [quote func] parameter-type-list result-type]]]]

        [or [eq-form first-form [quote recur]]]
        [let []
          ]

        [eq-form first-form [quote def]]
        [let [name [second form]
              value-form [third form]
              value-type [recur gctx local-ctx value-form]]
          [set-def-var-type gctx name value-type]]

        [eq-form first-form [quote def-with-meta]]
        [let [name [second form]
              meta-form [third form]
              value-form [fourth form]
              value-type [recur gctx local-ctx value-form]]
          [set-def-var-type gctx name value-type]]

        [let [type [recur gctx local-ctx first-form]]
          [if [is-func-type type]
            [let [parameter-types [second type]
                  n-of-param-types [size parameter-types]
                  has-rest-param [has-rest-param parameter-types]
                  n-of-regular-params [if has-rest-param [sub n-of-param-types 2] n-of-param-types]]
              [for i 0 [min n-of-args n-of-regular-params]
                [let [arg [at form [inc i]]
                      arg-t [recur gctx local-ctx arg]]
                  [when [lt-s i n-of-param-types]
                    [let [pt [at parameter-types i]]
                      [when-not [check-param-arg-conform pt arg-t]
                        [report arg parameter does not match [list pt arg-t]]]]]]]
              [if has-rest-param
                [let [rest-param-element-type [last parameter-types]]
                  [report-when [lt-s n-of-args n-of-regular-params] form wrong number of arguments]
                  [for i [inc n-of-param-types] s-form
                    [let [arg [at form i]
                          arg-t [recur gctx local-ctx arg]]
                      [report-when-not [check-param-arg-conform rest-param-element-type arg-t] arg
                        rest parameter type mismatch]]]]
                [do
                  [report-when-not [eq n-of-args n-of-regular-params] form wrong number of arguments]
                  ]]
              [set-node-type gctx form [third type]]]
            [do
              [report form not a function]
              type-error]]]]]]]

[defn assign-node-ids [node-id-counter node]
  [let [c [atom-get node-id-counter]]
    [atom-set node-id-counter [inc c]]
    [if [is-word node]
      [word-with-meta node [assoc [if-let [m [meta node]] m empty-kv-map] [quote node-id] [int-to-word c]]]
      [let [- [assert [is-list node] not a word or list not assigned node id [identity node]]
            s-node [size node]
            res [mutable-list-of-size s-node]]
        [for i 0 s-node
          [set-array res i [recur node-id-counter [at node i]]]]
        [list-with-meta res [assoc [if-let [m [meta node]] m empty-kv-map] [quote node-id] [int-to-word c]]]]]]]

[defn form-with-node-ids [form] [assign-node-ids [atom [i32 100]] form]]

[defn check-form-top [gctx form] [check-form gctx 0 [form-with-node-ids form]]]

[defn test [expected-type form]
  [let [gctx [make-check-global-context]
        - [test-expand-no-errors-fn [list form]]
        actual-type [check-form-top gctx [form-with-node-ids form]]
        messages [getq gctx messages]]
    [assert [is-empty messages] there are messages [identity messages]]
    [assert [eq-form expected-type actual-type]
      test failed expected [identity expected-type] actual [identity actual-type]]]]

[defn test-error [expected-type expected-error form]
  [let [gctx [make-check-global-context]
        actual-type [check-form-top gctx [form-with-node-ids form]]
        messages [getq gctx messages]]
    [assert [eq [size messages] 1] there is not exactly one error message [identity messages]
      [identity form] [identity actual-type]]
    [let [message [getq [first messages] message]]
      [assert [eq-form expected-error message] [list [quote test fail wrong message] form expected-error message]]
    [assert [eq-form expected-type actual-type] test fail unexpected type form expected [identity expected-type] actual [identity actual-type]]]]]

[defn check-forms [forms]
  [assert [not [is-empty forms]] forms is empty]
  [let [gctx [make-check-global-context]]
    [for i 0 [dec [size forms]]
      [check-form-top gctx [form-with-node-ids [at forms i]]]]
    [kv-map last-type [check-form-top gctx [form-with-node-ids [last forms]]]
            messages [getq gctx messages]]]]

[defn test-forms-ok [expected-last-type forms]
  [let [result [check-forms forms]
        messages [getq result messages]]
    [when-not [is-empty messages]
      [for-each message messages
        [logq test fail [getq message message] [getq message form]]]]
    [assert [eq-form expected-last-type [getq result last-type]]
      [list [quote test fail] forms expected-last-type [getq result last-type]]]]]

[defn quote-all-list [lmsg]
  [let [s [size lmsg]
        msg [mutable-list-of-size [inc s]]]
    [set-array msg 0 [quote list]]
    [loop [i 0]
      [when [lt-s i s]
        [set-array msg [inc i] [let [e [at lmsg i]] [mk-quote e]]]
        [continue i [inc i]]]]
    [freeze-mutable-list msg]
    msg]]

[defmacro test-forms-okq [expected-last-type .. forms]
  [list [quote test-forms-ok] [mk-quote expected-last-type] [quote-all-list forms]]]

[defmacro testq [expected-type form]
  [list [quote test] [mk-quote expected-type] [mk-quote form]]]

[defn test-check []
  [test-error type-any [quote not found] [quote no-such-var]]

  [testq i32 [i32 -2]]
  [testq i32 [[extern instructions i32.add [func [i32 i32] i32]] [i32 1] [i32 2]]]
  [test-error i32 [quote parameter does not match [i32 word]] [quote [[extern instructions i32.add [func [i32 i32] i32]] [i32 1] [quote a]]]]

  [testq word [quote a]]
  [testq [list form] [quote]]
  [testq [list form] [quote []]]
  [testq [list form] [quote [a]]]
  [testq [list form] [quote two words]]

  [test-error i32 [quote condition not i32] [quote [if [quote not-i32] [i32 2] [i32 3]]]]
  [comment this check is done during expansion
    [test-error i32 [quote if extra forms ignored] [quote [if [i32 1] [i32 2] [i32 3] [i32 4]]]]]
  [test-error i32 [quote if branches must have same type] [quote [if [i32 1] [quote a] [i32 1]]]]
  [test-error type-empty [quote if branches must have same type] [quote [if [i32 1] [i32 2]]]]
  [testq i32 [if [i32 1] [i32 2] [i32 3]]]
  [testq word [if [i32 1] [quote a] [quote b]]]
  [testq form [if [i32 1] [quote a] [quote []]]]
  [testq [tuple] [if [i32 1] [let []]]]

  [test-error type-empty [quote expects an even number of bindings] [quote [let [a]]]]
  [testq [tuple] [let []]]
  [testq [tuple] [let [a [i32 1]]]]
  [testq i32 [let [a [i32 1]] a]]
  [testq i32 [let [a [i32 1] b a] b]]
  [comment maybe we should ban redef as it complicates compilation to wasm and is not good style]
  [comment [testq i32 [let [a [i32 1] a [i32.add [i32 1] a]] a]]]

  [test-error type-empty [quote expects an even number of bindings] [quote [loop [a]]]]
  [testq [tuple] [loop []]]
  [testq [tuple] [loop [a [i32 1]]]]
  [testq i32 [loop [a [i32 1]] a]]
  [testq i32 [loop [a [i32 1] b a] b]]
  [comment [testq i32 [loop [a [i32 1] a [i32.add [i32 1] a]] a]]]

  [test-error type-bottom [quote continue not inside loop] [quote [continue]]]
  [test-error type-bottom [quote expected a loop variable here] [quote [loop [] [continue [i32 1] [i32 1]]]]]
  [test-error type-bottom [quote loop var not found] [quote [loop [i [i32 0]] [continue j [i32 1]]]]]
  [test-error type-bottom [quote type mismatch] [quote [loop [i [i32 0]] [continue i [quote a]]]]]
  [testq i32
    [loop [i [i32 10] res [i32 0]]
      [if i
        [continue i [[extern instructions i32.sub [func [i32 i32] i32]] i [i32 1]] res [[extern instructions i32.add [func [i32 i32] i32]] res i]]
        res]]]

  [test-error type-error [quote not a type] [quote [extern m ef not-a-type]]]
  [test-error type-error [quote not a function] [quote [let [a [i32 1]] [a]]]]
  [test-error i32 [quote parameter does not match [i64 i32]]
    [quote [let [f [extern mod mod-fun [func [i64] i32]]] [f [i32 1]]]]]
  [test-error i32 [quote wrong number of arguments]
    [quote [let [f [extern mod mod-fun [func [] i32]]] [f [i32 1]]]]]
  [test-error i32 [quote wrong number of arguments]
    [quote [let [f [extern mod mod-fun [func [i32 i32] i32]]] [f [i32 1]]]]]
  [test-error i32 [quote wrong number of arguments]
    [quote [let [f [extern mod mod-fun [func [i32 .. i32] i32]]] [f]]]]
  [test-error i32 [quote wrong number of arguments]
    [quote [let [f [extern mod mod-fun [func [i32 i32 .. i32] i32]]] [f [i32 1]]]]]
  [testq i32 [let [f [extern m p0 [func [] i32]]] [f]]]
  [testq i32 [let [f [extern m p1 [func [i32] i32]]] [f [i32 1]]]]
  [testq i32 [let [f [extern m p1 [func [i32] i32]]] [f [i32 1]]]]
  [testq i32 [let [f [extern m p1 [func [form] i32]]] [f [quote a]]]]
  [testq i32 [let [f [extern m p1 [func [form] i32]]] [f [quote []]]]]
  [testq i32 [let [f [extern m p0r [func [.. form] i32]]] [f]]]
  [testq i32 [let [f [extern m p0r [func [.. form] i32]]] [f [quote a]]]]
  [testq i32 [let [f [extern m p0r [func [.. form] i32]]] [f [quote a] [quote []]]]]
  [testq i32 [let [f [extern m p1r [func [i32 .. form] i32]]] [f [i32 1] [quote a] [quote []]]]]

  [testq [func [] [tuple]] [func f []]]
  [testq [func [] i32] [func f [] [i32 1]]]
  [testq [func [] word] [func f [] [quote a]]]
  [testq [func [i32] i32] [func double [x] [[extern instructions i32.add [func [i32 i32] i32]] x x]]]

  [test-forms-okq i32
      [def size [extern host size [func [[list any]] i32]]]
      [size [quote]]]
  [test-forms-okq i32
    [def size [extern host size [func [[list any]] i32]]]
    [let [] [size [quote [1 2 3]]]]]


  ]

[comment

[defn expand-check [host-func-types forms]
  [let [gctx [make-global-context]
        - [init-host-context gctx host-func-types]
        e-forms [expand-top-level-forms gctx forms]
        expand-errors [getq gctx messages]
        - [when [size expand-errors]
            [for-each error expand-errors
              [log [list [getq error message] [try-get-range [getq error form]]]]]
            [log expand-errors]
            [unreachable]]
        check-result [check-top-forms e-forms]
        errors [getq check-result errors]]
    [for-each error errors
      [log error]]
    [when-not [is-empty errors]
      [unreachable]]]]
]
[comment
  a scheme for list could be
  [type-scheme [a] [func [.. a] [list a]]]
  concat could be
  [type-scheme [a] [func [.. [list a]] [list a]]]
]
