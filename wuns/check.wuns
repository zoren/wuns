[macro comment [.. -] []]

[func list [.. l] l]

[macro constant-ids [.. id-constants]
  [let [f [mutable-list]]
    [push f [quote let]]
    [push f []]
    [loop [i [quote 0]]
      [if [lt i [size id-constants]]
        [let [name [at id-constants i]]
          [push f [list [quote constant] name [list [quote quote] name]]]
          [cont [add i [quote 1]]]]
        f]]]]

[constant-ids 0 1 2 3 4 -1]

[func inc [x] [add x 1]]

[func dec [x] [sub x 1]]

[func not [c] [eqz c]]

[func is-zero [x] [eqz x]]

[func is-odd [x] [bit-and x 1]]

[func is-even [x] [not [is-odd x]]]

[func is-negative [x] [lt x 0]]

[func first [l] [at l 0]]
[func second [l] [at l 1]]
[func third [l] [at l 2]]
[func fourth [l] [at l 3]]
[func last [l] [at l -1]]

[func rest [l] [slice l 1 [size l]]]

[func push-all [mut-list list]
  [let [s-l [size list]]
    [loop [i 0]
      [if [lt i s-l]
        [let []
          [push mut-list [at list i]]
          [cont [inc i]]]
        []]]]]

[func concat-lists [lists]
  [let [res [mutable-list] s [size lists]]
    [loop [i 0]
      [if [lt i s]
        [let []
          [push-all res [at lists i]]
          [cont [inc i]]]
        [freeze res]]]]]

[func concat [.. lists] [concat-lists lists]]

[macro do [.. forms]
  [concat [quote [let []]] forms]]

[macro when [cond .. forms]
  [list
    [quote if] cond
    [concat [quote [do]] forms]
    []]]

[macro when-not [cond .. forms]
  [list
    [quote if] cond
    []
    [concat [quote [do]] forms]]]

[macro assert [cond .. lmsg]
  [list [quote when-not] cond
    [list [quote log] [list [quote quote] [concat [list [quote assert-fail]] lmsg]]]
    [quote [abort]]]]

[macro report-when-not [cond form .. lmsg]
  [list [quote when-not] cond
    [list [quote report-error] [list [quote quote] lmsg] form]]]

[macro report [form .. lmsg]
  [list [quote report-error] [list [quote quote] lmsg] form]]

[macro ifs [.. clauses]
  [let [s [size clauses]]
    [assert [not [is-zero s]] ifs requires an odd number of arguments]
    [if [eq s 1]
        [first clauses]
        [list [quote if] [first clauses]
          [second clauses]
          [concat [quote [ifs]] [slice clauses 2 [size clauses]]]]]]]

[macro and [.. clauses]
  [let [s [size clauses]]
    [ifs
      [is-zero s]
      1

      [eq s 1]
      [first clauses]

      [let [gs [gensym]]
        [list [quote let] [list gs [first clauses]]
          [list [quote if] gs
            [concat [quote [and]] [rest clauses]]
            gs]]]]]]

[macro or [.. clauses]
  [let [s [size clauses]]
    [ifs
      [is-zero s]
      0

      [eq s 1]
      [first clauses]

      [let [gs [gensym]]
        [list [quote let] [list gs [first clauses]]
          [list [quote if] gs
            gs
            [concat [quote [or]] [rest clauses]]]]]]]]

[func eq-word [a b]
  [and [eq [size a] [size b]]
    [loop [i 0]
      [if [lt i [size a]]
        [if [eq [at a i] [at b i]]
          [cont [inc i]]
          0]
        1]]]]

[func = [a b]
  [if
    [and [is-word a] [is-word b]]
    [eq-word a b]

    [and [is-list a] [is-list b]
      [let [s [size a]]
        [and [eq s [size b]]
          [loop [i [quote 0]]
            [or [ge i s]
              [and [= [at a i] [at b i]] [cont [inc i]]]]]]]]]]

[func test [expected actual]
  [when-not [= expected actual]
    [log [list [quote expected] expected [quote [but got]] actual]]]]

[func index-assoc-list [ctx sym]
  [let [s [size ctx]]
    [loop [i 0]
      [if [ge i s]
        -1
        [if [eq-word [at ctx i] sym]
          i
          [cont [add i 2]]]]]]]

[func lookup-assoc-list [ctx sym]
  [let [index [index-assoc-list ctx sym]]
    [when [is-negative index]
      [log [list [quote symbol] sym [quote not found]]]]
    [assert [not [is-negative index]] lookup-assoc-list key not found]
    [at ctx [inc index]]]]

[constant i32 [quote i32]]
[constant any-type [quote any-type]]

[func dec-word-to-i32 [dw]
  [let [s [sub 0 [size dw]]]
    [loop [i -1 res 0 multi 1]
      [if [le s i]
        [let [c [at dw i]]
          [when-not [and [le [quote 48] c] [le c [quote 57]]]
            [log c]
            [report dw not a decimal character]]
          [assert [lt res [quote 214748364]] out of bounds]
          [cont [dec i] [add res [mul [sub c [quote 48]] multi]] [mul multi [quote 10]]]]
        res]]]]

[func check-decimal [dw]
  [let [s [size dw]]
    [loop [ii 0]
      [when [lt ii s]
        [let [c [at dw ii]]
          [if [and [le [quote 48] c] [le c [quote 57]]]
            [cont [inc ii]]
            [report dw not a decimal character]]]]]]]

[func check-form [global-ctx local-ctx tail-pos form]
  [ifs
    [is-word form]
    [loop [cur-ctx local-ctx]
      [if [eq [size cur-ctx] 1]
        [let [param-ctx [first cur-ctx]
              index [index-assoc-list param-ctx form]
              t
              [if [is-negative index]
                [do
                  [report form symbol not found]
                  i32]
                [at param-ctx [inc index]]]]
          [list t]]
        [let
          [vars [first cur-ctx]
           outer [second cur-ctx]
           index [index-assoc-list vars form]]
          [if [is-negative index]
            [cont outer]
            [list [at vars [inc index]]]]]]]

    [= form []]
    []

    [let [first-form [first form]
          s-form [size form]
          n-of-args [dec s-form]]
      [assert [is-word first-form] expected a word first]
      [ifs
        [= first-form [quote tuple]]
        [let
          [res-types [mutable-list] limit [inc n-of-args]]
          [loop [i [quote 1]]
            [when [lt i limit]
              [comment do we actually want to concat them]
              [push-all res-types [check-form global-ctx local-ctx 0 [at form i]]]
              [cont [inc i]]]]
          [freeze res-types]]

        [= first-form [quote quote]]
        [do
          [assert [eq n-of-args 1] only support decimal integers]
          [comment todo check if integer or word or list]
          i32]

        [= first-form [quote if]]
        [do
          [when [gt n-of-args 0]
            [let [c [at form 1]
                  ct [check-form global-ctx local-ctx 0 c]]
              [report-when-not [= ct i32] c condition not i32]]]
          [loop [i 4]
            [when [lt i s-form]
              [check-form global-ctx local-ctx 1 [at form i]]
              [report [at form i] if extra forms ignored]
              [cont [inc i]]]]
          [if [gt n-of-args 1]
            [let [tt [check-form global-ctx local-ctx tail-pos [third form]]
                  ft [if [eq n-of-args 2] [] [check-form global-ctx local-ctx tail-pos [fourth form]]]]
              [if [= tt any-type]
                [if [= ft any-type]
                  [report form if branches both any type maybe this is infinite loop]
                  ft]
                [do
                  [report-when-not [= tt ft] form if branches must have same type]
                  tt]]]]]

        [or
          [= first-form [quote let]]
          [= first-form [quote loop]]]
        [let
          [var-values [mutable-list]
           let-loop-ctx [list var-values local-ctx first-form]
           bindings [if [gt s-form 1] [at form 1] [do [report form let expects bindings] []]]
           n-of-bindings [size bindings]]
          [when [lt 1 s-form]
            [let
              [sec [second form]
               bindings [if [is-list sec] sec [do [report sec let expects a list of bindings] []]]
               n-of-bindings [size bindings]]
              [report-when-not [is-even n-of-bindings] [last bindings] let expects an even number of bindings]
              [loop [i 0]
                [when [lt i [dec n-of-bindings]]
                  [let
                    [var [at bindings i]
                     value [at bindings [inc i]]
                     var-type [check-form global-ctx let-loop-ctx 0 value]
                     - [report-when-not [= var-type i32] value let expects a single type]]
                    [push var-values var]
                    [push var-values [first var-type]]
                    [cont [add i 2]]]]]]]
          [loop [i 1]
            [when [lt i [dec s-form]]
              [check-form global-ctx let-loop-ctx 0 [at form i]]
              [cont [inc i]]]]
          [check-form global-ctx let-loop-ctx [if [= first-form [quote loop]] 1 tail-pos] [last form]]]

        [= first-form [quote cont]]
        [do
          [loop [cur-ctx local-ctx]
            [if [eq [size cur-ctx] 1]
              [report form cont not inside loop]
              [if [= [quote loop] [third cur-ctx]]
                [let [loop-vars [first cur-ctx]]
                  [report-when-not
                    [eq [mul n-of-args 2] [size loop-vars]]
                    form
                    cont needs same number of arguments as loop]
                  [report-when-not tail-pos form cont not at tail position of loop]]
                [cont [second cur-ctx]]]]]
          any-type]

        [or [= first-form [quote func]]
            [= first-form [quote macro]]]
        [let [name
              [if [gt s-form 1]
                [let [s [second form]]
                  [report-when-not [is-word s] s expected name here]]
                [do
                  [report form function expects a name]
                  [quote dummy-name]]]
              params
              [if [gt s-form 2]
                [let [l [third form]]
                  [report-when-not [is-list l] l expected list here]]
                [do
                  [report form function expects a list of parameters]
                  []]]
              param-ctx [mutable-list]
              parameter-type-list [mutable-list]
              -
              [loop [i 0]
                [when [lt i [size params]]
                  [let [p [at params i]
                        pt i32]
                    [report-when-not [is-negative [index-assoc-list param-ctx p]] p duplicate parameter]
                    [push param-ctx p]
                    [push param-ctx pt]
                    [push parameter-type-list pt]
                    [cont [inc i]]]]]
              func-ctx [list param-ctx [] first-form]
              parameter-type-list [freeze parameter-type-list]
              locals [mutable-list]
              func-sigs [lookup-assoc-list global-ctx [quote function-signatures]]
              -
              [loop [i 3]
                [when [lt i [dec [size form]]]
                  [comment remember to check type is empty maybe even drop unused and warn instead]
                  [check-form global-ctx func-ctx 0 [at form i]]
                  [cont [inc i]]]]
              result-type
              [if [gt [size form] 3]
                [check-form global-ctx func-ctx 0 [last form]]
                i32]
              ]
            [push func-sigs name]
            [push func-sigs [list [quote parameters] parameter-type-list [quote parameters] result-type]]
            result-type]

        [let [func-sigs [lookup-assoc-list global-ctx [quote function-signatures]]
              index [index-assoc-list func-sigs first-form]]
          [if [is-negative index]
            [report first-form function not found]
            [let [sig [at func-sigs [inc index]]
                  parameters [lookup-assoc-list sig [quote parameters]]
                  n-of-parameters [size parameters]]
              [report-when-not [ge n-of-args n-of-parameters] form
                missing arguments]
              [loop [i 1]
                [when [lt i n-of-args]
                  [let [arg [at form i]
                        arg-t [check-form global-ctx local-ctx 0 arg]
                        p-index [dec i]]
                    [when [lt p-index n-of-parameters]
                      [report-when-not [= arg-t [at parameters p-index]] arg instruction parameter type mismatch]]
                    [cont [inc i]]]]]
              [loop [i [inc n-of-parameters]]
                [when [lt i s-form]
                  [report [at form i] instruction extra arguments ignored]
                  [cont [inc i]]]]
              [lookup-assoc-list sig [quote results]]]
            ]]]]]]

[func check-top-level-form [ctx form]
  [if [eq-word [quote func] [first form]]
    [let [name [second form]
          params [third form]
          param-ctx [mutable-list]
          parameter-type-list [mutable-list]
          -
          [loop [i 0]
            [when [lt i [size params]]
              [comment check for duplicate parameters]
              [push param-ctx [at params i]]
              [push param-ctx i32]
              [push parameter-type-list i32]
              [cont [inc i]]]]
          func-ctx [list param-ctx]
          parameter-type-list [freeze parameter-type-list]
          locals [mutable-list]
          func-sigs [lookup-assoc-list ctx [quote function-signatures]]
          -
          [loop [i 3]
            [when [lt i [dec [size form]]]
              [comment remember to check type is empty maybe even drop unused and warn instead]
              [compile-form-mutable ctx func-ctx code [at form i]]]]
          result-type [compile-form-mutable ctx func-ctx code [last form]]
          type-index
          [push-type ctx
            [type-function parameter-type-list result-type]]
          functions [lookup-assoc-list ctx [quote functions]]
          func-index [size functions]]
      [push func-sigs name]
      [push func-sigs [list parameter-type-list result-type func-index]]

      [push functions type-index]
      [push [lookup-assoc-list ctx [quote exports]]
        [export name kind-function func-index]]
      [push code end]
      [push [lookup-assoc-list ctx [quote codes]] [code-to-bytes locals code]]
      ]

    [do
      [log [list form ]]
      [assert 0 not a top-level form]]]]

[func make-mty-ctx []
  [let [bin-insts [quote eq ne lt le gt ge add sub mul]
        ml [mutable-list]]
    [loop [i 0]
      [when [lt i [size bin-insts]]
        [let [name [at bin-insts i]]
          [push ml name]
          [push ml [quote parameters [i32 i32] results [i32]]]
          [cont [inc i]]]]]
    [list
      [quote function-signatures] ml]]]

[func compile-top-level-forms [forms]
  [let [ctx [make-mty-ctx]]
    [loop [i 0]
      [when [lt i [size forms]]
        [compile-top-level-form ctx [at forms i]]
        [cont [inc i]]]]
    ctx]]

[func check-forms [forms]
  [let [gctx [make-mty-ctx]]
    [loop [i 0]
      [when [lt i [size forms]]
        [check-form gctx [list []] 0 [at forms i]]
        [cont [inc i]]]]]]

[comment
[let
  [ctx [compile-top-level-forms [quote
  [
    [func fst [x y] x]
    [func snd [x y] y]
    [func add [x y] [i32.add x y]]
    [func sub [x y] [i32.sub x y]]
    [func inc [x] [i32.add x [quote 1]]]
    [func five [] [quote 5]]
    [func ifte [c] [if c [quote 1337] [quote 21]]]
    [func ignore [x] []]
    [func identity [x] x]
    [func id-pair [x] [tuple x x]]
    [func pair [x y] [tuple x y]]
  ]
  ]]
  ]
  [wasm-import-func wi fst my-fst]
  [wasm-import-func wi snd my-snd]
  [wasm-import-func wi add my-add]
  [wasm-import-func wi sub my-sub]
  [wasm-import-func wi inc my-inc]
  [wasm-import-func wi ifte my-ifte]
  [wasm-import-func wi ignore my-ignore]
  [wasm-import-func wi identity my-identity]
  [wasm-import-func wi id-pair my-id-pair]
  [wasm-import-func wi pair my-pair]
  ]

[test 3 [my-fst 3 2]]
[test 2 [my-snd 1 2]]
[test 3 [my-add 1 2]]
[test -1 [my-sub 1 2]]
[test 2 [my-inc 1]]
[test [quote 1337] [my-ifte 1]]
[test [quote 21] [my-ifte 0]]
[test [] [my-ignore 0]]
[test 0 [my-identity 0]]
[test 2 [my-identity 2]]
[test [list 2 2] [my-id-pair 2]]
[test [list 2 3] [my-pair 2 3]]
[test [list 2 3] [my-pair 2 3]]

[func compile-instantiate [funcs]
  [let
    [ctx [compile-top-level-forms funcs]
     mod [ctx-to-module ctx]
     wm [wasm-module mod]]
    [wasm-instance wm]]]

[wasm-import-func [compile-instantiate [quote [[func f [x] [] [quote 5]]]]] f my-f]

[wasm-import-func [compile-instantiate
  [quote
    [func callee [] [quote 5]]
    [func caller [] [callee]]]] caller my-caller]

[test [quote 5] [my-caller]]

[let [wi
  [compile-instantiate
    [quote
      [func let-test [] [let [] [quote 5]]]
      [func let1-test [] [let [] []]]
      [func let2-test [] [let [] [tuple [quote 5] [quote 6]]]]


      ]]]
  [wasm-import-func wi let-test my-let-test]
  [wasm-import-func wi let1-test my-let1-test]
  [wasm-import-func wi let2-test my-let2-test]
  ]

[test [quote 5] [my-let-test]]
[test [] [my-let1-test]]
[test [list [quote 5] [quote 6]] [my-let2-test]]
]