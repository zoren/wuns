[def type-word [quote word]]
[def type-form [quote form]]

[def type-i32 i32]
[def type-i64 i64]
[def type-any [quote any]]
[def type-error [quote type-error]]
[def type-pointer [quote i32]]

[defn is-word-type [t] [or [eq-form t type-word] [eq-form t type-i32]]]

[defn type-list [element-type] [list [quote list] element-type]]
[defn type-tuple [.. types] [concat [quote [tuple]] types]]
[def type-empty [type-tuple]]

[defn is-atomic-type [t]
  [or
    [eq-form t type-form]
    [eq-form t type-word]
    [eq-form t type-i32]
    [eq-form t type-i64]
    [eq-form t type-any]
    [eq-form t type-error]]]

[defn is-mutable-list-type [t] [and [is-list t] [eq [size t] 2] [eq-word [first t] [quote mutable-list]] [is-atomic-type [second t]]]]
[defn is-tuple-type [t] [and [is-list t] [lt-s 0 [size t]] [eq-form [first t] [quote tuple]]]]

[defn is-type [t]
  [or
    [is-atomic-type t]
    [and [is-list t] [eq [size t] 2]
      [or [eq-word [first t] [quote list]] [eq-word [first t] [quote mutable-list]]]
      [recur [second t]]]
    [and [is-list t] [le-s 1 [size t]]
      [eq-word [first t] [quote tuple]]
      [loop [i 1]
        [if [lt-s i [size t]]
          [if [recur [at t i]]
            [continue i [inc i]]
            0]
          1]]]]]

[defn is-func-type [t]
  [and [is-list t] [eq [size t] 3]
    [eq-word [first t] [quote func]]
    [is-list [second t]]
    [is-list [third t]]]]

[defn is-list-or-mut-list-type [t]
  [and [is-list t] [eq [size t] 2]
    [or [eq-word [first t] [quote list]] [eq-word [first t] [quote mutable-list]]]
    [is-type [second t]]]]

[defn is-list-type [t]
  [and [is-list t] [eq [size t] 2]
    [eq-word [first t] [quote list]]
    [is-type [second t]]]]

[defn is-form-type [t]
  [or
    [is-word-type t]
    [and [is-list-type t] [recur [second t]]]]]

[defn check-param-arg-conform [param-type arg-t]
  [or
    [eq-form param-type type-any]
    [eq-form param-type arg-t]
    [and [eq-word param-type type-form] [is-form-type arg-t]]
    [and [is-list-type param-type] [is-list-or-mut-list-type arg-t]]
    [and [is-list-type param-type] [is-list-type arg-t]
      [recur [second param-type] [second arg-t]]]]]

[comment
  when a varargs function is called we have to find the greatest common type of all the arguments
  and then check that against the parameter type
]

[defn max-types [t1 t2]
  [ifs
    [eq-form t1 type-any]
    t2

    [eq-form t2 type-any]
    t1

    [eq-form t1 type-form]
    [if [is-form-type t2] type-form type-any]

    [eq-form t2 type-form]
    [if [is-form-type t1] type-form type-any]

    [eq-form t1 t2]
    t1

    type-any]]

[defn set-node-type [gctx node type]
  [comment to do add to map inside gctx]
  type]

[defn eval-var-assoc-meta [gctx var key value]]

[defn try-get-var-type [gctx local-ctx var-name]
  [loop [cur-ctx local-ctx]
    [if-let [vars [try-getq cur-ctx vars]]
      [if-let [type [try-get vars var-name]]
        type
        [continue cur-ctx [getq cur-ctx outer]]]
      [if-let [def-var [eval-try-get-var gctx var-name]]
        [try-getq [var-meta def-var] type]
        0]]]]

[defn check-form [gctx local-ctx form]
  [ifs
    [is-word form]
    [if-let [type [try-get-var-type gctx local-ctx form]]
      [do
        [comment we could check for this as it will make compilation difficult
          [report-when-not [is-func-type type] form defed func used as value]]
        [set-node-type gctx form type]]
      [do
        [report form not found]
        [set-node-type gctx form type-any]]]

    [not [is-list form]]
    [logq-abort form expects a list [identity form]]

    [let [first-form [first form]
          s-form [size form]
          n-of-args [dec s-form]]
      [assert [is-word first-form] expected a word first [identity form]]
      [ifs
        [eq-form first-form [quote quote]]
        [do
          [set-node-type gctx form type-form]
          [if [eq n-of-args 1]
            [let [f [second form]]
              [if [is-list f]
                [type-list type-form]
                type-word]]
            [type-list type-form]]]

        [eq-form first-form [quote if]]
        [do
          [when [lt-s 0 n-of-args]
            [let [c [second form]]
              [report-when-not [eq-word [recur gctx local-ctx c] i32] c condition not i32]]]
          [for i 4 s-form
            [recur gctx local-ctx [at form i]]
            [report [at form i] if extra forms ignored]]
          [if [lt-s 1 n-of-args]
            [let [tt [recur gctx local-ctx [third form]]
                  ft [if [eq n-of-args 2] type-empty [recur gctx local-ctx [fourth form]]]]
              [set-node-type gctx form
                [ifs
                  [eq-form tt type-any]
                  ft

                  [eq-form ft type-any]
                  tt

                  [do
                    [report-when-not [eq-form tt ft] form if branches must have same type]
                    ft]]]]]]

        [or
          [eq-form first-form [quote let]]
          [eq-form first-form [quote loop]]]
        [let
          [var-values [transient-kv-map]
           let-loop-ctx [kv-map vars var-values outer local-ctx first-form first-form]
           bindings [if [lt-s 1 s-form] [second form] [do [report form expects bindings] [list]]]
           n-of-bindings [size bindings]]
          [when [lt-s 1 s-form]
            [let
              [sec [second form]
               bindings [if [is-list sec] sec [do [report sec expects a list of bindings] [list]]]
               n-of-bindings [size bindings]]
              [report-when-not [is-even n-of-bindings] [last bindings] expects an even number of bindings]
              [for-pair i 0 [dec n-of-bindings]
                [let
                  [var [at bindings i]
                   value [at bindings [inc i]]
                   val-type [recur gctx let-loop-ctx value]]
                  [set var-values var val-type]]]]]
          [for i 2 [dec s-form]
            [recur gctx let-loop-ctx [at form i]]]
          [set-node-type gctx form
            [if [lt-s 2 s-form]
              [recur gctx let-loop-ctx [last form]]
              type-empty]]]

        [eq-form first-form [quote continue]]
        [do
          [loop [cur-ctx local-ctx]
            [if-not [hasq cur-ctx outer]
              [report form continue not inside loop]
              [if [eq-form [quote loop] [getq cur-ctx first-form]]
                [let [loop-vars [getq cur-ctx vars]]
                  [report-when-not
                    [is-even n-of-args]
                    form
                    expected a list of pairs of bindings]
                  [for-pair i 1 n-of-args
                    [let [var [at form i]
                          value [at form [inc i]]
                          val-type [recur gctx cur-ctx value]]
                      [if [is-word var]
                        [if-not [has loop-vars var]
                          [report var loop var not found]
                          [let [type [get loop-vars var]]
                            [report-when-not [eq-form type val-type] value type mismatch]]]
                        [report var expected a loop variable here]]]]]
                [continue cur-ctx [getq cur-ctx outer]]]]]
          type-any]

        [eq-form first-form [quote def]]
        [let [name [second form]
              value-type [recur gctx local-ctx [third form]]]
          [eval-var-assoc-meta gctx name [quote type] value-type]]

        [or [eq-form first-form [quote defunc]]]
        [let [params [third form]
              param-ctx [transient-kv-map]
              n-of-param-words [size params]
              has-rest-param [has-rest-param params]
              n-of-regular-params [if has-rest-param [sub n-of-param-words 2] n-of-param-words]
              parameter-type-list [mutable-list-of-size n-of-regular-params]
              -
              [for i 0 n-of-regular-params
                [let [p [at params i]
                      pt [quote i32]]
                  [when-not [eq-form p -]
                    [set-node-type gctx p pt]
                    [set param-ctx p pt]]
                  [set-array parameter-type-list i pt]]]
              rest-param-element-type
              [if has-rest-param
                [let [p [last params]
                      pt type-any]
                  [report-when-not [is-word p] p not a word]
                  [when-not [eq-form p -]
                    [report-when [has param-ctx p] p duplicate parameter]
                    [set param-ctx p [type-list pt]]]
                  pt]
                0]
              meta-params [fourth form]
              func-ctx [kv-map vars param-ctx first-form first-form]
              locals [growable-list]
              sig-object [transient-kv-map]]
            [comment if this is a macro we should check it returns a form]
            [freeze-mutable-list parameter-type-list]
            [setq sig-object parameters parameter-type-list]
            [setq sig-object results type-any]
            [setq sig-object def first-form]
            [when rest-param-element-type
              [setq sig-object rest-param-element-type rest-param-element-type]]
            [comment
              [when [lt-s 1 s-form]
              [let [name [second form]]
                [if [is-word name]
                  [add-sig name sig-object]
                  [report name expected a word here]]]]]
            [for i 3 [dec [size form]]
              [comment remember to check type is empty maybe even drop unused and warn instead]
              [recur gctx func-ctx [at form i]]]
            [let [
              result-type
              [if [lt-s 3 [size form]]
                [recur gctx func-ctx [last form]]
                type-error]]
              [setq sig-object results result-type]]]

        [if-let [type [try-get-var-type gctx local-ctx first-form]]
          [if [is-func-type type]
            [let [parameter-types [second type]
                  n-of-param-types [size parameter-types]
                  has-rest-param [has-rest-param parameter-types]
                  n-of-regular-params [if has-rest-param [sub n-of-param-types 2] n-of-param-types]]
              [for i 1 [inc n-of-regular-params]
                [let [arg [at form i]
                      arg-t [recur gctx local-ctx arg]
                      p-index [dec i]]
                  [when [lt-s p-index n-of-param-types]
                    [let [pt [at parameter-types p-index]]
                      [when-not [check-param-arg-conform pt arg-t]
                        [report arg parameter does not match [list pt arg-t]]]]]]]
              [when has-rest-param
                [let [rest-param-element-type [last parameter-types]]
                  [for i [inc n-of-param-types] s-form
                    [let [arg [at form i]
                          arg-t [recur gctx local-ctx arg]]
                      [report-when-not [check-param-arg-conform rest-param-element-type arg-t] arg
                        rest parameter type mismatch]]]]]
              [set-node-type gctx form [third type]]]
            [do
              [report form not a function]
              type-error]]

          [if-let [instruction [try-get-instruction first-form]]
            [let [imm-parameters [getq instruction immediate-parameters]
                  parameters [getq instruction parameters]
                  n-of-parameters [add [size imm-parameters] [size parameters]]
                  results [getq instruction results]]
              [report-when-not [eq n-of-args n-of-parameters] form wrong number of arguments]
              [for i 0 [size imm-parameters]
                [let [imm-p [at imm-parameters i]
                      arg [at form [inc i]]]
                  [ifs
                    [eq-word imm-p immediate-s32]
                    [report-when-not [is-decimal arg] arg expects a decimal]

                    [eq-word imm-p immediate-u32]
                    [report-when-not [is-decimal arg] arg expects a decimal]

                    [eq-word imm-p immediate-s64]
                    [report-when-not [is-decimal arg] arg expects a decimal]

                    [assert 0 unknown immediate parameter type [identity imm-p]]]]]
              [for i 0 [size parameters]
                [let [arg [at form [inc [add i [size imm-parameters]]]]
                      arg-t [recur gctx local-ctx arg]
                      pt [at parameters i]]
                    [when-not [check-param-arg-conform pt arg-t]
                      [report arg parameter does not match [list pt arg-t]] arg]]]
              [set-node-type gctx form results]]
            [report form function not found [identity first-form]]]
                ]]]]]

[defn assign-node-ids [node-id-counter node]
  [let [c [atom-get node-id-counter]]
    [atom-set node-id-counter [inc c]]
    [if [is-word node]
      [word-with-meta node [assoc [if-let [m [meta node]] m empty-kv-map] [quote node-id] [int-to-word c]]]
      [let [- [assert [is-list node] not a word or list not assigned node id [identity node]]
            s-node [size node]
            res [mutable-list-of-size s-node]]
        [for i 0 s-node
          [set-array res i [recur node-id-counter [at node i]]]]
        [list-with-meta res [assoc [if-let [m [meta node]] m empty-kv-map] [quote node-id] [int-to-word c]]]]]]]

[defn form-with-node-ids [form] [assign-node-ids [atom [i32.const 100]] form]]

[defn test [expected-type form]
  [let [gctx [make-global-context]
        actual-type [check-form gctx [kv-map] [form-with-node-ids form]]
        messages [getq gctx messages]]
    [assert [is-empty messages] there are messages [identity messages]]
    [assert [eq-form expected-type actual-type] [list [quote test] form expected-type actual-type]]]]

[defn test-error [expected-type expected-error form]
  [let [gctx [make-global-context]
        actual-type [check-form gctx [kv-map] [form-with-node-ids form]]
        messages [getq gctx messages]]
    [assert [eq [size messages] 1] there are more than one error messages [identity messages]]
    [let [message [getq [first messages] message]]
      [assert [eq-form expected-error message] [list [quote test fail wrong message] form expected-error message]]
    [assert [eq-form expected-type actual-type] test fail unexpected type form expected [identity expected-type] actual [identity actual-type]]]]]

[defmacro testq [expected-type form]
  [list [quote test] [mk-quote expected-type] [mk-quote form]]]

[defn test-check []
  [test-error type-any [quote not found] [quote no-such-var]]

  [testq i32 [i32.const -2]]
  [testq i64 [i64.const -2]]
  [testq i32 [i32.add [i32.const 1] [i32.const 2]]]
  [test-error i64 [quote parameter does not match [i64 i32]] [quote [i64.add [i32.const 1] [i64.const 2]]]]

  [testq word [quote a]]
  [testq [list form] [quote]]
  [testq [list form] [quote []]]
  [testq [list form] [quote [a]]]
  [testq [list form] [quote two words]]

  [test-error i32 [quote condition not i32] [quote [if [i64.const 1] [i32.const 2] [i32.const 3]]]]
  [test-error i32 [quote if extra forms ignored] [quote [if [i32.const 1] [i32.const 2] [i32.const 3] [i32.const 4]]]]
  [test-error i32 [quote if branches must have same type] [quote [if [i32.const 1] [quote a] [i32.const 1]]]]
  [test-error type-empty [quote if branches must have same type] [quote [if [i32.const 1] [i32.const 2]]]]
  [testq i32 [if [i32.const 1] [i32.const 2] [i32.const 3]]]
  [testq word [if [i32.const 1] [quote a] [quote b]]]
  [testq [tuple] [if [i32.const 1] [let []]]]

  [test-error type-empty [quote expects an even number of bindings] [quote [let [a]]]]
  [testq [tuple] [let []]]
  [testq [tuple] [let [a [i32.const 1]]]]
  [testq i32 [let [a [i32.const 1]] a]]
  [testq i32 [let [a [i32.const 1] b a] b]]
  [testq i32 [let [a [i32.const 1] b [i32.add [i32.const 1] a]] b]]
  [comment maybe we should ban redef as it complicates compilation to wasm and is not good style]
  [testq i32 [let [a [i32.const 1] a [i32.add [i32.const 1] a]] a]]

  [test-error type-empty [quote expects an even number of bindings] [quote [loop [a]]]]
  [testq [tuple] [loop []]]
  [testq [tuple] [loop [a [i32.const 1]]]]
  [testq i32 [loop [a [i32.const 1]] a]]
  [testq i32 [loop [a [i32.const 1] b a] b]]
  [testq i32 [loop [a [i32.const 1] b [i32.add [i32.const 1] a]] b]]
  [comment maybe we should ban redef as it complicates compilation to wasm and is not good style]
  [testq i32 [loop [a [i32.const 1] a [i32.add [i32.const 1] a]] a]]

  [test-error type-any [quote continue not inside loop] [quote [continue]]]
  [test-error type-any [quote expected a loop variable here] [quote [loop [] [continue [i32.const 1] [i32.const 1]]]]]
  [test-error type-any [quote loop var not found] [quote [loop [i [i32.const 0]] [continue j [i64.const 1]]]]]
  [test-error type-any [quote type mismatch] [quote [loop [i [i32.const 0]] [continue i [i64.const 1]]]]]
  [testq i32
    [loop [i [i32.const 10] res [i32.const 0]]
      [if i
        [continue i [i32.sub i [i32.const 1]] res [i32.add res i]]
        res]]]

  [test-error type-error [quote not a function] [quote [let [a [i32.const 1]] [a]]]]

  ]

[comment
[defn check-top-forms [forms]
  [let [messages [list]
        global-ctx [kv-map messages messages]
        node-id-counter [atom [i32.const 100]]]
    [for-each form forms
      [check-form global-ctx [kv-map vars [kv-map]] [assign-node-ids node-id-counter form]]]
    [when-not [is-empty messages]
      [for-each err messages
        [log [list [getq err message] [getq err form] [try-get-range [getq err form]]]]]
      []
      [unreachable]]
    [kv-map
      errors messages
      global-ctx global-ctx]]]

[defn expand-check [host-func-types forms]
  [let [gctx [make-global-context]
        - [init-host-context gctx host-func-types]
        e-forms [expand-top-level-forms gctx forms]
        expand-errors [getq gctx messages]
        - [when [size expand-errors]
            [for-each error expand-errors
              [log [list [getq error message] [try-get-range [getq error form]]]]]
            [log expand-errors]
            [unreachable]]
        check-result [check-top-forms e-forms]
        errors [getq check-result errors]]
    [for-each error errors
      [log error]]
    [when-not [is-empty errors]
      [unreachable]]]]
]
[comment
  a scheme for list could be
  [type-scheme [a] [func [.. a] [list a]]]
  concat could be
  [type-scheme [a] [func [.. [list a]] [list a]]]
]