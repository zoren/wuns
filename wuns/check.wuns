[type
  type-var-kind []
  [union
    [linked type]
    [word word]]

  type-var []
  [record
    [kind type-var-kind mutable]
    [level i32 mutable]]

  func-type []
  [record
    [params [list type]]
    [rest-param-opt [option type]]
    [result type]
    [is-ctor bool]]

  inst-type []
  [union
    [func func-type]
    [apply word [list type]]]

  type []
  [union
    [var type-var]
    [inst inst-type]]]

[defn make-type-list [type-name type-args] [type/inst [inst-type/apply type-name type-args]]]

[defn make-type [type-name .. type-args] [make-type-list type-name type-args]]

[def type-i32 [make-type [word i32]]]

[def type-word [make-type [word word]]]

[def type-form [make-type [word form]]]

[defn type-list [elem-type] [make-type [word list] elem-type]]

[def type-empty-tuple [make-type-list [word tuple] [list]]]

[defn type-func [params opt-rest-param result]
  [type/inst [inst-type/func [func-type params opt-rest-param result 0]]]]

[defn type-ctor [params result]
  [type/inst [inst-type/func [func-type params [none] result 1]]]]

[defn report-fn [gctx message form]
  [push [getq gctx messages] [kv-map-id message form]]]

[defmacro report-when [cond form .. lmsg]
  [flist [quote when] cond
    [flist [quote report-fn] [quote gctx] [quote-list lmsg] form]]]

[defmacro report-when-not [cond form .. lmsg]
  [flist [quote when-not] cond
    [flist [quote report-fn] [quote gctx] [quote-list lmsg] form]]]

[defmacro report [form .. lmsg]
  [flist [quote report-fn] [quote gctx] [quote-list lmsg] form]]

[defn set-type-var-kind-to-type [type-var type]
  [type-var/set/kind type-var [type-var-kind/linked type]]]

[comment normalize a type make type variable point directly to the linked type - if any]
[defn normalize-type [t0]
  [match t0
    [type/var tv]
    [let [kind [type-var/kind tv]]
      [match kind
        [type-var-kind/word w] t0
        [type-var-kind/linked linked-t]
        [let-do [t2 [normalize-type linked-t]]
          [set-type-var-kind-to-type tv t2]
          t2]]]
    t0]]

[defn member-type-var-list [set t]
  [[func member-type-var-list-go [i]
    [if [lt-s i [size set]]
      [if [is-identical [at set i] t]
        1
        [member-type-var-list-go [inc i]]]
      0]] 0]]

[defn free-type-vars-growable [set t]
  [let [nt [normalize-type t]]
    [match nt
      [type/var tv]
      [when-not [member-type-var-list set tv]
        [push set tv]]

      [type/inst inst-type]
      [match inst-type
        [inst-type/func ft]
        [do
          [for-each param [func-type/params ft]
            [free-type-vars-growable set param]]
          [when-let [rest [func-type/rest-param-opt ft]]
            [free-type-vars-growable set rest]]
          [free-type-vars-growable set [func-type/result ft]]]

        [inst-type/apply type-name type-args]
        [for-each arg type-args
          [free-type-vars-growable set arg]]]]]]

[defn free-type-vars [t]
  [let-do [set [growable-list]]
    [free-type-vars-growable set t]
    [clone-growable-to-frozen-list set]]]

[defn prune-level [max-level tvs]
  [for-each tv tvs
    [type-var/set/level tv [min [type-var/level tv] max-level]]]]

[defn link-var-to-type [type-var type]
  [let
    [level [type-var/level type-var]
     fvs [free-type-vars type]]
    [do
      [assert [not [member-type-var-list fvs type-var]] type-var occurs in type
        [list fvs type-var [member-type-var-list fvs type-var]]]
      [prune-level level fvs]
      [set-type-var-kind-to-type type-var type]]]]

[defn push-unify-error [errors msg]
  [push errors msg]]

[defexpr message [.. words]
  words]

[defn unify [errors t1 t2]
  [let [nt1 [normalize-type t1]
        nt2 [normalize-type t2]]
    [match nt1
      [type/var tv1]
      [match nt2
        [type/var tv2]
        [when-not [is-identical tv1 tv2]
          [if [lt-s [type-var/level tv1] [type-var/level tv2]]
            [link-var-to-type tv1 nt2]
            [link-var-to-type tv2 nt1]]]

        [type/inst inst-type2]
        [link-var-to-type tv1 nt2]]

      [type/inst inst-type1]
      [match nt2
        [type/var tv2]
        [link-var-to-type tv2 nt1]

        [type/inst inst-type2]
        [match inst-type1
          [inst-type/func ft1]
          [match inst-type2
            [inst-type/func ft2]
            [let-do [type-args1 [func-type/params ft1] type-args2 [func-type/params ft2]
                     s1 [size type-args1] s2 [size type-args2]]
              [for i 0 [min s1 s2]
                [unify errors [at type-args1 i] [at type-args2 i]]]
              [when [not [eq s1 s2]]
                [if [lt-s s1 s2]
                  [if-let [rest1 [func-type/rest-param-opt ft1]]
                    [for i s1 s2
                      [unify errors rest1 [at type-args2 i]]]
                    [push-unify-error errors [message not unifiable - different number of parameters]]]
                  [if-let [rest2 [func-type/rest-param-opt ft2]]
                    [for i s2 s1
                      [unify errors [at type-args1 i] rest2]]
                    [push-unify-error errors [message not unifiable - different number of parameters]]]]]
              [unify errors [func-type/result ft1] [func-type/result ft2]]]

            [push-unify-error errors [message not unifiable - different types]]]

          [inst-type/apply type-name1 type-args1]
          [match inst-type2
            [inst-type/apply type-name2 type-args2]
            [if-not [eq-word type-name1 type-name2]
              [push-unify-error errors [message not unifiable - different types]]
              [do
                [assert [eq [size type-args1] [size type-args2]] different number of type arguments general]
                [for i 0 [size type-args1]
                  [unify errors [at type-args1 i] [at type-args2 i]]]]]

            [push-unify-error errors [message not unifiable - different types]]]]]]]]

[defn unify-report [gctx t1 t2 .. forms]
  [let [errors [growable-list]
        form [first forms]]
    [do
      [unify errors t1 t2]
      [for-each error [clone-growable-to-frozen-list errors]
        [report-fn gctx error form]]]]]

[defn int-to-type-var-name [i]
  [if [lt-s i [i32 26]]
    [char-code-to-word [add [i32 97] i]]
    [concat-words
      [int-to-type-var-name [i32.div-s i [i32 26]]]
      [char-code-to-word [add [i32 97] [i32.rem-s i [i32 26]]]]]]]

[defn generate-fresh-type-var-atom [counter-atom level]
  [type/var [type-var [type-var-kind/word [int-to-type-var-name [inc-atom counter-atom]]] level]]]

[defn generate-fresh-type-var [gctx level]
  [generate-fresh-type-var-atom [getq gctx type-var-counter] level]]

[defn unify-call [gctx level func-type arg-types form]
  [let [t-res [generate-fresh-type-var gctx level]
        t-func [type-func arg-types [none] t-res]]
    [unify-report gctx func-type t-func form]
    t-res]]

[type type-scheme []
  [record
    [type-vars [list type-var]]
    [type type]]]

[defn mk-type-scheme [type-vars type] [type-scheme type-vars type]]

[defn mk-empty-type-scheme [type] [mk-type-scheme [list] type]]

[defn generalize [current-level type]
  [let-do [tvs [growable-list]]
    [for-each tv [free-type-vars type]
      [when [lt-s current-level [type-var/level tv]]
        [push tvs tv]]]
    [mk-type-scheme [clone-growable-to-frozen-list tvs] type]]]

[defn try-get-assoc-identical [assoc-list var]
  [[func try-get-assoc-identical-go [i]
    [if [lt-s i [size assoc-list]]
      [let [pair [at assoc-list i]]
        [if [is-identical var [first pair]]
          [some [second pair]]
          [try-get-assoc-identical-go [inc i]]]]
      [none]]]
    0]]

[defn copy-type [subst-map t]
  [match t
    [type/var tv]
    [if-let [subst-type [try-get-assoc-identical subst-map tv]]
      subst-type
      [match [type-var/kind tv]
        [type-var-kind/word w] t
        [type-var-kind/linked linked-t] [copy-type subst-map linked-t]]]

    [type/inst inst-type]
    [match inst-type
      [inst-type/func ft]
      [type-func
        [list-map param [func-type/params ft] [copy-type subst-map param]]
        [if-let [rest [func-type/rest-param-opt ft]]
          [some [copy-type subst-map rest]]
          [none]]
        [copy-type subst-map [func-type/result ft]]]

      [inst-type/apply type-name type-args]
      [type/inst [inst-type/apply type-name [list-map arg type-args [copy-type subst-map arg]]]]]]]

[defn specialize [gctx level type-vars type]
  [if [is-empty type-vars]
    type
    [let [subst-assoc-list [list-map tv type-vars [list tv [generate-fresh-type-var gctx level]]]]
      [copy-type subst-assoc-list type]]]]

[defn specialize-type-scheme [gctx level type-scheme]
  [specialize gctx level [type-scheme/type-vars type-scheme] [type-scheme/type type-scheme]]]

[type
  local-context []
  [record
    [vars kv-map]
    [outer [option local-context]]
    [first-form form]]]

[defn make-local-context [var-values lctx-opt first-form]
  [some [local-context var-values lctx-opt first-form]]]

[defn try-get-local-var-type [local-ctx var-name]
  [[func go [cur-ctx]
    [if-let [type [try-get [local-context/vars cur-ctx] var-name]]
      [some type]
      [if-let [outer [local-context/outer cur-ctx]]
        [go outer]
        [none]]]] local-ctx]]

[defn try-get-var-type [gctx local-ctx-opt var-name]
  [if-let [ltype [if-let [local-ctx local-ctx-opt]
                    [try-get-local-var-type local-ctx var-name]
                    [none]]]
    [some ltype]
    [try-get [getq gctx def-var-types] var-name]]]

[defn params-to-map [params]
  [if [and [lt-s 1 [size params]] [eq-form-word [at params -2] [quote ..]]]
    [kv-mapq params [slice params 0 [sub [size params] 2]]
             rest-param [last params]]
    [kv-mapq params params]]]

[defn check-type-arity [gctx type-name n-of-given-type-args]
  [ifs
    [eq-form type-name [quote tuple]]
    [report-when [eq n-of-given-type-args 1] type-name tuple type expects zero or multiple arguments]

    [or
      [eq-form type-name [quote i32]]
      [eq-form type-name [quote word]]]
    [report-when [eq n-of-given-type-args 0] type-name atomic type expects no arguments]

    [eq-form type-name [quote list]]
    [report-when-not [eq n-of-given-type-args 1] type-name list type expects one argument]

    [eq-form type-name [quote func]]
    [report-when-not [eq n-of-given-type-args 3]
      type-name func type expects a parameter list a rest parameter list and a return type]

    [if-let [type-name-word [try-get-form-word-option type-name]]
      [if-let [type [try-get [getq gctx types] type-name-word]]
        [let [arity [getq type arity]]
          [report-when-not [eq n-of-given-type-args arity]
            type-name type expects [identity arity] arguments]]
        [report type-name not a known type [identity type-name]]]
      [logq-abort check-builtin-type-arity type-name not a known builtin type [identity type-name]]]]]

[defn is-builtin-type [word]
  [or [eq-word word [word i32]]
      [eq-word word [word word]]

      [eq-word word [word tuple]]

      [eq-word word [word list]]

      [eq-word word [word func]]]]

[comment given a type such as [func [i32 i32] i32] instantiates to a type-scheme]
[defn instantiate-annotated-type [gctx type-var-env type]
  [ifs
    [eq-form type [quote i32]]
    type-i32

    [eq-form type [quote word]]
    type-word

    [eq-form type [quote form]]
    type-form

    [is-word type]
    [let-do [w [form-to-word type]]
      [if-let [t [try-get type-var-env w]]
        t
        [logq-abort type could not be instantiated - not known - [identity type] [identity type-var-env]]]]

    [not [is-list type]]
    [logq-abort type expected word or list]

    [let-do [elements [form-to-list type]
          first-form [first elements]
          s-form [size elements]
          n-of-args [dec s-form]]
      [comment todo make this safe for empty lists]
      [if [eq s-form 0]
        [logq-abort type expects a non-empty list]
        [ifs
          [not [is-word first-form]]
          [logq-abort type expects a word [identity first-form]]

          [eq-form first-form [quote func]]
          [do
            [report-when-not [eq n-of-args 2] type expects 2 arguments a parameter list and a return type]
            [let [params [second elements]
                  - [report-when-not [is-list params] type expects a list]
                  params-list [form-to-list params]
                  result [third elements]
                  params-map [params-to-map params-list]
                  reg-params [getq params-map params]
                  internal-params
                  [list-map param reg-params
                    [do
                      [report-when [eq-form param [quote ..]] param .. in wrong place]
                      [instantiate-annotated-type gctx type-var-env param]]]]
              [type-func
                internal-params
                [if-let [rest-param [try-getq params-map rest-param]]
                  [some [instantiate-annotated-type gctx type-var-env rest-param]]
                  [none]]
                [instantiate-annotated-type gctx type-var-env result]]]]

          [eq-form first-form [quote type-scheme]]
          [do
            [report-when-not [eq n-of-args 2] type type-scheme expects 2 arguments]
            [let-do [type-vars [second elements]
                     type [third elements]
                     type-var-env [transient-kv-map]]
              [report-when-not [is-list type-vars] type type-vars expects a list]
              [for-each tv [form-to-list type-vars]
                [report-when-not [is-word tv] type-vars expects a word]
                [set-kv-map type-var-env [form-to-word tv] [generate-fresh-type-var gctx 0]]]
              [instantiate-annotated-type gctx type-var-env type]]]

          [let-do [type-args [mutable-list-of-size n-of-args]]
            [check-type-arity gctx first-form n-of-args]
            [for i 0 n-of-args
              [set-array type-args i [instantiate-annotated-type gctx type-var-env [at elements [inc i]]]]]
            [make-type-list [form-to-word first-form] type-args]]]]]]]

[def try-get-macro [extern interpreter try-get-macro]]
[def interpreter-apply [extern interpreter apply]]

[defn try-get-form-word-option [form]
  [match form
    [form-word w] [some w]
    [none]]]

[defn try-get-ctor [t]
  [match t
    [type/var tv]
    [none]

    [type/inst inst-type]
    [match inst-type
      [inst-type/func ft]
      [if [func-type/is-ctor ft]
        [some ft]
        [none]]

      [inst-type/apply type-name type-args]
      [none]]]]

[defn try-get-word-report [form]
  [match form
    [form/word w] [some w]
    [do
      [report form expected a word]
      [none]]]]

[defn try-get-list-report [form]
  [match form
    [form/list l] l
    [do
      [report form expected a list]
      [list]]]]

[defn check [gctx level lctx form]
  [ifs
    [is-word form]
    [if-let [type-scheme [try-get-var-type gctx lctx [form-to-word form]]]
      [specialize-type-scheme gctx level type-scheme]
      [do
        [report form not found]
        [generate-fresh-type-var gctx level]]]

    [not [is-list form]]
    [logq-abort check input not a form [identity form]]

    [let [sub-forms [form-to-list form]
          s-form [size sub-forms]
          first-form [first sub-forms]
          n-of-args [dec s-form]]
      [ifs
        [eq-form [quote i32] first-form]
        [do
          [report-when-not [eq n-of-args 1] form expects 1 argument]
          type-i32]

        [eq-form [quote word] first-form]
        [do
          [report-when-not [eq n-of-args 1] form expects 1 argument]
          type-word]

        [eq-form [quote quote] first-form]
        [do
          [report-when-not [eq n-of-args 1] form expects 1 argument]
          type-form]

        [eq-form first-form [quote if]]
        [let-do
          [cond [second sub-forms]
           then-branch [third sub-forms]
           else-branch [fourth sub-forms]
           cond-type [check gctx level lctx cond]
           then-type [check gctx level lctx then-branch]
           else-type [check gctx level lctx else-branch]]
          [report-when-not [eq n-of-args 3] form expects 3 argument]
          [unify-report gctx cond-type type-i32 cond]
          [unify-report gctx then-type else-type then-branch else-branch]
          then-type]

        [eq-form first-form [quote type]]
        [let-do
          [types [getq gctx types]
           def-var-types [getq gctx def-var-types]]
          [report-when-not [eq [i32.rem-s n-of-args 3] 0] form expects triplets of arguments]
          [for-3 i 1 s-form
            [let [name-form [at sub-forms i]]
              [when-let [name-word [try-get-word-report name-form]]
                [ifs
                  [is-builtin-type name-word]
                  [report name-form built-in type cannot be redefined]

                  [has types name-word]
                  [report name-form already defined]

                  [let-do [type-params-list [try-get-list-report [at sub-forms [inc i]]]
                          param-map [transient-kv-map]
                          type-args [growable-list]]
                    [for-each param type-params-list
                      [when-let [param-word [try-get-word-report param]]
                        [report-when [has param-map param-word] param already defined]
                        [let-do [tv [generate-fresh-type-var gctx level]]
                          [set-kv-map param-map param-word tv]
                          [push type-args tv]]]]
                    [set-kv-map types name-word
                      [kv-mapq
                        arity [size type-params-list]
                        param-map param-map
                        result-type [make-type-list name-word [clone-growable-to-frozen-list type-args]]]]]]]]]
          [for-3 i 1 s-form
            [when-let [name-word [try-get-form-word-option [at sub-forms i]]]
              [let-do
                [type-prefix [concat-words name-word [word /]]
                 this-type [get types name-word]
                 result-type [getq this-type result-type]
                 param-map [getq this-type param-map]
                 type-def-list [try-get-list-report [at sub-forms [add 2 i]]]]
                [ifs
                  [eq-form [quote union] [first type-def-list]]
                  [for i 1 [size type-def-list]
                    [let-do [ctor [try-get-list-report [at type-def-list i]]
                             param-list [list-map param [slice ctor 1 [size ctor]] [instantiate-annotated-type gctx param-map param]]]
                      [when-let [ctor-name [try-get-word-report [first ctor]]]
                        [set-kv-map def-var-types [concat-words type-prefix ctor-name]
                          [generalize 0 [type-ctor param-list result-type]]]]]]

                  [eq-form [quote record] [first type-def-list]]
                  [let-do
                    [fields [growable-list]]
                    [for i 1 [size type-def-list]
                      [let-do
                        [type-def-list [try-get-list-report [at type-def-list i]]
                         inst-field-type [instantiate-annotated-type gctx param-map [second type-def-list]]]
                        [push fields inst-field-type]
                        [when-let [field-name [try-get-word-report [first type-def-list]]]
                          [set-kv-map def-var-types [concat-words type-prefix field-name]
                            [generalize 0 [type-func [list result-type] [none] inst-field-type]]]]]]
                    [set-kv-map def-var-types name-word
                      [generalize 0 [type-func [clone-growable-to-frozen-list  fields] [none] [getq [get types name-word] result-type]]]]]

                  [logq-abort check type definition not recognized [first type-def-list]]]]]]]

        [eq-form first-form [quote match]]
        [let-do [match-value [second sub-forms]
                 match-type [check gctx level lctx match-value]
                 result-type [generate-fresh-type-var gctx level]]
          [for-pair i 2 [dec s-form]
            [let [pattern [at sub-forms i]
                  branch [at sub-forms [inc i]]]
              [match pattern
                [form-list pattern-list]
                [if [is-empty pattern-list]
                  [report pattern expects a non-empty list]
                  [let-do
                    [destructor-type [check gctx level lctx [first pattern-list]]
                     destructor-opt [try-get-ctor [normalize-type destructor-type]]]
                      [if-let [destructor destructor-opt]
                        [let-do [destructor-params [func-type/params destructor]
                                 var-values [transient-kv-map]
                                 branch-ctx [make-local-context var-values lctx first-form]]
                          [report-when-not [eq [size destructor-params] [dec [size pattern-list]]]
                            pattern-list and destructor-params have different sizes]
                          [for i 1 [size pattern-list]
                            [if-let [pattern-var [try-get-form-word-option [at pattern-list i]]]
                              [let [general-val-type [generalize level [at destructor-params [dec i]]]]
                                [set-kv-map var-values pattern-var general-val-type]]
                              [report [at pattern-list i] expects a word]]]
                          [unify-report gctx match-type [func-type/result destructor] pattern]
                          [unify-report gctx [check gctx level branch-ctx branch] result-type branch]]
                        [report [first pattern-list] destructor not found]]]]

                  [do
                    [report pattern expects a list]
                    [generate-fresh-type-var gctx level]]]]]
          result-type]

        [eq-form first-form [quote do]]
        [if n-of-args
          [do
            [for i 1 n-of-args
              [check gctx level lctx [at sub-forms i]]]
            [check gctx level lctx [last sub-forms]]]
          type-empty-tuple]

        [eq-form first-form [quote let]]
        [let-do
          [var-values [transient-kv-map]
           let-ctx [make-local-context var-values lctx first-form]
           bindings
            [if [lt-s 1 s-form]
              [form-to-list [second sub-forms]]
              [do [report form expects bindings] [list]]]
           n-of-bindings [size bindings]
           level-1 [inc level]]
          [report-when-not [eq n-of-args 2] form expects two arguments]
          [when [lt-s 1 s-form]
            [for-pair i 0 [dec n-of-bindings]
              [let-do
                [var [form-to-word [at bindings i]]
                 value [at bindings [inc i]]
                 val-type [check gctx level-1 let-ctx value]
                 general-val-type [generalize level val-type]]
                [set-kv-map var-values var general-val-type]]]]
          [for i 2 [dec s-form]
            [check gctx level let-ctx [at sub-forms i]]]
          [if [lt-s 2 s-form]
            [check gctx level let-ctx [last sub-forms]]
            type-empty-tuple]]

        [or
          [eq-form first-form [quote func]]
          [eq-form first-form [quote macro]]
          [eq-form first-form [quote fexpr]]]
        [let-do
          [level-1 [inc level]
           func-name [second sub-forms]
           params-form [third sub-forms]
           body [fourth sub-forms]
           params [form-to-list params-form]
           param-ctx [transient-kv-map]
           parsed-params [params-to-map params]
           reg-params-parsed [getq parsed-params params]
           func-type [generate-fresh-type-var gctx level-1]
           func-ctx [make-local-context param-ctx lctx first-form]
           reg-params [growable-list]
           takes-form-params [or [eq-form first-form [quote macro]] [eq-form first-form [quote fexpr]]]]
          [report-when-not [eq n-of-args 3] form expects 3 arguments]
          [set-kv-map param-ctx [form-to-word func-name] [mk-empty-type-scheme func-type]]
          [for-each param reg-params-parsed
            [let-do [tv [if takes-form-params type-form [generate-fresh-type-var gctx level-1]]]
              [set-kv-map param-ctx [form-to-word param] [mk-empty-type-scheme tv]]
              [push reg-params tv]]]
          [let-do
            [opt-rest-param
                [if-let [rest-param [try-getq parsed-params rest-param]]
                  [let-do [tv [if takes-form-params type-form [generate-fresh-type-var gctx level-1]]]
                    [set-kv-map param-ctx [form-to-word rest-param]
                      [mk-empty-type-scheme [type-list tv]]]
                    [some tv]]
                  [none]]
                return-type [check gctx level-1 func-ctx body]]
            [unify-report gctx
              func-type
              [type-func
                [clone-growable-to-frozen-list reg-params]
                opt-rest-param
                return-type]
              form]
            [when [eq-form first-form [quote macro]]
              [unify-report gctx return-type type-form body]]]
          func-type]

        [eq-form first-form [quote def]]
        [let-do
          [name [second sub-forms]
           value-form [third sub-forms]
           value-type [check gctx [inc level] lctx value-form]
           general-val-type [generalize level value-type]]
          [report-when-not [eq n-of-args 2] form expects 2 arguments]
          [set-kv-map [getq gctx def-var-types] [form-to-word name] general-val-type]
          value-type]

        [eq-form first-form [quote extern]]
        [do
          [for i 1 s-form
            [let [sf [at sub-forms i]]
              [report-when-not [is-word sf] sf expects words]]]
          [generate-fresh-type-var gctx level]]

        [eq-form first-form [quote type-anno]]
        [let-do
          [value-form [second sub-forms]
           annotated-type [third sub-forms]
           value-type [check gctx level lctx value-form]
           inst-anno-type [instantiate-annotated-type gctx [kv-mapq] annotated-type]]
          [report-when-not [eq n-of-args 2] form expects 2 arguments]
          [unify-report gctx inst-anno-type value-type form]
          value-type]

        [let [eval-context [getq gctx eval-context]]
          [if-let [mac [if-let [w [try-get-form-word-option first-form]]
                        [try-get-macro eval-context w]
                        [none]]]
            [let-do [expanded-form [interpreter-apply eval-context mac [slice sub-forms 1 s-form]]]
              [check gctx level lctx expanded-form]]
            [let-do
              [func-type [check gctx level lctx first-form]
               arg-types [mutable-list-of-size n-of-args]]
              [for i 0 n-of-args
                [set-array arg-types i [check gctx level lctx [at sub-forms [inc i]]]]]
              [let-do
                [t-res [generate-fresh-type-var gctx level]
                 t-func [type-func arg-types [none] t-res]]
                [unify-report gctx func-type t-func form]
                t-res]]]]]]]]

[def make-eval-context [extern interpreter make-context]]

[defn make-global-context []
  [kv-mapq
    messages [growable-list]
    def-var-types [transient-kv-map]
    type-var-counter [atom 0]
    types [transient-kv-map]
    eval-context [make-eval-context]]]

[def evaluate [extern interpreter evaluate]]

[defn check-top [gctx form]
  [logq form [identity form]]
  [evaluate [getq gctx eval-context] form]
  [check gctx 0 [none] form]]

[defn check-top-forms [gctx forms]
  [assert [size forms] check-top-forms expects at least one form]
  [logq we are checking]
  [[func check-top-forms-go [i]
    [if [lt-s i [dec [size forms]]]
      [do
        [check-top gctx [at forms i]]
        [check-top-forms-go [inc i]]]
      [check-top gctx [at forms i]]]] 0]]

[defn internal-to-present-type [internal-type]
  [let [nt internal-type]
    [match nt
      [type/var tv]
      [let-do [kind [type-var/kind tv]]
        [match kind
          [type-var-kind/linked lt] [logq-abort internal-to-present-type expected a non-linked type var]
          [type-var-kind/word w] [form-word w]]]

      [type/inst inst-type]
      [match inst-type
        [inst-type/func ft]
        [flist [quote func]
          [if-let [rest-type [func-type/rest-param-opt ft]]
            [form-concat [list-map type [func-type/params ft] [internal-to-present-type type]] [list [quote ..] [internal-to-present-type rest-type]]]
            [form-list [list-map type [func-type/params ft] [internal-to-present-type type]]]]
          [internal-to-present-type [func-type/result ft]]]

        [inst-type/apply type-name type-args]
        [if [eq-word type-name [word tuple]]
          [form-concat [list [quote tuple]] [list-map type type-args [internal-to-present-type type]]]
          [let [n-of-args [size type-args]
                present-type [mutable-list-of-size [inc n-of-args]]]
          [if n-of-args
            [let-do [present-type [mutable-list-of-size [inc n-of-args]]]
              [set-array present-type 0 [form-word type-name]]
              [for i 0 n-of-args
                [set-array present-type [inc i] [internal-to-present-type [at type-args i]]]]
              [freeze-mutable-list present-type]
              [form-list present-type]]
            [form-word type-name]]]]]]]]

[defn normalize-deep [internal-type]
  [let-do [nt [normalize-type internal-type]]
    [match nt
      [type/var tv]
      [match [type-var/kind tv]
        [type-var-kind/linked lt] [logq-abort normalize-deep expected a non-linked type var]
        [do]]

      [type/inst inst-type]
      [match inst-type
        [inst-type/func ft]
        [do
          [for-each param [func-type/params ft] [normalize-deep param]]
          [when-let [rest-type [func-type/rest-param-opt ft]]
            [normalize-deep rest-type]]
          [normalize-deep [func-type/result ft]]]

        [inst-type/apply type-name type-args]
        [for-each type-arg type-args
          [normalize-deep type-arg]]]]]]

[defn normalize-present-type-scheme [internal-type]
  [normalize-deep internal-type]
  [let-do
       [type-vars [free-type-vars internal-type]
        type-var-counter [atom 0]
        fresh-type-vars [list-map tv type-vars [generate-fresh-type-var-atom type-var-counter 0]]
        subst-assoc-list [mutable-list-of-size [size type-vars]]
        new-present-type-vars [list-map tv fresh-type-vars [internal-to-present-type tv]]]
    [for i 0 [size type-vars]
      [let [tv [at type-vars i]
            new-tv [at fresh-type-vars i]]
        [set-array subst-assoc-list i [list tv new-tv]]]]
    [if [is-empty new-present-type-vars]
      [internal-to-present-type [copy-type subst-assoc-list internal-type]]
      [flist [quote type-scheme]
        [form-list new-present-type-vars]
        [internal-to-present-type [copy-type subst-assoc-list internal-type]]]]]]
