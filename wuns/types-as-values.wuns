[load std.wuns]

[type name []
  [record
    [word word]]]

[type integer []
  [record
    [value i32]]]

[type
  exp []
  [union
    [constructor word]
    [i32 i32]
    [f64 f64]
    [call exp [list exp]]

    [var name]
    [if exp exp exp]
    [cast exp exp]
    [import name name import-kind]
    [deref exp]
    [assign exp exp]
    [intrinsic name [list exp]]
    ]

  import-kind []
  [union
    [memory exp integer [option integer]]
    [function [list exp] exp]]]

[comment
    [let [list [pair name exp]] [list exp]]
    [loop [list [pair name exp]] [list exp]]
    [continue [list [pair name exp]]]
    [do [list exp]]
    [field exp name]
    [index exp exp]
    [size-of exp]
]

[defn is-normal-form [exp]
  [match exp
    [exp/constructor w]
    true

    [exp/i32 i]
    true

    [exp/f64 f]
    true

    [exp/call f args]
    [match f
      [exp/constructor w]
      [all args is-normal-form]

      false]

    false]]

[defn exp-eq [t1 t2]
  [logq exp-eq [identity t1]]
  [logq exp-eq [identity t2]]
  [assert [is-normal-form t1] exp-eq expects normal form [identity t1]]
  [assert [is-normal-form t2] exp-eq expects normal form [identity t2]]
  [if [is-identical t1 t2]
    true
    [match t1
      [exp/constructor s1]
      [match t2
        [exp/constructor s2]
        [eq-word s1 s2]
        false]

      [exp/i32 s1]
      [match t2
        [exp/i32 s2]
        [eq s1 s2]
        false]

      [exp/call constr1 ts1]
      [match t2
        [exp/call constr2 ts2]
        [and
          [exp-eq constr1 constr2]
          [eq [size ts1] [size ts2]]
          [loop [i 0 n [size ts1]]
            [if [lt-s i n]
              [if [exp-eq [at ts1 i] [at ts2 i]]
                [continue i [inc i]]
                false]
              true]]]

        false]

      false]]]

[type exp-function []
  [record
    [name name]
    [params [list [pair name exp]]]
    [return-type exp]
    [bodies [list exp]]]]

[type top-exp []
  [union
    [constant name exp]
    [function exp-function]]]

[type defunc-desc []
  [record
    [params [list [pair name exp]]]
    [return-type exp]]]

[type top-desc []
  [union
    [constant exp exp]
    [function defunc-desc]]]

[type local-var-kind []
  [union
    [param exp]
    [let-loop exp]]]

[type local-context-kind []
  [union [func] [let] [loop] [def]]]

[type local-context []
  [record
    [outer [option local-context]]
    [names [transient-kv-map word local-var-kind]]
    [kind local-context-kind]]]

[type desc []
  [union
    [local [pair local-var-kind local-context-kind]]
    [top top-desc]]]

[type top-context []
  [record
    [errors [list [pair form [list form]]]]
    [top-names [transient-kv-map word top-desc]]]]

[defn error-fn [errors exp message-form]
  [push errors [pair exp message-form]]]

[defmacro error [form .. message]
  [flist [quote error-fn] [quote errors] form [quote-list message]]]

[defn local-context-make [outer vars kind]
  [local-context [option/some outer] vars kind]]

[defn local-context-make-top [vars kind]
  [local-context [option/none] vars kind]]

[defn try-get-local [lctx name]
  [loop [cur lctx]
    [if-let [v [try-get [local-context/names cur] name]]
      [option/some [pair v [local-context/kind cur]]]
      [if-let [o [local-context/outer cur]]
        [continue cur o]
        [option/none]]]]]

[def ctor-i32 [exp/constructor [word i32]]]
[def ctor-f64 [exp/constructor [word f64]]]
[def type-type [exp/constructor [word type]]]
[def ctor-tuple [exp/constructor [word tuple]]]
[def ctor-array [exp/constructor [word array]]]
[def ctor-func [exp/constructor [word func]]]
[def ctor-memory [exp/constructor [word memory]]]
[def ctor-pointer [exp/constructor [word pointer]]]
[def ctor-record [exp/constructor [word record]]]

[defn exp-call [f .. args] [exp/call f args]]
[def empty-tuple [exp-call ctor-tuple]]
[defn tuple-make-list [params] [if [is-empty params] empty-tuple [exp/call ctor-tuple params]]]

[defn type-func [params ret] [exp-call ctor-func [tuple-make-list params] ret]]
[defn type-array [elem-type size] [exp-call ctor-array elem-type size]]
[defn type-memory [pointer-type] [exp-call ctor-memory pointer-type]]
[defn type-pointer [memory target] [exp-call ctor-pointer memory target]]

[defn type-field [name type] [exp-call ctor-tuple name type]]
[defn type-record [fields] [exp/call ctor-record fields]]
[def type-error [exp/constructor [word error]]]

[defn defunc-desc-to-func-type [dd]
  [type-func
    [list-map p [defunc-desc/params dd] [pair/snd p]]
    [defunc-desc/return-type dd]]]

[defn try-get-ctor-call [t]
  [match t
    [exp/call call-target args]
    [match call-target
      [exp/constructor wp]
      [option/some [pair wp args]]
      [option/none]]
    [option/none]]]

[defn try-get-pointer-args [t]
  [if-let [ctor-call [try-get-ctor-call t]]
    [if [eq-word [word pointer] [pair/fst ctor-call]]
      [let [args [pair/snd ctor-call]]
        [option/some [pair [first args] [second args]]]]
      [option/none]]
    [option/none]]]

[defn make-top-names []
  [let [
    built-words [list [word i32] [word f64] [word type]
      [word memory] [word tuple]]
    top-names [transient-kv-map]]
    [for-each w built-words
      [set-kv-map top-names w [top-desc/constant type-type [exp/constructor w]]]]
    top-names]]

[defn bind [errors top-names]
  [let
    [name-to-form [transient-kv-map]]
    [letfn [
[func get-word [f]
  [if-let [w [try-get-word f]]
    w
    [do
      [error f expected word]
      [word --not-a-word--]]]]
[func get-list [f]
  [if-let [w [try-get-list f]]
    w
    [do
      [error f expected list]
      [list]]]]
[func form-to-name [f]
  [if-let [w [try-get-word f]]
    [let [n [name w]]
      [set-kv-map name-to-form n f]
      n]
    [logq-abort expected word [identity f]]]]
[func form-to-integer [f]
  [if-let [w [try-get-word f]]
    [integer [word-to-int w]]
    [logq-abort expected word]]]
[func try-get-desc [lctx w]
  [if-let [ldesc [try-get-local lctx w]]
    [option/some [desc/local ldesc]]
    [if-let [top-desc [try-get top-names w]]
      [option/some [desc/top top-desc]]
      [option/none]]]]
[func get-name [lctx n]
  [if-let [desc [try-get-desc lctx [name/word n]]]
    desc
    [logq-abort get-name problem [name/word n]]]]

[func form-to-import-kind [lctx form]
  [let [l [get-list form]]
    [assert-not [is-empty l] form-to-import-kind expected non-empty list]
    [switch [form-to-word [first l]]
      [[word memory]]
      [do
        [assert [or [eq [size l] 3] [eq [size l] 4]] import memory expected 3 or 4 elements]
        [import-kind/memory
          [form-to-exp lctx [second l]]
          [form-to-integer [third l]]
          [if [eq [size l] 3]
            [option/none]
            [option/some [form-to-integer [fourth l]]]]]]

      [[word func]]
      [do
        [assert [eq [size l] 2] import func expected 2 elements]
        [import-kind/function
          [list-map param [get-list [second l]] [form-to-exp lctx param]]
          [form-to-exp lctx [third l]]]]

      [logq-abort not implemented import-kind [first l]]]]]

[func form-special-to-exp [lctx fw l]
  [switch fw
    [[word constructor]]
    [exp/constructor
      [form-to-word [second l]]]

    [[word if]]
    [exp/if
      [form-to-exp lctx [second l]]
      [form-to-exp lctx [third l]]
      [form-to-exp lctx [fourth l]]]

    [[word cast]]
    [exp/cast
      [form-to-exp lctx [second l]]
      [form-to-exp lctx [third l]]]

    [[word import]]
    [exp/import
      [form-to-name [second l]]
      [form-to-name [third l]]
      [form-to-import-kind lctx [fourth l]]]

    [[word deref]]
    [exp/deref [form-to-exp lctx [second l]]]

    [[word assign]]
    [exp/assign
      [form-to-exp lctx [second l]]
      [form-to-exp lctx [third l]]]

    [[word intrinsic]]
    [exp/intrinsic
      [form-to-name [second l]]
      [list-map arg [slice l 2 [size l]] [form-to-exp lctx arg]]]

    [logq-abort not impl [identity fw]]]]

[func form-to-exp [lctx f]
  [match f
    [form/word w]
    [let [n [form-to-name f]]
      [get-name lctx n]
      [exp/var n]]

    [form/list l]
    [let [ff [first l]
          args [rest l]]
      [if-let [fw [try-get-word ff]]
        [if-let [desc [try-get-desc lctx fw]]
          [match desc
            [desc/top td]
            [match td
              [top-desc/constant desc-type desc-exp]
              [ifs
                [exp-eq desc-exp ctor-i32]
                [do
                  [when-not [eq [size args] 1]
                    [error f expected 1 argument got]]
                  [exp/i32 [word-to-int [get-word [first args]]]]]

                [exp-eq desc-exp ctor-f64]
                [do
                  [when-not [eq [size args] 1]
                    [error f expected 1 argument got]]
                  [exp/f64 [word-to-f64 [get-word [first args]]]]]

                [exp/call [exp/var [form-to-name ff]] [list-map arg args [form-to-exp lctx arg]]]]

              [top-desc/function fd]
              [exp/call
                [exp/var [form-to-name ff]]
                [list-map arg args [form-to-exp lctx arg]]]]
            [logq-abort not implemented local call]]
          [form-special-to-exp lctx fw l]]
        [exp/call [form-to-exp lctx ff] [list-map arg args [form-to-exp lctx arg]]]]]]]

[func evaluate [lctx exp]
  [match exp
    [exp/call f args]
    [exp/call [evaluate lctx f] [list-map arg args [evaluate lctx arg]]]

    [exp/var n]
    [match [get-name lctx n]
      [desc/top td]
      [match td
        [top-desc/constant desc-type desc-exp]
        desc-exp
        exp]
      [desc/local ld]
      exp]

    [exp/if c t e]
    [match [evaluate lctx c]
      [exp/i32 ec]
      [evaluate lctx [if [eq ec 0] e t]]
      [logq-abort eval exp condition not i32]]

    [exp/cast t e]
    [exp/cast
      [evaluate lctx t]
      [evaluate lctx e]]

    exp]]

      [func form-to-eval [lctx f]
        [evaluate lctx [form-to-exp lctx f]]]
[func type-of [lctx exp]
  [match exp
    [exp/constructor w]
    type-type

    [exp/i32 i]
    ctor-i32

    [exp/f64 f]
    ctor-f64

    [exp/if c t e]
    [do
      [when-not [exp-eq [type-of lctx c] ctor-i32] [logq-abort eval exp condition not i32]]
      [let [tt [type-of lctx t]]
        [when-not [exp-eq tt [type-of lctx e]] [logq-abort eval exp branches not same type]]
        tt]]

    [exp/call f args]
    [match f
      [exp/var fn]
      [match [get-name lctx fn]
        [desc/top td]
        [match td
          [top-desc/function fd]
          [let [params [defunc-desc/params fd]]
            [when-not [eq [size params] [size args]] [logq-abort eval exp expected n arguments got m]]
            [for i 0 [min [size params] [size args]]
              [let [param-pair [at params i]
                    pname [pair/fst param-pair]
                    ptype [pair/snd param-pair]
                    arg [at args i]]
                [when-not [exp-eq [type-of lctx arg] ptype] [logq-abort eval exp expected type got]]]]
            [defunc-desc/return-type fd]]
          [logq-abort not implemented type-of call]]
        [desc/local ld]
        exp]
      [exp/constructor cn]
      type-type
      ]

    [exp/import n m ik]
    [match ik
      [import-kind/memory et s os]
      [do
        [todo type should include index or name of type...]
        [type-memory [evaluate lctx et]]]

      [import-kind/function ps rt]
      [type-func ps rt]

      [logq-abort not implemented type-of import]]

    [exp/cast t e]
    [let [tt [type-of lctx t]]
      [when-not [exp-eq tt type-type] [logq-abort eval exp expected type got]]
      [evaluate lctx t]]

    [exp/var n]
    [match [get-name lctx n]
      [desc/top td]
      [match td
        [top-desc/constant desc-type desc-exp]
        desc-type
        exp]
      [desc/local ld]
      exp]

    [exp/intrinsic intrinsic-name args]
    [switch [name/word intrinsic-name]
      [[word i32.add] [word i32.sub] [word i32.mul]]
      [do
        [assert [eq [size args] 2] intrinsic expected 2 arguments]
        [assert [exp-eq [type-of lctx [at args 0]] ctor-i32] intrinsic expected i32 ]
        [assert [exp-eq [type-of lctx [at args 1]] ctor-i32] intrinsic expected i32]
        ctor-i32]

      [logq-abort not implemented type-of intrinsic]]

    [exp/deref target]
    [let [target-type [type-of lctx target]]
      [logq target-type [identity target-type]]
      [if-let [p [try-get-pointer-args target-type]]
        [pair/snd p]
        [do
          type-error]]]

    [exp/assign target source]
    [let [target-pointer-type [type-of lctx target]
          source-type [type-of lctx source]]
      [when-let [p [try-get-pointer-args target-pointer-type]]
        [when-not [exp-eq [pair/snd p] source-type] [logq-abort eval exp expected type got]]]
      empty-tuple]

    [logq-abort not implemented type-of [identity exp]]]]
[func bind-top [name-form desc]
  [let [n [get-word name-form]]
    [when [has top-names n]
      [error name-form name already defined]]
    [set-kv-map top-names n desc]]]
[func top-form-to-top-exp [form]
  [let [l [get-list form]]
    [if [is-empty l]
      [do
        [error form expected non-empty list]
        [option/none]]
      [let [f [first l]
            fw [get-word f]]
        [when [has top-names fw]
          [error f top-level calls not yet implemented]]
        [switch fw
          [[word def]]
          [do
            [when-not [eq [size l] 3] [error form expected def name exp-form]]
            [let
              [be
                [form-to-eval
                  [local-context-make-top [transient-kv-map] [local-context-kind/def]]
                  [third l]]
               type [type-of [local-context-make-top [transient-kv-map] [local-context-kind/def]] be]
               bt [top-exp/constant [form-to-name [second l]] be]]
              [bind-top [second l] [top-desc/constant type be]]
              [option/some bt]]]

          [[word defn]]
          [do
            [when [lt-s [size l] 3]
              [error form function expected name params return-type bodies]]
            [let
              [params-list [get-list [third l]]
               return-type-form [fourth l]
               param-ctx [transient-kv-map]
               lctx [local-context-make-top param-ctx [local-context-kind/func]]
               parameters
               [list-map p [pairwise-pairs params-list]
                 [let [pname [form-to-name [pair/fst p]]
                       ptype [form-to-eval lctx [pair/snd p]]
                       ptype-type [type-of lctx ptype]]
                  [when-not [exp-eq ptype-type type-type]
                    [logq-abort defn parameter was not a type [identity ptype-type]]]
                  [set-kv-map param-ctx [name/word pname] [local-var-kind/param ptype]]
                  [pair pname ptype]]]
               return-type [form-to-eval lctx return-type-form]]
              [bind-top [second l]
                [top-desc/function
                  [defunc-desc parameters return-type]]]
              [let
                [cbodies [list-map body [slice l 4 [size l]] [form-to-eval lctx body]]
                 inferred-return-type
                 [if [is-empty cbodies]
                   empty-tuple
                   [type-of lctx [last cbodies]]]]
                [logq defn [second l]]
                [logq return-type [identity return-type]]
                [logq inferred-return-type [identity inferred-return-type]]
                [when-not [exp-eq return-type inferred-return-type]
                  [logq-abort return type mismatch [identity return-type] [identity inferred-return-type]]]
                [option/some
                  [top-exp/function
                    [exp-function
                      [form-to-name [second l]]
                      parameters
                      return-type
                      cbodies]]]]]]
          [logq-abort not implemented [identity fw]]]]]]]]
    top-form-to-top-exp]]]

[defexpr qlist [.. fs] fs]

[defn bind-forms-fn [forms]
  [let
    [gerrors [growable-list]
     top-names [make-top-names]
     top-form-to-top-exp [bind gerrors top-names]
     top-forms [growable-list]]
    [for-each form forms
      [if-let [top [top-form-to-top-exp form]]
        [push top-forms top]
        [logq-abort no top form for [identity form]]]]
    [let [errors [clone-growable-to-frozen-list gerrors]]
      [when-not [is-empty errors]
        [logq there were errors]
        [for-each e errors
          [logq error [identity e]]]]
      [for-each top-form [clone-growable-to-frozen-list top-forms]
      [log top-form]]]]]

[defexpr bind-forms [.. forms]
  [bind-forms-fn forms]]

[def prog1 [qlist
[def mem [import env mem [memory i32 1]]]
[defn empty [] [tuple]]
[defn pointer [mem memory s i32] type
  [[constructor pointer] mem s]]
[def bump-top [cast [pointer mem i32] [i32 0]]]
[defn get-top [] i32
  [deref bump-top]]
[defn set-top [new-top i32] [tuple]
  [assign bump-top new-top]]
[defn alloc-init [] [tuple]
  [set-top [intrinsic i32.add [get-top] [i32 16]]]]

    ]]

[comment
  [bind-forms [def mem [import env mem [memory i32 1]]]]

  ]
