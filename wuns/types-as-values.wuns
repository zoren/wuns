[load wat.wuns]

[type name []
  [record
    [word word]]]

[type
  type []
  [union
    [primitive name]
    [tuple [list type]]
    [pointer name type]
    [memory mem-type]
    [func [list type] type]
    [error]
    ]

  mem-type []
  [record [type type] [name name]]

  exp []
  [union
    [i32 i32]
    [f64 f64]
    [call exp [list exp]]

    [var name]
    [if exp exp exp]
    [cast type exp]
    [tuple [list exp]]
    [deref exp]
    [deref-to type exp]
    [assign exp exp]
    [intrinsic name [list exp]]
    [let [list [pair name exp]] [list exp]]
    [do [list exp]]

    [size-of type]
    [import name name import-kind]
    ]

  import-kind []
  [union
    [memory type i32 [option i32]]
    [function [list type] type]]]

[comment
    [loop [list [pair name exp]] [list exp]]
    [continue [list [pair name exp]]]
    [field exp name]
    [index exp exp]
]

[type exp-function []
  [record
    [name name]
    [params [list [pair name type]]]
    [return-type type]
    [bodies [list exp]]]]

[type top-exp []
  [union
    [constant name exp]
    [function exp-function]]]

[type defunc-desc []
  [record
    [params [list [pair name type]]]
    [return-type type]]]

[type top-desc []
  [union
    [constant type exp]
    [function defunc-desc]]]

[type local-context-kind []
  [union [func] [let] [loop] [def]]]

[type local-context []
  [record
    [outer [option local-context]]
    [names [transient-kv-map word type]]
    [kind local-context-kind]]]

[type top-context []
  [record
    [errors [list [pair form [list form]]]]
    [top-names [transient-kv-map word top-desc]]]]

[defn error-fn [errors exp message-form]
  [push errors [pair exp message-form]]]

[defmacro error [form .. message]
  [flist [quote error-fn] [quote errors] form [quote-list message]]]

[defn local-context-make [outer vars kind]
  [local-context [option/some outer] vars kind]]

[defn local-context-make-top [vars kind]
  [local-context [option/none] vars kind]]

[defn try-get-local [lctx name]
  [loop [cur lctx]
    [if-let [v [try-get [local-context/names cur] name]]
      [option/some [pair v [local-context/kind cur]]]
      [if-let [o [local-context/outer cur]]
        [continue cur o]
        [option/none]]]]]

[defn try-get-pointer-args [t]
  [match t
    [type/pointer m p]
    [option/some [pair m p]]

    [option/none]]]

[defn make-top-names []
  [let [top-names [transient-kv-map]]
    top-names]]

[def type-i32 [type/primitive [name [word i32]]]]
[def type-f64 [type/primitive [name [word f64]]]]
[def type-empty-tuple [type/tuple [list]]]

[defn try-get-primitive [t]
  [match t
    [type/primitive w]
    [option/some [name/word w]]
    [option/none]]]

[defn option-pair [opt1 opt2]
  [match opt1
    [option/some v1]
    [match opt2
      [option/some v2]
      [option/some [pair v1 v2]]
      [option/none]]
    [option/none]]]

[load interpreter-externs.wuns]

[type desc []
  [union
    [local [pair type local-context-kind]]
    [top top-desc]]]

[defn desc-to-type [desc]
  [match desc
    [desc/top td]
    [match td
      [top-desc/constant desc-type desc-exp]
      desc-type

      [top-desc/function fd]
      [type/func
        [list-map p [defunc-desc/params fd] [pair/snd p]]
        [defunc-desc/return-type fd]]]

    [desc/local ld]
    [pair/fst ld]]]

[defn bind [evaluator errors top-names]
  [let
    [name-to-desc [transient-kv-map]]
    [letfn [
[func get-word [f]
  [if-let [w [try-get-word f]]
    w
    [do
      [error f expected word]
      [word --not-a-word--]]]]
[func get-list [f]
  [if-let [w [try-get-list f]]
    w
    [do
      [error f expected list]
      [list]]]]
[func form-to-name [f]
  [if-let [w [try-get-word f]]
    [name w]
    [logq-abort expected word [identity f]]]]

[func try-lookup-bind-name [lctx name]
  [let
    [name-word [name/word name]
     opt-desc
     [if-let [ldesc [try-get-local lctx name-word]]
      [option/some [desc/local ldesc]]
      [if-let [top-desc [try-get top-names name-word]]
        [option/some [desc/top top-desc]]
        [option/none]]]]
    [if-let [desc opt-desc]
      [do
        [set-kv-map name-to-desc name desc]
        [option/some desc]]
      [option/none]]]]

[func form-to-type [lctx form]
  [match form
    [form/word w]
    [type/primitive [form-to-name form]]

    [form/list l]
  [do
    [when [is-empty l] [log-location form]]

    [assert-not [is-empty l] form-to-type expected non-empty list]
    [switch [form-to-word [first l]]
      [[word i8]  [word u8]
       [word i16] [word u16]
       [word i32] [word u32]
       [word f32]
       [word f64]
       [word v128]]
      [type/primitive [form-to-name [first l]]]

      [[word tuple]]
      [type/tuple [list-map t [slice l 1 [size l]] [form-to-type lctx t]]]

      [[word pointer]]
      [let [mem-name [form-to-name [second l]]]
        [if-let [desc [try-lookup-bind-name lctx mem-name]]
          [match [desc-to-type desc]
            [type/memory -]
            [do]

            [logq-abort not a memory type]]
          [logq-abort memory not bound]]
        [type/pointer
          mem-name
          [form-to-type lctx [third l]]]]

      [logq-abort not implemented type [identity form]]]]]]

[func form-to-import-kind [lctx form]
  [let [l [get-list form]]
    [logq form-to-import-kind [identity l]]
    [assert-not [is-empty l] form-to-import-kind expected non-empty list]
    [switch [form-to-word [first l]]
      [[word memory]]
      [let [mt [form-to-type lctx [second l]]]
        [assert [or [eq [size l] 3] [eq [size l] 4]] import memory expected 3 or 4 elements]
        [logq mt [identity mt]]
        [import-kind/memory
          mt
          [word-to-int [form-to-word [third l]]]
          [if [eq [size l] 3]
            [option/none]
            [option/some [word-to-int [form-to-word [fourth l]]]]]]]

      [[word func]]
      [do
        [assert [eq [size l] 2] import func expected 2 elements]
        [import-kind/function
          [list-map param [get-list [second l]] [form-to-type lctx param]]
          [form-to-type lctx [third l]]]]

      [logq-abort not implemented import-kind [first l]]]]]

[func form-special-to-exp [lctx fw l]
  [switch fw
    [[word i32]]
    [exp/i32 [word-to-int [get-word [second l]]]]

    [[word if]]
    [exp/if
      [form-to-exp lctx [second l]]
      [form-to-exp lctx [third l]]
      [form-to-exp lctx [fourth l]]]

    [[word cast]]
    [exp/cast
      [form-to-type lctx [second l]]
      [form-to-exp lctx [third l]]]

    [[word import]]
    [exp/import
      [form-to-name [second l]]
      [form-to-name [third l]]
      [form-to-import-kind lctx [fourth l]]]

    [[word deref]]
    [exp/deref [form-to-exp lctx [second l]]]

    [[word deref-to]]
    [exp/deref-to
      [form-to-type lctx [second l]]
      [form-to-exp lctx [third l]]]

    [[word assign]]
    [exp/assign
      [form-to-exp lctx [second l]]
      [form-to-exp lctx [third l]]]

    [[word intrinsic]]
    [exp/intrinsic
      [form-to-name [second l]]
      [list-map arg [slice l 2 [size l]] [form-to-exp lctx arg]]]

    [[word let]]
    [let
      [vars [transient-kv-map]
       let-ctx [local-context-make lctx vars [local-context-kind/let]]]
      [exp/let
        [list-map p [pairwise-pairs [get-list [second l]]]
          [let [pname [form-to-name [pair/fst p]]
                pexp [form-to-exp let-ctx [pair/snd p]]]
            [set-kv-map vars [name/word pname] [type-of pexp]]
            [pair pname pexp]]]
        [list-map b [slice l 2 [size l]] [form-to-exp let-ctx b]]]]

    [[word do]]
    [exp/do [list-map b [rest l] [form-to-exp lctx b]]]

    [logq-abort form-special-to-exp not impl [identity fw]]]]

[func form-to-exp [lctx f]
  [match f
    [form/word w]
    [let [n [form-to-name f]]
      [try-lookup-bind-name lctx n]
      [exp/var n]]

    [form/list l]
    [let [ff [first l]
          args [rest l]]
      [if-let [fw [try-get-word ff]]
        [let [fn [form-to-name ff]]
          [if-let [desc [try-lookup-bind-name lctx fn]]
            [match desc
              [desc/top td]
              [match td
                [top-desc/function fd]
                [exp/call
                  [exp/var fn]
                  [list-map arg args [form-to-exp lctx arg]]]]
              [logq-abort not implemented local call]]
            [if-let [macro-func [try-get-macro evaluator fw]]
              [form-to-exp lctx [apply macro-func args]]
              [form-special-to-exp lctx fw l]]]]
        [exp/call [form-to-exp lctx ff] [list-map arg args [form-to-exp lctx arg]]]]]]]

[func name-to-type [n] [desc-to-type [get name-to-desc n]]]

[func type-equals [t1 t2]
  [match t1
    [type/primitive w1]
    [match t2
      [type/primitive w2]
      [eq-word [name/word w1] [name/word w2]]
      false]

    [type/tuple ts1]
    [match t2
      [type/tuple ts2]
      [and
        [eq [size ts1] [size ts2]]
        [loop [i 0 n [size ts1]]
          [if [lt-s i n]
            [if [type-equals [at ts1 i] [at ts2 i]]
              [continue i [inc i]]
              false]
            true]]]
      false]

    [type/pointer m1 t1]
    [match t2
      [type/pointer m2 t2]
      [and
        [type-equals [name-to-type m1] [name-to-type m2]]
        [type-equals t1 t2]]
      false]

    [type/memory m1]
    [match t2
      [type/memory m2]
      [and
        [type-equals [mem-type/type m1] [mem-type/type m2]]
        [eq-word [name/word [mem-type/name m1]] [name/word [mem-type/name m2]]]]
      false]

    [logq-abort type-equals [identity t1] [identity t2]]]]

[func type-of [exp]
  [match exp
    [exp/i32 i]
    type-i32

    [exp/f64 f]
    type-f64

    [exp/if c t e]
    [do
      [when-not [type-equals [type-of c] type-i32] [logq-abort eval exp condition not i32]]
      [let [tt [type-of t]]
        [when-not [type-equals tt [type-of e]] [logq-abort eval exp branches not same type]]
        tt]]

    [exp/call f args]
    [match f
      [exp/var fn]
      [match [name-to-type fn]
        [type/func - rt]
        rt

        [logq-abort not a function type]]

      [logq-abort not implemented type-of call]]

    [exp/import n m ik]
    [match ik
      [import-kind/memory et s os]
      [type/memory [mem-type et m]]

      [import-kind/function ps rt]
      [type/func ps rt]

      [logq-abort not implemented type-of import]]

    [exp/cast t e]
    [do
      [if-let [ptp [try-get-pointer-args t]]
        [let [mt [name-to-type [pair/fst ptp]]]
          [match mt
            [type/memory mk]
            [assert [type-equals [mem-type/type mk] [type-of e]]
              cast expected pointer to point to same type [identity mt] [type-of e]]

            [logq-abort not implemented type-of cast]]]
        [logq-abort not implemented type-of cast]]
      t]

    [exp/var n]
    [name-to-type n]

    [exp/intrinsic intrinsic-name args]
    [switch [name/word intrinsic-name]
      [[word i32.add] [word i32.sub] [word i32.mul] [word i32.eq]]
      [do
        [assert [eq [size args] 2] intrinsic expected 2 arguments]
        [assert [type-equals [type-of [at args 0]] type-i32] intrinsic expected i32 ]
        [assert [type-equals [type-of [at args 1]] type-i32] intrinsic expected i32]
        type-i32]

      [[word unreachable]]
      type-empty-tuple

      [logq-abort not implemented type-of intrinsic [name/word intrinsic-name]]]

    [exp/deref target]
    [let [target-type [type-of target]]
      [if-let [p [try-get-pointer-args target-type]]
        [pair/snd p]
        [type/error]]]

    [exp/deref-to target-type target-exp]
    [let [exp-type [type-of target-exp]]
      [if-let [p [try-get-pointer-args exp-type]]
        [let [pointer-target-type [pair/snd p]]
          [when-not [type-equals pointer-target-type target-type]
            [if-let [p [option-pair [try-get-primitive pointer-target-type] [try-get-primitive target-type]]]
              [let [et [pair/fst p]]
                [switch [pair/snd p]
                  [[word i32]]
                  [assert
                    [or [eq-word et [word u8]] [eq-word et [word i8]]]]
                  [[word i64]]
                  [assert
                    [or [eq-word et [word u8]] [eq-word et [word i8]]]]
                  [logq-abort only i32 and i64 targets supported for deref-to]]]
              [logq-abort expected primitive types]]]]
        [logq-abort not a pointer]]
      target-type]

    [exp/assign target source]
    [let [target-pointer-type [type-of target]
          source-type [type-of source]]
      [when-let [p [try-get-pointer-args target-pointer-type]]
        [when-not [type-equals [pair/snd p] source-type] [logq-abort eval exp expected type got]]]
      type-empty-tuple]

    [exp/let bindings bodies]
    [do
      [for-each binding bindings
        [type-of [pair/snd binding]]]
      [type-ofs bodies]]

    [exp/do bodies]
    [type-ofs bodies]

    [logq-abort not implemented type-of [identity exp]]]]

[func type-ofs [bodies]
  [if [is-empty bodies]
    type-empty-tuple
    [type-of [last bodies]]]]

[func bind-top [name-form desc]
  [let [n [get-word name-form]]
    [when [has top-names n]
      [error name-form name already defined]]
    [set-kv-map top-names n desc]]]

[func top-form-to-top-exp [form]
  [let [l [get-list form]]
    [if [is-empty l]
      [do
        [error form expected non-empty list]
        [option/none]]
      [let [f [first l]
            fw [get-word f]]
        [when [has top-names fw]
          [error f top-level calls not yet implemented]]
        [switch fw
          [[word def]]
          [do
            [when-not [eq [size l] 3] [error form expected def name exp-form]]
            [let
              [be
                [form-to-exp
                  [local-context-make-top [transient-kv-map] [local-context-kind/def]]
                  [third l]]
               type [type-of be]
               bt [top-exp/constant [form-to-name [second l]] be]]
              [bind-top [second l] [top-desc/constant type be]]
              [option/some bt]]]

          [[word defn]]
          [do
            [when [lt-s [size l] 3]
              [error form function expected name params return-type bodies]]
            [let
              [params-list [get-list [third l]]
               return-type-form [fourth l]
               param-ctx [transient-kv-map]
               lctx [local-context-make-top param-ctx [local-context-kind/func]]
               parameters
               [list-map p [pairwise-pairs params-list]
                 [let [pname [form-to-name [pair/fst p]]
                       ptype [form-to-type lctx [pair/snd p]]]
                  [set-kv-map param-ctx [name/word pname] ptype]
                  [pair pname ptype]]]
               return-type [form-to-type lctx return-type-form]]
              [bind-top [second l]
                [top-desc/function
                  [defunc-desc parameters return-type]]]
              [let
                [cbodies [list-map body [slice l 4 [size l]] [form-to-exp lctx body]]
                 inferred-return-type [type-ofs cbodies]]
                [when-not [type-equals return-type inferred-return-type]
                  [logq-abort return type mismatch [identity return-type] [identity inferred-return-type]]]
                [option/some
                  [top-exp/function
                    [exp-function
                      [form-to-name [second l]]
                      parameters
                      return-type
                      cbodies]]]]]]
          [logq-abort not implemented [identity fw]]]]]]]

[func type-to-wat-type [t]
  [match t
    [type/primitive n]
    [name/word n]

    [type/pointer mem-name -]
    [match [name-to-type mem-name]
      [type/memory mk]
      [type-to-wat-type [mem-type/type mk]]

      [logq-abort not a memory type]]

    [logq-abort type-to-wat-type [identity t]]]]

[func type-to-wat-types [type]
  [match type
    [type/tuple types]
    [list-map t types [type-to-wat-type t]]

    [list [type-to-wat-type type]]]]

[func form-to-inst [f]
  [match f
    [exp/import mod-name name ik] [logq-abort inline imports not implemented]
    [exp/cast t e] [form-to-inst e]
    [exp/i32 i] [wat-inst/i32.const [int-to-word i]]
    [exp/deref target]
    [let
      [pt [type-of target]
       ppt [if-let [p [try-get-pointer-args pt]] p [logq-abort not a pointer]]
       target-type [pair/snd ppt]]
      [wat-inst/load
        [wasm-name-to-wat-byte-array
          [switch [type-to-wat-type target-type]
            [[word i32]] [word i32.load]
            [[word i64]] [word i64.load]
            [[word f32]] [word f32.load]
            [[word f64]] [word f64.load]
            [[word v128]] [word v128.load]
            [logq-abort not implemented deref inst-type/apply]]]
        [wat-inst-memargs
          [name/word [pair/fst ppt]]
          [word 0]
          [word 1]]
        [form-to-inst target]]]

    [exp/assign target value]
    [let
      [pt [type-of target]
       ppt [if-let [p [try-get-pointer-args pt]] p [logq-abort not a pointer]]
       target-type [pair/snd ppt]]
      [wat-inst/store
        [wasm-name-to-wat-byte-array
          [switch [type-to-wat-type target-type]
          [[word i32]] [word i32.store]
          [[word i64]] [word i64.store]
          [[word f32]] [word f32.store]
          [[word f64]] [word f64.store]
          [[word v128]] [word v128.store]
          [[word u8] [word i8]] [word i32.store8]
          [[word u16] [word i16]] [word i32.store16]
          [logq-abort not implemented assign inst-type/apply]]]
        [wat-inst-memargs
          [name/word [pair/fst ppt]]
          [word 0]
          [word 1]]
        [form-to-inst target]
        [form-to-inst value]]]
    [exp/intrinsic n args] [wat-inst/inst-word [name/word n] [list-map arg args [form-to-inst arg]]]

    [exp/var n]
    [match [get name-to-desc n]
      [desc/top td]
      [match td
        [top-desc/constant t e]
        [wat-inst/global.get [name/word n]]

        [top-desc/function fd]
        [logq-abort function as value not implemented]]

      [desc/local ld]
      [wat-inst/local.get [name/word n]]]

    [exp/call fexp args]
    [match fexp
      [exp/var fn]
      [wat-inst/call [name/word fn] [list-map arg args [form-to-inst arg]]]
      [logq-abort not implemented call on non-var]]

    [exp/if c t e]
    [wat-inst/if
      [type-to-wat-types [type-of t]]
      [form-to-inst c] [form-to-inst t] [form-to-inst e]]

    [exp/do es]
    [forms-to-inst es]

    [exp/let bindings bodies]
    [wat-inst/instructions
      [concat
        [list-map b bindings
          [let [n [name/word [pair/fst b]]
                e [pair/snd b]]
            [wat-inst/local.set n [form-to-inst e]]]]
        [list [forms-to-inst bodies]]]]

    [logq-abort form-to-inst not implemented [identity f]]]]

[func forms-to-inst [forms]
  [wat-inst/instructions
    [if [is-empty forms]
      [list]
      [concat
        [list-map form [slice forms 0 [dec [size forms]]]
          [loop [res [form-to-inst form] i [size [type-to-wat-types [type-of form]]]]
              [if i
                [continue
                  res [wat-inst-word [word drop] res]
                  i [dec i]]
                res]]]
        [list [form-to-inst [last forms]]]]]]]

[func wuns-to-wat-func [f]
  [let
    [glocals [growable-list]
     add-locals
      [func add-locals [f]
        [match f
          [exp/import mod-name name ik] [do]
          [exp/cast t e] [add-locals e]
          [exp/i32 i] [do]
          [exp/deref p] [add-locals p]
          [exp/assign t s] [do [add-locals t] [add-locals s]]
          [exp/intrinsic n args] [for-each arg args [add-locals arg]]
          [exp/var n] [do]
          [exp/call fexp args]
          [do
            [add-locals fexp]
            [for-each arg args [add-locals arg]]]

          [exp/if c t e]
          [do
            [add-locals c] [add-locals t] [add-locals e]]

          [exp/do es]
          [for-each e es [add-locals e]]

          [exp/let bindings bodies]
          [do
            [for-each binding bindings [add-locals [pair/snd binding]]]
            [for-each body bodies [add-locals body]]]

          [logq-abort add-locals not implemented [identity f]]]]]
    [for-each body [exp-function/bodies f]
      [add-locals body]]
    [wat-func
      [name/word [exp-function/name f]]
      [list-map p [exp-function/params f]
        [pair
          [name/word [pair/fst p]]
          [type-to-wat-type [pair/snd p]]]]
      [clone-growable-to-frozen-list glocals]
      [type-to-wat-types [exp-function/return-type f]]
      [forms-to-inst [exp-function/bodies f]]]]]

[func compile [tops]
  [let
    [imports [growable-list]
     memories [growable-list]
     globals [growable-list]
     funcs [growable-list]
     exports [growable-list]
     datas [growable-list]]
    [for-each top tops
      [match top
        [top-exp/constant n e]
        [match e
          [exp/import mod-name name ik]
          [push
            imports
            [pair
              [pair [name/word mod-name] [name/word name]]
              [match ik
                [import-kind/function ps rt]
                [wat-import-kind/func
                  [name/word name]
                  [list-map p ps [type-to-wat-type p]]
                  [type-to-wat-types rt]]

                [import-kind/memory mk s os]
                [wat-import-kind/memory
                  [match mk
                    [type/primitive w]
                    [switch [name/word w]
                      [[word i32]] [memory-kind/i32]
                      [[word i64]] [memory-kind/i64]
                      [logq-abort not implemented memory-kind [identity w]]]
                    [logq-abort not implemented memory-kind [identity mk]]]
                  s
                  os]]]]

          [push
            globals
            [wat-global
              [name/word n]
              [type-to-wat-type [type-of e]]
              [form-to-inst e]]]]

        [top-exp/function f]
        [push
          funcs
          [wuns-to-wat-func f]]]]

    [wat-output
      imports
      memories
      globals
      funcs
      exports
      datas]]]
]
    [pair
      top-form-to-top-exp
      compile]]]]

[defexpr qlist [.. fs] fs]

[defn make-init-evaluator-async []
  [let [evaluator [make-evaluator]]
    [promise-then
      [evaluate-top-async evaluator [quote [load llmacro.wuns]]]
      [func t [-] evaluator]]]]

[defn bind-forms-fn [forms]
  [promise-then
    [make-init-evaluator-async]
    [func then [evaluator]
      [let
        [gerrors [growable-list]
         top-names [make-top-names]
         binder-compiler [bind evaluator gerrors top-names]
         top-form-to-top-exp [pair/fst binder-compiler]
         compile-tops [pair/snd binder-compiler]
         top-forms [growable-list]]
        [for-each form forms
          [if-let [top [top-form-to-top-exp form]]
            [push top-forms top]
            [logq-abort no top form for [identity form]]]]
        [let [errors [clone-growable-to-frozen-list gerrors]
              tops [clone-growable-to-frozen-list top-forms]]
          [when-not [is-empty errors]
            [logq there were errors]
            [for-each e errors
              [logq error [identity e]]]]
          [for-each top-form tops
            [log top-form]]
          [byte-array-log-as-string [wat-to-wat-bytes [output-to-wat [compile-tops tops]]]]]]]]]

[defexpr bind-forms [.. forms]
  [bind-forms-fn forms]]

[def prog1 [qlist
[def mem [import env mem [memory i32 1]]]
[defn empty [] [tuple]]
[def bump-top [cast [pointer mem i32] [i32 0]]]
[defn get-top [] i32
  [deref bump-top]]
[defn set-top [new-top i32] [tuple]
  [assign bump-top new-top]]
[def 0 [i32 0]]
[def 1 [i32 1]]
[defn alloc-init [] [tuple]
  [set-top [add [get-top] [i32 16]]]]

[defn alloc-n [n-bytes i32] i32
  [let [top-val [get-top]]
    [when [eq top-val 0] [intrinsic unreachable]]
    [set-top [add top-val n-bytes]]
    top-val]]

[defn inc [x i32] i32 [add x 1]]
[defn dec [x i32] i32 [sub x 1]]

    ]]

[comment
  [bind-forms [def mem [import env mem [memory i32 1]]]]

  ]
