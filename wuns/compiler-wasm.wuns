[import standard-library.wuns
  constant-ids
  inc dec ifs or is-odd mutable-list push when size at comment -2 -1 0 1 2 3 4 do
  concat concat-lists
  is-word concat-words

   eq-word assoc-list-get assoc-list-index assoc-list-set slice push-all not is-negative freeze assert
  when-not and log abort
  first
  second
  third
  fourth
  rest
  last
  is-even
  is-zero
  is-list
  eq-form
  set-array
]

[func u32-word-to-leb-128 [w]
  [assert [not [is-negative w]] expected 32 bit ints]
  [let [res [mutable-list]]
    [loop [n w]
      [let
        [byte [bitwise-and n [quote 127]]
         nn [bitwise-shift-right n [quote 7]]]
        [if [is-zero nn]
          [push res byte]
          [do
            [push res [bitwise-ior byte [quote 128]]]
            [continue n nn]]]]]
    [freeze res]]]

[func s32-word-to-leb-128 [value]
  [let [res [mutable-list]]
    [loop [value1 value]
      [let
        [byte [bitwise-and value1 [quote 127]]
         value2 [bitwise-shift-right value1 [quote 7]]
         sign-bit [bitwise-and byte [quote 64]]]
        [comment todo it seems we should swap the order here as we already have the sign bit]
        [if [or [and [is-zero value2] [not sign-bit]]
                [and [eq value2 -1]   sign-bit]]
          [push res byte]
          [do
            [push res [bitwise-ior byte [quote 128]]]
            [continue value1 value2]]]]]
    [freeze res]]]

[func reverse [l]
  [let [res [mutable-list]]
    [loop [i [dec [size l]]]
      [when-not [is-negative i]
        [push res [at l i]]
        [continue i [dec i]]]]
    [freeze res]]]

[func dec-word-to-hex-word [dw]
  [assert [not [is-negative dw]] expected non-negative decimal word]
  [if [is-zero dw]
    [quote 0x0]
    [let [hex-digits [quote 0 1 2 3 4 5 6 7 8 9 a b c d e f]
          res [mutable-list]]
      [loop [n dw]
        [if [is-zero n]
          [do
            [push res [quote x]]
            [push res 0]
            [concat-words [reverse res]]]
          [let [remainder [bitwise-and n [quote 15]]
                quotient [bitwise-shift-right n [quote 4]]]
            [push res [at hex-digits remainder]]
            [continue n quotient]]]]]]]

[func dec-words-to-hex [decs]
  [let [res [mutable-list] s [size decs]]
    [loop [i 0]
      [if [lt i s]
        [do
          [push res [dec-word-to-hex-word [at decs i]]]
          [continue i [inc i]]]
        [freeze res]]]]]

[func test [expected actual]
  [when-not [eq-form expected actual]
    [log [list [quote expected] expected [quote [but got]] actual]]]]

[comment wikipedia says 0xe5 0x8e 0x26]

[test [quote [0xe5 0x8e 0x26]] [dec-words-to-hex [u32-word-to-leb-128 [quote 624485]]]]

[comment wikipedia says 0xc0 0xbb 0x78]

[test [quote [0xc0 0xbb 0x78]] [dec-words-to-hex [s32-word-to-leb-128 [quote -123456]]]]

[constant i32.const [quote 0x41]]
[constant local.get [quote 0x20]]
[constant local.set [quote 0x21]]

[constant empty-type [quote 0x40]]
[constant i32 [quote 0x7f]]

[func make-operation-obj [name opcode parameters results]
  [concat
    [quote [name]] [list name]
    [quote [opcode]] [list opcode]
    [quote [parameters]] [list parameters]
    [quote [results]] [list results]]]

[macro make-binary-i32 [name opcode]
  [list [quote quote] [make-operation-obj name opcode [list i32 i32] [list i32]]]]

[constant instructions
  [list
    [make-binary-i32 eq  0x46]
    [make-binary-i32 ne  0x47]
    [make-binary-i32 lt  0x48]
    [make-binary-i32 gt  0x4a]
    [make-binary-i32 le  0x4c]
    [make-binary-i32 ge  0x4e]

    [make-binary-i32 add 0x6a]
    [make-binary-i32 sub 0x6b]
    [make-binary-i32 mul 0x6c]
    [make-binary-i32 div 0x6d]

    [make-binary-i32 bitwise-and 0x71]
    [make-binary-i32 bitwise-ior 0x72]
    [make-binary-i32 bitwise-xor 0x73]

    ]]

[func get-instruction [name]
  [loop [i 0]
    [if [lt i [size instructions]]
      [let [o [at instructions i]]
        [if [eq-word [assoc-list-get o [quote name]] name]
          o
          [continue i [inc i]]]]
      0]]]

[func type-function [params results]
  [concat
    [quote [0x60]]
    [u32-word-to-leb-128 [size params]]
    params
    [u32-word-to-leb-128 [size results]]
    results]]

[constant if [quote 0x04]]
[constant else [quote 0x05]]
[constant call [quote 0x10]]
[constant end [quote 0x0b]]

[func index-of-word [words word]
  [let [s-words [size words]]
    [loop [i 0]
      [if [lt i s-words]
        [if [eq-word word [at words i]]
          i
          [continue i [inc i]]]
        -1]]]]

[func push-type [ctx type]
  [let [types [assoc-list-get ctx [quote types]]
        index [index-of-word types type]]
    [if [is-negative index]
      [let [new-index [size types]]
        [push types type]
        new-index]
      index]]]

[constant kind-function 0]

[func word-to-codepoints [w]
  [let [ml [mutable-list]]
    [loop [i 0]
      [when [lt i [size w]]
        [push ml [at w i]]
        [continue i [inc i]]]]
    [freeze ml]]]

[func wasm-export [name kind index]
  [concat
    [u32-word-to-leb-128 [size name]]
    [word-to-codepoints name]
    [list kind]
    [u32-word-to-leb-128 index]]]

[func decimal-word-to-i32 [dw]
  [if [eq-word [first dw] [quote 45]]
    [let [s [sub 0 [size dw]]]
      [loop [i [dec [size dw]] res 0 multi -1]
        [if [gt i 0]
          [let [c [at dw i]]
            [assert [and [le [quote 48] c] [le c [quote 57]]] not a decimal character neg]
            [assert [gt res [quote -214748364]] out of bounds]
            [continue
              i [dec i]
              res [add res [mul [sub c [quote 48]] multi]]
              multi [mul multi [quote 10]]]]
          res]]]
    [let [s [sub 0 [size dw]]]
      [loop [i -1 res 0 multi 1]
        [if [le s i]
          [let [c [at dw i]]
            [assert [and [le [quote 48] c] [le c [quote 57]]] not a decimal character pos]
            [assert [lt res [quote 214748364]] out of bounds]
            [continue
              i [dec i]
              res [add res [mul [sub c [quote 48]] multi]]
              multi [mul multi [quote 10]]]]
          res]]]]]

[func type-list-to-code [ctx type-list]
  [ifs
    [eq-form type-list []]
    empty-type

    [eq-form type-list [list i32]]
    i32

    [let
      [i [push-type ctx [type-function [] type-list]]]
      [assert [lt i [quote 32]] not sure how to handle higher indexes]
      i]]]

[func make-mty-ctx []
  [list
    [quote types] [mutable-list]
    [quote functions] [mutable-list]
    [quote exports] [mutable-list]
    [quote codes] [mutable-list]
    [quote function-signatures] [mutable-list]]]

[constant global-ctx [make-mty-ctx]]

[func push-code-byte [code-locals byte] [push [first code-locals] byte]]

[func push-code-u32 [code-locals value] [push-all [first code-locals] [u32-word-to-leb-128 value]]]
[func push-code-s32 [code-locals value] [push-all [first code-locals] [s32-word-to-leb-128 value]]]

[func push-local [code-locals type]
  [let [locals [second code-locals]
        arity [third code-locals]
        index [add arity [div [size locals] 2]]]
    [push locals 1]
    [push locals type]
    index]]

[func compile-form-mutable [local-ctx code form]
  [ifs
    [is-word form]
    [let [vars-index
      [loop [cur-ctx local-ctx]
        [if [eq [size cur-ctx] 1]
          [let [param-ctx [first cur-ctx]
                index [assoc-list-index param-ctx form]]
            [assert [not [is-negative index]] not found in local ctx]
            [list [at param-ctx [inc index]] [div index 2]]]
          [let
            [- [assert [eq [size cur-ctx] 2] we need a local ctx and a outer ctx if not at root]
             vars [first cur-ctx]
             index [assoc-list-index vars form]]
            [if [is-negative index]
              [continue cur-ctx [second cur-ctx]]
              [at vars [inc index]]]]]]]
      [push-code-byte code local.get]
      [push-code-u32 code [second vars-index]]
      [list [first vars-index]]]

    [eq-form form []]
    []

    [let [first-form [first form]
          args [rest form]]
      [assert [is-word first-form] expected a word first]
      [ifs
        [eq-word first-form [quote tuple]]
        [let
          [res-types [mutable-list]]
          [loop [i 0]
            [when [lt i [size args]]
              [comment do we actually want to concat them [i32 i32] [i32] we be surprising]
              [push-all res-types [compile-form-mutable local-ctx code [at args i]]]
              [continue i [inc i]]]]
          [freeze res-types]]

        [eq-word first-form [quote i32]]
        [let
          [- [assert [eq [size args] 1] only support decimal integers]
           dw [decimal-word-to-i32 [first args]]]
          [push-code-byte code i32.const]
          [push-code-s32 code dw]
          [list i32]]

        [eq-word first-form [quote if]]
        [let
          [- [assert [eq [size args] 3] if needs a condition and two branches]
           ct [compile-form-mutable local-ctx code [first args]]
           - [push-code-byte code if]
           type-index [size [first code]]
           dummy-type empty-type
           - [push-code-byte code dummy-type]
           - [assert [and [eq [size ct] 1] [eq [at ct 0] i32]] condition not i32]
           tt [compile-form-mutable local-ctx code [second args]]
           - [push-code-byte code else]
           ft [compile-form-mutable local-ctx code [third args]]
           - [assert [eq-form tt ft] if branch types differ]
           enc-branch-type [type-list-to-code global-ctx ft]]
          [push-code-byte code end]
          [when-not [eq dummy-type enc-branch-type]
            [set-array [first code] type-index enc-branch-type]]
          tt]

        [eq-word first-form [quote let]]
        [let
          [bindings [first args]
           var-values [mutable-list]
           let-ctx [list var-values local-ctx]
           n-of-bindings [size bindings]]
          [assert [is-list bindings] let expects a list of bindings]
          [assert [is-even n-of-bindings] let expects an even number of bindings]
          [loop [i 0]
            [when [lt i n-of-bindings]
              [let
                [var [at bindings i]
                 value [at bindings [inc i]]
                 var-type [compile-form-mutable let-ctx code value]
                 - [assert [eq [size var-type] 1] let expects a single type]
                 t [first var-type]
                 local-index [push-local code t]]
                [push-code-byte code local.set]
                [push-code-u32 code local-index]
                [push var-values var]
                [push var-values [list t local-index]]
                [continue i [add i 2]]]]]
          [loop [i 2]
            [when [lt i [dec [size form]]]
              [compile-form-mutable let-ctx code [at form i]]
              [continue i [inc i]]]]
          [compile-form-mutable let-ctx code [last form]]]

        [eq-word first-form [quote loop]]
        [let []
          [log [quote loop not yet implemented]]
          [abort]]

        [let [instruction [get-instruction first-form]]
          [if instruction
            [do
              [assert [eq [size [assoc-list-get instruction [quote parameters]]] [size args]]
                instruction arity mismatch]
              [loop [i 0]
                [when [lt i [size args]]
                  [comment todo also check types]
                  [compile-form-mutable local-ctx code [at args i]]
                  [continue i [inc i]]]]
              [push-code-byte code [assoc-list-get instruction [quote opcode]]]
              [assoc-list-get instruction [quote results]]]
            [let [func-sigs [assoc-list-get global-ctx [quote function-signatures]]
                  func-sig [assoc-list-get func-sigs first-form]
                  parameter-types [first func-sig]]
              [assert [eq [size parameter-types] [size args]] parameter arity mismatch]
              [loop [i 0]
                [when [lt i [size args]]
                  [comment todo also check types]
                  [compile-form-mutable local-ctx code [at args i]]
                  [continue i [inc i]]]]
              [push-code-byte code call]
              [push-code-byte code [u32-word-to-leb-128 [third func-sig]]]
              [second func-sig]

            ]]]]]]]

[func locals-to-bytes [locals]
  [let [bytes [mutable-list]
        number-of-locals [size locals]]
    [push-all bytes [u32-word-to-leb-128 [div number-of-locals 2]]]
    [loop [i 0]
      [when [lt i number-of-locals]
        [push-all bytes [u32-word-to-leb-128 [at locals i]]]
        [push bytes [at locals [inc i]]]
        [continue i [add i 2]]]]
    bytes]]

[func code-to-bytes [locals instructions]
  [let
    [bytes
      [concat
        [locals-to-bytes locals]
        instructions]]
    [concat [u32-word-to-leb-128 [size bytes]] bytes]]]

[func compile-top-level-form [form]
  [if [eq-word [quote func] [first form]]
    [let [name [second form]
          params [third form]
          param-ctx [mutable-list]
          parameter-type-list [mutable-list]
          -
          [loop [i 0]
            [when [lt i [size params]]
              [comment check for duplicate parameters make type configurable]
              [push param-ctx [at params i]]
              [push param-ctx i32]
              [push parameter-type-list i32]
              [continue i [inc i]]]]
          func-ctx [list param-ctx]
          parameter-type-list [freeze parameter-type-list]
          locals [mutable-list]
          code [mutable-list]
          code-locals [list code locals [size params]]
          func-sigs [assoc-list-get global-ctx [quote function-signatures]]
          -
          [loop [i 3]
            [when [lt i [dec [size form]]]
              [comment remember to check type is empty maybe even drop unused and warn instead]
              [compile-form-mutable func-ctx code-locals [at form i]]]]
          result-type [compile-form-mutable func-ctx code-locals [last form]]
          type-index
          [push-type global-ctx
            [type-function parameter-type-list result-type]]
          functions [assoc-list-get global-ctx [quote functions]]
          func-index [size functions]]
      [push func-sigs name]
      [push func-sigs [list parameter-type-list result-type func-index]]

      [push functions type-index]
      [push [assoc-list-get global-ctx [quote exports]]
        [wasm-export name kind-function func-index]]
      [push code end]
      [push [assoc-list-get global-ctx [quote codes]] [code-to-bytes locals code]]
      ]

    [do
      [log [list form ]]
      [assert 0 not a top-level form]]]]

[func vector-section [section-id content]
  [concat [list section-id] [u32-word-to-leb-128 [size content]] content]]

[func vector-section-concat [section-id elements]
  [vector-section section-id [concat [u32-word-to-leb-128 [size elements]] [concat-lists elements]]]]

[func func-section [func-indexes]
  [vector-section 3 [concat [u32-word-to-leb-128 [size func-indexes]] func-indexes]]]

[func ctx-to-module [ctx]
  [concat
    [quote [0 97 115 109
            1 0 0 0]]
    [vector-section-concat [quote 1] [assoc-list-get ctx [quote types]]]
    [func-section [assoc-list-get ctx [quote functions]]]
    [vector-section-concat [quote 7] [assoc-list-get ctx [quote exports]]]
    [vector-section-concat [quote 10] [assoc-list-get ctx [quote codes]]]]]

[func compile-top-forms-to-context [forms]
  [do
    [loop [i 0]
      [when [lt i [size forms]]
        [compile-top-level-form [at forms i]]
        [continue i [inc i]]]]
    global-ctx]]

[export ctx-to-module compile-top-forms-to-context]

[comment
[external-func wasm-module [list] [module]]
[external-func wasm-instance [module] [instance]]
[external-func wasm-import-func [instance word] []]

[let
  [ctx [compile-top-forms [quote
    [func fst [x y] x]
    [func snd [x y] y]
    [func add [x y] [i32.add x y]]
    [func sub [x y] [i32.sub x y]]
    [func inc [x] [i32.add x [quote 1]]]
    [func five [] [quote 5]]
    [func ifte [c] [if c [quote 1337] [quote 21]]]
    [func ignore [x] []]
    [func identity [x] x]
    [func id-pair [x] [tuple x x]]
    [func pair [x y] [tuple x y]]
  ]]
  mod [ctx-to-module ctx]
  - [log mod]
  wm [wasm-module mod]
  wi [wasm-instance wm]
  ]
  [wasm-import-func wi fst my-fst]
  [wasm-import-func wi snd my-snd]
  [wasm-import-func wi add my-add]
  [wasm-import-func wi sub my-sub]
  [wasm-import-func wi inc my-inc]
  [wasm-import-func wi ifte my-ifte]
  [wasm-import-func wi ignore my-ignore]
  [wasm-import-func wi identity my-identity]
  [wasm-import-func wi id-pair my-id-pair]
  [wasm-import-func wi pair my-pair]
  ]

[test 3 [my-fst 3 2]]
[test 2 [my-snd 1 2]]
[test 3 [my-add 1 2]]
[test -1 [my-sub 1 2]]
[test 2 [my-inc 1]]
[test [quote 1337] [my-ifte 1]]
[test [quote 21] [my-ifte 0]]
[test [] [my-ignore 0]]
[test 0 [my-identity 0]]
[test 2 [my-identity 2]]
[test [list 2 2] [my-id-pair 2]]
[test [list 2 3] [my-pair 2 3]]
[test [list 2 3] [my-pair 2 3]]

[func compile-instantiate [funcs]
  [let
    [ctx [compile-top-level-forms funcs]
     mod [ctx-to-module ctx]
     wm [wasm-module mod]]
    [wasm-instance wm]]]

[wasm-import-func [compile-instantiate [quote [[func f [x] [] [quote 5]]]]] f my-f]

[wasm-import-func [compile-instantiate
  [quote
    [func callee [] [quote 5]]
    [func caller [] [callee]]]] caller my-caller]

[test [quote 5] [my-caller]]

[let [wi
  [compile-instantiate
    [quote
      [func let-test [] [let [] [quote 5]]]
      [func let1-test [] [let [] []]]
      [func let2-test [] [let [] [tuple [quote 5] [quote 6]]]]


      ]]]
  [wasm-import-func wi let-test my-let-test]
  [wasm-import-func wi let1-test my-let1-test]
  [wasm-import-func wi let2-test my-let2-test]
  ]

[test [quote 5] [my-let-test]]
[test [] [my-let1-test]]

[test [list [quote 5] [quote 6]] [my-let2-test]]
]