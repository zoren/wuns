[import standard-library.wuns
  constant-ids
  inc dec ifs or is-odd mutable-list push when size at comment -2 -1 0 1 2 3 4 do
  concat concat-lists
  is-word concat-words

  eq-word assoc-list-get assoc-list-index assoc-list-set slice push-all not is-negative freeze assert
  when-not and log abort
  first
  second
  third
  fourth
  rest
  last
  is-even
  is-zero
  is-list
  eq-form
  set-array for for-inc
]

[func u32-word-to-leb-128 [w]
  [assert [not [is-negative w]] expected 32 bit ints]
  [let [res [mutable-list]]
    [loop [n w]
      [let
        [byte [bitwise-and n [quote 127]]
         nn [bitwise-shift-right n [quote 7]]]
        [if [is-zero nn]
          [push res byte]
          [do
            [push res [bitwise-ior byte [quote 128]]]
            [continue n nn]]]]]
    [freeze res]]]

[func s32-word-to-leb-128 [value]
  [let [res [mutable-list]]
    [loop [value1 value]
      [let
        [byte [bitwise-and value1 [quote 127]]
         value2 [bitwise-shift-right value1 [quote 7]]
         sign-bit [bitwise-and byte [quote 64]]]
        [comment todo it seems we should swap the order here as we already have the sign bit]
        [if [or [and [is-zero value2] [not sign-bit]]
                [and [eq value2 -1]   sign-bit]]
          [push res byte]
          [do
            [push res [bitwise-ior byte [quote 128]]]
            [continue value1 value2]]]]]
    [freeze res]]]

[func reverse [l]
  [let [res [mutable-list]]
    [loop [i [dec [size l]]]
      [when-not [is-negative i]
        [push res [at l i]]
        [continue i [dec i]]]]
    [freeze res]]]

[func dec-word-to-hex-word [dw]
  [assert [not [is-negative dw]] expected non-negative decimal word]
  [if [is-zero dw]
    [quote 0x0]
    [let [hex-digits [quote 0 1 2 3 4 5 6 7 8 9 a b c d e f]
          res [mutable-list]]
      [loop [n dw]
        [if [is-zero n]
          [do
            [push res [quote x]]
            [push res 0]
            [concat-words [reverse res]]]
          [let [remainder [bitwise-and n [quote 15]]
                quotient [bitwise-shift-right n [quote 4]]]
            [push res [at hex-digits remainder]]
            [continue n quotient]]]]]]]

[func dec-words-to-hex [decs]
  [let [res [mutable-list]]
    [for i 0 [size decs]
      [push res [dec-word-to-hex-word [at decs i]]]]
    [freeze res]]]

[func test [expected actual]
  [when-not [eq-form expected actual]
    [log [list [quote expected] expected [quote [but got]] actual]]]]

[comment wikipedia says 0xe5 0x8e 0x26]

[test [quote [0xe5 0x8e 0x26]] [dec-words-to-hex [u32-word-to-leb-128 [quote 624485]]]]

[comment wikipedia says 0xc0 0xbb 0x78]

[test [quote [0xc0 0xbb 0x78]] [dec-words-to-hex [s32-word-to-leb-128 [quote -123456]]]]

[constant i32.const [quote 0x41]]
[constant local.get [quote 0x20]]
[constant local.set [quote 0x21]]

[constant empty-type [quote 0x40]]
[constant i32 [quote 0x7f]]
[constant immediate-u32 [quote immediate-u32]]
[constant continue-type [quote continue-type]]

[import wasm-instructions.wuns get-instruction]

[func type-function [params results]
  [concat
    [quote [0x60]]
    [u32-word-to-leb-128 [size params]]
    params
    [u32-word-to-leb-128 [size results]]
    results]]

[constant loop [quote 0x03]]
[constant if [quote 0x04]]
[constant else [quote 0x05]]
[constant call [quote 0x10]]
[constant end [quote 0x0b]]
[constant br [quote 0x0c]]

[func index-of-word [words word]
  [let [s-words [size words]]
    [loop [i 0]
      [if [lt i s-words]
        [if [eq-word word [at words i]]
          i
          [continue i [inc i]]]
        -1]]]]

[constant kind-function 0]

[func word-to-codepoints [w]
  [let [ml [mutable-list]]
    [for i 0 [size w]
      [push ml [at w i]]]
    [freeze ml]]]

[func word-to-length-bytes [name]
  [concat
    [u32-word-to-leb-128 [size name]]
    [word-to-codepoints name]]]

[func wasm-export [name kind index]
  [concat
    [word-to-length-bytes name]
    [list kind]
    [u32-word-to-leb-128 index]]]

[func wasm-import [module-name name import-desc]
  [concat
    [word-to-length-bytes module-name]
    [word-to-length-bytes name]
    import-desc]]

[constant kind-memory 0x02]

[func import-desc-mem-min [min]
  [concat
    [list kind-memory 0]
    [u32-word-to-leb-128 min]]]

[func import-desc-mem-min-max [min max]
  [concat
    [list kind-memory 1]
    [u32-word-to-leb-128 min]
    [u32-word-to-leb-128 max]]]

[func import-desc-func [index]
  [concat [list 0] [u32-word-to-leb-128 index]]]

[func active-data-word [offset w]
  [concat [list 0 i32.const] [s32-word-to-leb-128 offset] [list end] [word-to-length-bytes w]]]

[func passive-data-word [w]
  [concat [list 1] [word-to-length-bytes w]]]

[func passive-data-bytes [bytes]
  [for i 0 [size bytes]
    [let [b [at bytes i]]
      [assert [not [is-negative b]] passive-data-bytes negative byte]
      [assert [le b [i32 255]] passive-data-bytes byte greater than 255]]]
  [concat [list 1] [u32-word-to-leb-128 [size bytes]] bytes]]

[func decimal-word-to-i32 [dw]
  [if [eq-word [first dw] [quote 45]]
    [let [s [sub 0 [size dw]]]
      [loop [i [dec [size dw]] res 0 multi -1]
        [if [gt i 0]
          [let [c [at dw i]]
            [assert [and [le [quote 48] c] [le c [quote 57]]] not a decimal character neg]
            [assert [gt res [quote -214748364]] out of bounds]
            [continue
              i [dec i]
              res [add res [mul [sub c [quote 48]] multi]]
              multi [mul multi [quote 10]]]]
          res]]]
    [let [s [sub 0 [size dw]]]
      [loop [i -1 res 0 multi 1]
        [if [le s i]
          [let [c [at dw i]]
            [assert [and [le [quote 48] c] [le c [quote 57]]] not a decimal character pos]
            [assert [lt res [quote 214748364]] out of bounds]
            [continue
              i [dec i]
              res [add res [mul [sub c [quote 48]] multi]]
              multi [mul multi [quote 10]]]]
          res]]]]]

[constant global-ctx-types [mutable-list]]
[constant global-ctx-imports [mutable-list]]
[constant global-ctx-functions [mutable-list]]
[constant global-ctx-exports [mutable-list]]
[constant global-ctx-codes [mutable-list]]
[constant global-ctx-func-sigs [mutable-list]]
[constant global-ctx-datas [mutable-list]]

[func push-type [type]
  [let [index [index-of-word global-ctx-types type]]
    [if [is-negative index]
      [let [new-index [size global-ctx-types]]
        [push global-ctx-types type]
        new-index]
      index]]]

[func type-list-to-code [type-list]
  [ifs
    [eq-form type-list []]
    empty-type

    [eq-form type-list [list i32]]
    i32

    [let
      [i [push-type [type-function [] type-list]]]
      [assert [lt i [quote 32]] not sure how to handle higher indexes]
      i]]]

[func push-code-byte [code-locals byte] [push [first code-locals] byte]]

[func push-code-u32 [code-locals value] [push-all [first code-locals] [u32-word-to-leb-128 value]]]
[func push-code-s32 [code-locals value] [push-all [first code-locals] [s32-word-to-leb-128 value]]]

[func push-local [code-locals type]
  [let [locals [second code-locals]
        arity [third code-locals]
        index [add arity [div [size locals] 2]]]
    [push locals 1]
    [push locals type]
    index]]

[func identity [x] x]

[func quote-args [list]
  [let [ml [mutable-list]]
    [push ml [first list]]
    [for i 1 [size list]
      [push ml [list [quote quote] [at list i]]]]
    [freeze ml]]]

[external-func macro-expand [form] [form]]
[external-func eval [form] [form]]

[func compile-form-mutable [local-ctx code form]
  [ifs
    [is-word form]
    [let [vars-index
      [loop [cur-ctx local-ctx]
        [if [eq [size cur-ctx] 1]
          [let [param-ctx [first cur-ctx]
                index [assoc-list-index param-ctx form]]
            [assert [not [is-negative index]] not found in local ctx [identity form]]
            [list [at param-ctx [inc index]] [div index 2]]]
          [let
            [- [assert [eq [size cur-ctx] 3] we need a local ctx and a outer ctx if not at root]
             vars [first cur-ctx]
             index [assoc-list-index vars form]]
            [if [is-negative index]
              [continue cur-ctx [second cur-ctx]]
              [at vars [inc index]]]]]]]
      [push-code-byte code local.get]
      [push-code-u32 code [second vars-index]]
      [list [first vars-index]]]

    [eq-form form []]
    []

    [let [first-form [first form]
          args [rest form]
          s-form [size form]]
      [assert [is-word first-form] expected a word first]
      [ifs
        [eq-word first-form [quote tuple]]
        [let
          [res-types [mutable-list]]
          [for i 0 [size args]
            [comment do we actually want to concat them [i32 i32] [i32] we be surprising]
            [push-all res-types [compile-form-mutable local-ctx code [at args i]]]]
          [freeze res-types]]

        [eq-word first-form [quote i32]]
        [let
          [- [assert [eq [size args] 1] only support decimal integers]
           dw [decimal-word-to-i32 [first args]]]
          [push-code-byte code i32.const]
          [push-code-s32 code dw]
          [list i32]]

        [eq-word first-form [quote if]]
        [let
          [s-args [dec s-form]
           - [assert [or [eq s-args 2] [eq s-args 3]] if expects 2 or 3 arguments]
           ct [compile-form-mutable local-ctx code [first args]]
           - [push-code-byte code if]
           type-index [size [first code]]
           dummy-type empty-type
           - [push-code-byte code dummy-type]
           - [assert [and [eq [size ct] 1] [eq [at ct 0] i32]] condition not i32]
           tt [compile-form-mutable local-ctx code [second args]]
           enc-branch-type [type-list-to-code tt]]
          [if [eq-form tt [list continue-type]]
            [let []

            ]
            [let
              [if [eq s-args 3]
                [let [- [push-code-byte code else]
                      ft [compile-form-mutable local-ctx code [third args]]]
                  [assert [eq-form tt ft] if branch types differ [identity tt] [identity ft]]]
                [assert [eq s-args 2] if expects 2 or 3 arguments]]
              [push-code-byte code end]
              [when-not [eq dummy-type enc-branch-type]
                [set-array [first code] type-index enc-branch-type]]
              tt]]]

        [or
          [eq-word first-form [quote let]]
          [eq-word first-form [quote loop]]]
        [let
          [bindings [first args]
           var-values [mutable-list]
           let-loop-ctx [list var-values local-ctx first-form]
           n-of-bindings [size bindings]
           is-loop [eq-word first-form [quote loop]]]
          [assert [is-list bindings] expects a list of bindings]
          [assert [is-even n-of-bindings] expects an even number of bindings]
          [for-inc i 0 2 n-of-bindings
            [let
              [var [at bindings i]
               value [at bindings [inc i]]
               var-type [compile-form-mutable let-loop-ctx code value]]
              [ifs
                [eq-word [quote -] var]
                [assert [eq [size var-type] 0] let - expects unit type]

                [is-word var]
                [let
                  [- [assert [eq [size var-type] 1] let expects a single type]
                    t [first var-type]
                    local-index [push-local code t]]
                  [push-code-byte code local.set]
                  [push-code-u32 code local-index]
                  [push var-values var]
                  [push var-values [list t local-index]]]

                [let [s [size var]]
                  [assert [is-list var] expects a word or list]
                  [assert [eq [size var] [size var-type]] let expects matching type arity]
                  [for i 0 [size var]
                    [let
                      [t [at var-type i]
                       local-index [push-local code t]]
                      [push-code-byte code local.set]
                      [push-code-u32 code local-index]
                      [push var-values [at var [dec [sub s i]]]]
                      [push var-values [list t local-index]]]]]]]]
          [if is-loop
            [do
              [push-code-byte code loop]
              [let [type-index [size [first code]]]
                [push-code-byte code empty-type]
                [for i 2 [dec [size form]]
                  [compile-form-mutable let-loop-ctx code [at form i]]]
                [let [last-body-type [compile-form-mutable let-loop-ctx code [last args]]]
                  [set-array [first code] type-index [type-list-to-code last-body-type]]
                  [push-code-byte code end]
                  last-body-type]]]
            [do
              [for i 2 [dec [size form]]
                [compile-form-mutable let-loop-ctx code [at form i]]]
              [compile-form-mutable let-loop-ctx code [last form]]]]]

        [eq-word first-form [quote continue]]
        [let
          [loop-ctx
           [loop [cur-ctx local-ctx]
             [if [eq [size cur-ctx] 1]
               [do [log [quote continue not in a loop]]
                   [abort]]
               [do
                [assert [eq [size cur-ctx] 3] we need a local ctx and a outer ctx if not at root]
                [if [eq-word [third cur-ctx] [quote loop]]
                  [first cur-ctx]
                  [continue cur-ctx [second cur-ctx]]]]]]]
          [for-inc i 1 2 s-form
            [let
              [local [assoc-list-get loop-ctx [at form i]]
               arg-type [compile-form-mutable local-ctx code [at form [inc i]]]]
              [comment todo check types]
              [push-code-byte code local.set]
              [push-code-u32 code [second local]]]]
          [push-code-byte code br]
          [push-code-u32 code 1]
          [list continue-type]]

        [eq-word [quote data-passive-word] [first form]]
        [let [index [size global-ctx-datas]
              w [at form 1]]
          [push global-ctx-datas [passive-data-word w]]
          [push-code-byte code i32.const]
          [push-code-s32 code index]
          [list i32]]

        [eq-word [quote data-passive-bytes] [first form]]
        [let [index [size global-ctx-datas]
              byte-list [at form 1]]
          [push global-ctx-datas [passive-data-bytes byte-list]]
          [list]]

        [let [instruction [get-instruction first-form]]
          [if instruction
            [let [arity [assoc-list-get instruction [quote arity]]
                  immediate-parameters [assoc-list-get instruction [quote immediate-parameters]]
                  parameters [assoc-list-get instruction [quote parameters]]
                  opcode [assoc-list-get instruction [quote opcode]]]
              [assert [eq arity [size args]] instruction arity mismatch [identity first-form]]
              [for i 0 [size parameters]
                [comment todo also check typessssss]
                [compile-form-mutable local-ctx code [at form [inc [add i [size immediate-parameters]]]]]]
              [if [is-list opcode]
                [for i 0 [size opcode]
                  [push-code-byte code [at opcode i]]]
                [push-code-byte code opcode]]
              [for i 0 [size immediate-parameters]
                  [assert [eq-word [at immediate-parameters i] immediate-u32] immediate parameter type mismatch]
                  [push-code-u32 code [eval [at form [inc i]]]]]
              [assoc-list-get instruction [quote results]]]
            [let [sig-index [assoc-list-index global-ctx-func-sigs first-form]]
              [if [is-negative sig-index]
                [let [exp-form [macro-expand form]]
                  [log [list [quote exp-form] exp-form]]
                  [compile-form-mutable local-ctx code exp-form]]
              [let [func-sig [at global-ctx-func-sigs [inc sig-index]]
                    parameter-types [first func-sig]]
                [assert [eq [size parameter-types] [size args]] parameter arity mismatch [list first-form [size parameter-types] [size args]]]
                [for i 0 [size args]
                  [comment todo also check types]
                  [compile-form-mutable local-ctx code [at args i]]]
                [push-code-byte code call]
                [push-code-u32 code [div sig-index 2]]
                [second func-sig]]]]
            ]]]]]]

[func data-passive-bytes [byte-list]
  [let [index [size global-ctx-datas]]
    [push global-ctx-datas [passive-data-bytes byte-list]]
    index]]

[func locals-to-bytes [locals]
  [let [bytes [mutable-list]
        number-of-locals [size locals]]
    [push-all bytes [u32-word-to-leb-128 [div number-of-locals 2]]]
    [for-inc i 0 2 number-of-locals
      [push-all bytes [u32-word-to-leb-128 [at locals i]]]
      [push bytes [at locals [inc i]]]]
    bytes]]

[func code-to-bytes [locals instructions]
  [let
    [bytes [concat [locals-to-bytes locals] instructions]]
    [concat [u32-word-to-leb-128 [size bytes]] bytes]]]

[func parse-type-list [types]
  [let [ml [mutable-list]]
    [for i 0 [size types]
      [let
        [type-word [at types i]
         type-code
         [ifs
          [eq-word [quote i32] type-word]
          i32

          [do
            [log unknown]
            [abort]]]]
        [push ml type-code]]]
    ml]]

[func comp-const-expr [form]
  [ifs
    [eq-word [quote data-passive-bytes] [first form]]
    [let [index [size global-ctx-datas]]
      [push global-ctx-datas [passive-data-bytes [rest form]]]
      [list index [dec [size form]]]]
    [abort]]]

[external-func eval [form] [form]]

[func dec-word-to-i32 [dw]
  [let [s [sub 0 [size dw]]]
    [loop [i -1 res 0 multi 1]
      [if [le s i]
        [let [c [at dw i]]
          [assert [and [le [quote 48] c] [le c [quote 57]]] not a decimal character]
          [assert [lt res [quote 214748364]] out of bounds]
          [continue i [dec i]
                    res [add res [mul [sub c [quote 48]] multi]]
                    multi [mul multi [quote 10]]]]
        res]]]]

[func compile-top-level-form [form]
  [ifs
    [eq-word [quote wasm-func] [first form]]
    [let [name [second form]
          params [third form]
          results [fourth form]
          param-ctx [mutable-list]
          parameter-type-list [mutable-list]
          -
          [for i 0 [size params]
            [comment check for duplicate parameters make type configurable]
            [push param-ctx [at params i]]
            [push param-ctx i32]
            [push parameter-type-list i32]]
          func-ctx [list param-ctx]
          parameter-type-list [freeze parameter-type-list]
          locals [mutable-list]
          code [mutable-list]
          code-locals [list code locals [size params]]
          -
          [for i 4 [dec [size form]]
            [comment remember to check type is empty maybe even drop unused and warn instead]
            [compile-form-mutable func-ctx code-locals [at form i]]]
          result-type [compile-form-mutable func-ctx code-locals [last form]]
          type-index
          [push-type
            [type-function parameter-type-list result-type]]
          import-count [size global-ctx-imports]
          functions global-ctx-functions
          func-index [div [size global-ctx-func-sigs] 2]]
      [push global-ctx-func-sigs name]
      [push global-ctx-func-sigs [list parameter-type-list result-type]]

      [push functions type-index]
      [push global-ctx-exports
        [wasm-export name kind-function func-index]]
      [push code end]
      [push global-ctx-codes [code-to-bytes locals code]]
      ]

    [eq-word [quote external-func] [first form]]
    [let [parameter-type-list [parse-type-list [at form 3]]
          result-type [parse-type-list [at form 4]]
          tf [type-function parameter-type-list result-type]
          - [log [list [quote tf] tf]]
          type-index [push-type tf]
          name [at form 2]]
      [push global-ctx-func-sigs name]
      [push global-ctx-func-sigs [list parameter-type-list result-type type-index]]
      [push global-ctx-imports
        [wasm-import [at form 1] name [import-desc-func type-index]]]]

    [eq-word [quote wasm-import] [first form]]
    [let [module-name [second form]
          field-name [third form]
          import-desc-syntax [fourth form]
          fw [first import-desc-syntax]
          import-desc
          [ifs
            [eq-word [quote memory] fw]
            [ifs
              [eq [size import-desc-syntax] 2]
              [import-desc-mem-min [dec-word-to-i32 [second import-desc-syntax]]]

              [eq [size import-desc-syntax] 3]
              [import-desc-mem-min-max [second import-desc-syntax] [third import-desc-syntax]]

              [do [log [quote mem wrong arity]] [abort]]]

            [eq-word [quote func] fw]
            [let [parameter-type-list [parse-type-list [second import-desc-syntax]]
                  result-type [parse-type-list [third import-desc-syntax]]
                  tf [type-function parameter-type-list result-type]
                  type-index [push-type tf]]
              [push global-ctx-func-sigs field-name]
              [push global-ctx-func-sigs [list parameter-type-list result-type type-index]]
              [import-desc-func type-index]
              ]

            [do [log [quote comp-import-desc not implemented]] [abort]]
            ]]
      [push global-ctx-imports
        [wasm-import module-name field-name import-desc]]]

    [eq-word [quote constant] [first form]]
    [let [name [second form]
          value [third form]]
      []]

    [eval form]]]

[func vector-section [section-id content]
  [let [n-of-bytes [size content]]
    [if n-of-bytes
      [concat [list section-id] [u32-word-to-leb-128 n-of-bytes] content]
      [list]]]]

[func vector-section-concat [section-id elements]
  [let [n-of-elements [size elements]]
    [if n-of-elements
      [vector-section section-id [concat [u32-word-to-leb-128 n-of-elements] [concat-lists elements]]]
      [list]]]]

[func func-section [func-indexes]
  [let [n-of-funcs [size func-indexes]]
    [if n-of-funcs
      [vector-section 3 [concat [u32-word-to-leb-128 n-of-funcs] func-indexes]]
      [list]]]]

[func ctx-to-module []
  [let [s-datas [size global-ctx-datas]]
    [concat
      [quote [0 97 115 109
              1 0 0 0]]
      [vector-section-concat 1 global-ctx-types]
      [vector-section-concat 2 global-ctx-imports]
      [func-section global-ctx-functions]
      [vector-section-concat [quote 7] global-ctx-exports]
      [if s-datas [vector-section [quote 12] [u32-word-to-leb-128 s-datas]] [list]]
      [vector-section-concat [quote 10] global-ctx-codes]
      [if s-datas [vector-section-concat [quote 11] global-ctx-datas] [list]]]]]

[func push-wasm-import [module-name field-name import-desc]
  [push global-ctx-imports
    [wasm-import module-name field-name import-desc]]]

[func import-func [name parameter-type-list result-type]
  [let [tf [type-function parameter-type-list result-type]
        type-index [push-type tf]]
    [push global-ctx-func-sigs name]
    [push global-ctx-func-sigs [list parameter-type-list result-type type-index]]
    [import-desc-func type-index]]]

[func push-wasm-import-func [module-name func-name parameter-type-list result-type]
  [push-wasm-import module-name func-name
    [import-func func-name parameter-type-list result-type]]]

[func compile-top-forms-to-module [forms]
  [for i 0 [size forms]
    [compile-top-level-form [at forms i]]]
  [ctx-to-module]
  ]

[export compile-top-forms-to-module]
