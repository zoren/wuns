[defn type-to-wasm [t]
  [if [is-pointer-type t] [quote i32] t]]

[defn type-to-result [t]
  [if [eq-form type-empty t]
      [quote [result]]
      [list [quote result] [type-to-wasm t]]]]

[defn push-word-chars [mut-list w]
  [for i 0 [size w]
    [push mut-list [at-word w i]]]]

[def tag-word 1]
[def tag-list 3]

[defn push-i32-little-endian [mut-list val]
  [loop [i 0 cur val]
    [when [lt i 4]
      [push mut-list [bitwise-and cur [const 255]]]
      [continue i [inc i] cur [bitwise-shift-right-unsigned cur [const 8]]]]]]

[def active-mem-start-offset [const 16]]

[defn get-or-create-word [ctx w]
  [let [word-map [getq ctx word-map]]
    [if [has word-map w]
      [get word-map w]
      [let [active-mem [getq ctx active-mem]
            offset [add [size active-mem] active-mem-start-offset]
            ws [size w]
            padding [sub 4 [bitwise-and 3 ws]]]
        [assert [lt ws [const 120]] word must be less than 120 characters]
        [push-i32-little-endian active-mem tag-word]
        [push-i32-little-endian active-mem ws]
        [push-word-chars active-mem w]
        [for i 0 padding
          [push active-mem [const 0]]]
        [set word-map w offset]
        offset]]]]

[defn get-or-create-form [ctx form]
  [if [is-word form]
    [get-or-create-word ctx form]
    [let [active-mem [getq ctx active-mem]
          offset [add [size active-mem] active-mem-start-offset]]
      [push-i32-little-endian active-mem tag-list]
      [push-i32-little-endian active-mem [size form]]
      [for-each element form
        [let [element-offset [get-or-create-form ctx element]]
          [push-i32-little-endian active-mem element-offset]]]
      offset]]]

[defn compile-form [ctx is-tail form]
  [if [is-word form]
    [let [gctx [getq [getq ctx check-result] global-ctx]]
      [if [and [has gctx form] [eq-form [getq [get gctx form] def] [quote constant]]]
        [list [quote global.get] [list [quote dollar] form]]
        [list [quote local.get] [list [quote dollar] form]]]]
    [do
      [assert [is-list form] form must be a list]
      [assert [not [is-empty form]] list must not be empty]
      [let [fw [at form 0]]
        [ifs
          [eq-word [quote if] fw]
          [ifs
            [eq 4 [size form]]
            [list fw
              [type-to-result [try-get-node-type form]]
              [compile-form ctx 0 [at form 1]]
              [list [quote then] [compile-form ctx is-tail [at form 2]]]
              [list [quote else] [compile-form ctx is-tail [at form 3]]]]
            [eq 3 [size form]]
            [list fw
              [type-to-result [try-get-node-type form]]
              [compile-form ctx 0 [at form 1]]
              [list [quote then] [compile-form ctx is-tail [at form 2]]]]

            [assert 0 sdf sdfsdf ]]

          [eq-word [quote quote] fw]
          [do
            [assert [eq 2 [size form]] quote must have 2 elements]
            [let [quoted [at form 1]
                  offset [get-or-create-form ctx quoted]]
              [list [quote i32.const] offset]]]

          [eq-word [quote let] fw]
          [do
            [log [quote let not implemented]]
            [unreachable]
          ]

          [let [instruction [try-get-instruction fw]]
            [if instruction
              [let [imm-parameters [getq instruction immediate-parameters]]
                [ifs
                  [eq-form imm-parameters imm-memargs]
                  [let [memargs [try-get-node-type [at form 1]]]
                    [concat
                      [list [list [quote raw] [getq instruction wat-name]] [getq memargs mem]
                        [list [quote eq-pair] [quote offset] [getq memargs offset]]
                        [list [quote eq-pair] [quote align] [getq memargs align]]]
                      [loop [i 2 res [mutable-list]]
                        [if [lt i [size form]]
                          [do
                            [push res [compile-form ctx 0 [at form i]]]
                            [continue i [inc i]]]
                          res]]]]

                  [not [is-empty imm-parameters]]
                  form

                  [loop [i 1 res [mutable-list]]
                    [if [lt i [size form]]
                      [do
                        [push res [compile-form ctx 0 [at form i]]]
                        [continue i [inc i]]]
                      [concat [list [list [quote raw] [getq instruction wat-name]]] res]]]]]
              [loop [i 1 res [mutable-list]]
                [if [lt i [size form]]
                  [do
                    [push res [compile-form ctx 0 [at form i]]]
                    [continue i [inc i]]]
                  [concat [list [quote call] [list [quote dollar] fw]] res]]]]]]]]]]

[defn compile-top-form [ctx form]
  [if [is-word form]
    []
    [do
      [assert [is-list form] list must be a list]
      [assert [not [is-empty form]] a list must not be empty]
      [let [fw [at form 0]]
        [assert [is-word fw] first element of a list must be a word]
        [ifs
          [eq-word [quote import] fw]
          [let [module-name [at form 1]
                name [at form 2]
                t [at form 3]]
              [list [quote import] [list [quote dq-string] module-name] [list [quote dq-string] name]
                [if [eq-word [first t] [quote memory]]
                  t
                  [list [quote func] [list [quote dollar] name] [concat [quote [param]] [second t]] [concat [quote [result]] [third t]]]]]]

          [eq-word [quote constant] fw]
          [let [name [at form 1]
                value [at form 2]]
              [list [quote global]
                [list [quote dollar] name]
                [list [quote export] [list [quote dq-string] name]]
                [type-to-wasm [try-get-node-type value]]
                [compile-form ctx 1 value]]]

          [eq-word [quote defn] fw]
          [let [fname [at form 1]
                params [at form 2]
                wasm-params [mutable-list]
                wasm-bodies [mutable-list]
                last-body [at form -1]]
            [assert [is-word fname] second element of a list must be a word]
            [assert [is-list params] third element of a list must be a list]
            [for-each param params
              [push wasm-params
                [list [quote param]
                  [list [quote dollar] param]
                  [try-get-node-type param]]]]
            [for i 3 [dec [size form]]
              [let [body [at form i]
                    cbody [compile-form ctx 0 body]]
                [push wasm-bodies [if [is-atomic-type [try-get-node-type body]] [list [quote drop] cbody] cbody]]]]
            [push wasm-bodies [compile-form ctx 1 last-body]]
            [concat
              [list [quote func] [list [quote dollar] fname] [list [quote export] [list [quote dq-string] fname]]]
              wasm-params
              [list [type-to-result [try-get-node-type last-body]]]
              wasm-bodies]]

          [assert 0 sdf sdfsdf ]]]]]]

[defn is-printable-ascii [c]
  [and [ge c [const 32]] [lt c [const 127]]]]

[defn int-to-hex-ascii [i]
  [if [lt i [const 10]]
    [add i [const 48]]
    [add [sub i [const 10]] [const 97]]]]

[defn print-paren-recursive-form [mut-list form]
  [ifs
    [is-word form]
    [push-word-chars mut-list form]

    [is-list form]
    [let [s [size form]]
      [ifs
        [and [eq s 3] [eq-word [first form] [quote eq-pair]]]
        [do
          [push-word-chars mut-list [second form]]
          [push mut-list [const 61]]
          [push-word-chars mut-list [third form]]]

        [and [eq s 2] [eq-word [first form] [quote dollar]]]
        [do
          [push mut-list [const 0x24]]
          [push-word-chars mut-list [second form]]]

        [and [eq s 2] [eq-word [first form] [quote dq-string]]]
        [do
          [push mut-list [const 0x22]]
          [push-word-chars mut-list [second form]]
          [push mut-list [const 0x22]]]

        [and [eq s 2] [eq-word [first form] [quote dq-string-bytes]]]
        [do
          [push mut-list [const 0x22]]
          [for-each c [second form]
            [if [is-printable-ascii c]
              [push mut-list c]
              [do
                [assert [not [is-negative c]] c must be positive]
                [assert [lt c [const 256]] c must be less than 256]
                [push mut-list [const 0x5c]]
                [push mut-list [int-to-hex-ascii [div c [const 16]]]]
                [push mut-list [int-to-hex-ascii [rem c [const 16]]]]]]]
          [push mut-list [const 0x22]]]

        [and [eq s 2] [eq-word [first form] [quote raw]]]
        [push-all mut-list [second form]]

        [do
          [push mut-list [const 40]]
          [when [lt 0 s]
            [print-paren-recursive-form mut-list [at form 0]]
            [for i 1 s
              [push mut-list [const 32]]
              [print-paren-recursive-form mut-list [at form i]]]]
          [push mut-list [const 41]]]]]

    [do [log [list [quote unknown node] form ]]
      [unreachable]]]]

[defn print-paren-form [form]
  [let [mut-list [mutable-list]]
    [print-paren-recursive-form mut-list form]
    mut-list]]

[defn compile-top-forms-to-text [forms]
  [let [check-result [check-top-forms forms]
        mut-list [mutable-list]
        active-mem [mutable-list]
        ctx [kv-map active-mem active-mem check-result check-result
                    word-map [transient-kv-map] list-map [transient-kv-map]]]
    [for-each form forms
      [print-paren-recursive-form mut-list [compile-top-form ctx form]]
      [push mut-list [const 10]]]
    [delete-all-keys node-types]
    [when [size active-mem]
      [print-paren-recursive-form mut-list [list [quote data] [list [quote i32.const] active-mem-start-offset] [list [quote dq-string-bytes] active-mem]]]]
    [print-paren-recursive-form mut-list [list [quote global] [quote dollar wuns-active-mem-top] [quote i32] [list [quote i32.const] [add [size active-mem] active-mem-start-offset]]]]
    [persistent-array mut-list]]]
