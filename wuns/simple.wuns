[load wat.wuns]
[load interpreter-externs.wuns]

[def initial-memory-offset [i32 256]]
[def memory-alignment [i32 16]]

[defn align [p x]
  [intrinsic i32.and
    [add x [dec p]]
    [intrinsic i32.xor [i32 -1] [dec p]]]]

[defn memory-align [x] [align memory-alignment x]]

[type primitive-type []
  [record
    [prefix word]
    [bytes i32]]]

[defn primitive-type/bits [pt]
  [mul 8 [primitive-type/bytes pt]]]

[defn primitive-type/name [pt]
  [concat-words [primitive-type/prefix pt] [int-to-word [primitive-type/bits pt]]]]

[def primitive-types-by-name
  [let [m [transient-kv-map]]
    [for-each prefix-bits [list
        [pair [word i] 1]
        [pair [word u] 1]

        [pair [word i] 2]
        [pair [word u] 2]

        [pair [word i] 4]
        [pair [word u] 4]

        [pair [word i] 8]

        [pair [word f] 4]
        [pair [word f] 8]

        [pair [word v] [i32 16]]]
      [let [prefix [pair/fst prefix-bits]
            bytes [pair/snd prefix-bits]
            pt [primitive-type prefix bytes]]
        [set-kv-map m [primitive-type/name pt] pt]]]
    m]]

[defn get-primitive [word]
  [get primitive-types-by-name word]]

[defn primitive-is-wasm-value-type [pt]
  [let
    [prefix [primitive-type/prefix pt] bits [primitive-type/bits pt]]
    [or
      [and [or [eq-word prefix [word i]] [eq-word prefix [word f]]] [or [eq bits [i32 32]] [eq bits [i32 64]]]]
      [eq-word [primitive-type/name pt] [word v128]]]]]

[defn primitive-type-is-integer [p]
  [let [prefix [primitive-type/prefix p]]
    [or [eq-word prefix [word u]] [eq-word prefix [word i]]]]]

[defn primitive-integer-type-min-max-range [pt]
  [switch [primitive-type/prefix pt]
    [[word i]]
    [let [bits [primitive-type/bits pt]
          pow2 [intrinsic bigint.shl [bigint 1] [i32-to-bigint [dec bits]]]]
        [pair [intrinsic bigint.sub [bigint 0] pow2] [intrinsic bigint.sub pow2 [bigint 1]]]]

    [[word u]]
    [let [bits [primitive-type/bits pt]
          pow2 [intrinsic bigint.shl [bigint 1] [i32-to-bigint bits]]]
        [pair [bigint 0] [intrinsic bigint.sub pow2 [bigint 1]]]]

    [logq-abort unsupported literal type]]]

[def type-primitive-u8 [get-primitive [word u8]]]
[def type-primitive-i32 [get-primitive [word i32]]]
[def type-primitive-i64 [get-primitive [word i64]]]
[def type-primitive-f32 [get-primitive [word f32]]]
[def type-primitive-f64 [get-primitive [word f64]]]

[type name []
  [record
    [word word]]]

[type let-or-loop []
  [union [let] [loop]]]

[type imm-arg []
  [union [memory name]]]

[type
  type []
  [union
    [primitive primitive-type]
    [var name]
    [wildcard name]
    [pointer type type]

    [memory name]

    [array type [option type]]
    [tuple [list type]]
    [record [list [pair name type]]]

    [union [list type]]

    [exp exp]

    [func type-func]
    [functor [list [pair name type-kind]] type]
    [apply-custom name [list type]]]

  type-func []
  [record
    [type-parameters [list [pair name type-kind]]]
    [parameters [list type]]
    [result type]]

  exp []
  [union
    [integer primitive-type bigint]
    [float primitive-type f64]
    [var name]

    [call exp [list exp]]
    [call-functor name [list type]]
    [instantiate exp [list type]]

    [reify type]

    [intrinsic name [list imm-arg] [list exp]]
    [size-of-type type]
    [size-of-exp exp]

    [if exp exp exp]
    [let-loop let-or-loop [list [pair [list name] exp]] [list exp]]
    [continue [list [pair name exp]]]
    [do [list exp]]

    [cast type exp]
    [annotation type exp]

    [deref exp]

    [pindex exp exp]
    [pfield exp name]

    [offset-of type name]

    [array type [list exp]]
    [tuple [list exp]]
    [record [list [pair name exp]]]

    [assign exp exp]
    [passign i32 exp exp]

    [data
      ; a memory
      exp
      ; a constant exp
      exp]
    [data-passive exp]
    [memory-static-top exp]
    [func exp-function]

    ]

  type-kind []
  [union
    [datatype]
    [non-datatype]
    [exp type]
    [memory primitive-type]]

  exp-function []
  [record
    [kind word]
    [name [option name]]
    [type type-func]
    [parameters [list name]]
    [bodies [list exp]]]]

[defn may-side-effect [e]
  [match e
    [exp/integer - --] false
    [exp/float - --] false
    [exp/var -] false
    [exp/cast - e] [may-side-effect e]
    [exp/annotation - e] [may-side-effect e]
    [exp/pindex t i] [or [may-side-effect t] [may-side-effect i]]
    [exp/pfield t -] [may-side-effect t]
    [exp/offset-of - --] false
    [exp/intrinsic n - args]
    [or
      [eq-word [name/word n] [word unreachable]]
      [exists args may-side-effect]]
    [exp/deref e] [may-side-effect e]
    true]]

[def type-u8 [type/primitive type-primitive-u8]]
[def type-i32 [type/primitive type-primitive-i32]]
[def type-i64 [type/primitive type-primitive-i64]]
[def type-f64 [type/primitive type-primitive-f64]]
[def type-empty [type/union [list]]]
[def type-tuple-empty [type/tuple [list]]]

[defn type-empty-is [t]
  [match t
    [type/union utypes] [is-empty utypes]
    false]]

[type immediate-type []
  [union
    [memory]]]

[type intrinsic-type []
  [record
    [immediate-parameters [list immediate-type]]
    [parameters [list type]]
    [result type]]]

[type data-active []
  [record
    [mem-name word]
    [address i32]
    [bytes byte-array]]]

[defn intrinsic-type-from-name [n]
  [switch n
    [[word i32.add] [word i32.sub] [word i32.mul]
     [word i32.and] [word i32.or] [word i32.xor]
     [word i32.shl] [word i32.shr-s] [word i32.shr-u]

     [word i32.eq]   [word i32.ne]
     [word i32.lt-s] [word i32.le-s]
     [word i32.gt-s] [word i32.ge-s]
     [word i32.lt-u] [word i32.le-u]
     [word i32.gt-u] [word i32.ge-u]]
    [intrinsic-type [list] [list type-i32 type-i32] type-i32]

    [[word i64.add] [word i64.sub] [word i64.mul]
     [word i64.and] [word i64.or] [word i64.xor]
     [word i64.shl] [word i64.shr-s] [word i64.shr-u]
     [word i64.div-s] [word i64.div-u] [word i64.rem-s] [word i64.rem-u]
     ]
    [intrinsic-type [list] [list type-i64 type-i64] type-i64]

    [[word i64.eq]   [word i64.ne]
     [word i64.lt-s] [word i64.le-s]
     [word i64.gt-s] [word i64.ge-s]
     [word i64.lt-u] [word i64.le-u]
     [word i64.gt-u] [word i64.ge-u]]
    [intrinsic-type [list] [list type-i64 type-i64] type-i32]

    [[word f64.add] [word f64.sub] [word f64.mul]]
    [intrinsic-type [list] [list type-f64 type-f64] type-f64]

    [[word i32.wrap-i64]]
    [intrinsic-type [list] [list type-i64] type-i32]

    [[word i64.extend-i32-s]]
    [intrinsic-type [list] [list type-i32] type-i64]

    [[word unreachable]]
    [intrinsic-type [list] [list] type-empty]

    [[word memory.size]]
    [intrinsic-type [list [immediate-type/memory]] [list] type-i32]

    [[word memory.grow]]
    [intrinsic-type [list [immediate-type/memory]] [list type-i32] type-i32]

    [[word memory.copy]]
    [intrinsic-type [list [immediate-type/memory]] [list type-i32 type-i32 type-i32] type-tuple-empty]

    [[word memory.fill]]
    [intrinsic-type [list [immediate-type/memory]] [list type-i32 type-i32 type-i32] type-tuple-empty]

    [logq-abort not implemented intrinsic [identity n]]]]

[defn type-iterate [f]
  [func go [t]
    [f t]
    [match t
      [type/var -] [do]
      [type/wildcard -] [do]
      [type/primitive -] [do]
      [type/exp -] [do]

      [type/tuple ts] [for-each tt ts [go tt]]
      [type/pointer mt pt] [do [go mt] [go pt]]
      [type/array at opt-et] [do [go at] [when-let [et opt-et] [go et]]]
      [type/record fs] [for-each ff fs [go [pair/snd ff]]]
      [type/union ts] [for-each tt ts [go tt]]
      [type/apply-custom tn args] [for-each arg args [go arg]]
      [type/func tf] [do [for-each pp [type-func/parameters tf] [go pp]] [go [type-func/result tf]]]
      [logq-abort type-iterate not implemented [identity t]]]]]

[defn type-substitute [type-env outer-t]
  [[func go [t]
    [match t
      [type/var tv]
      [if-let [subst-t [try-get type-env [name/word tv]]]
        subst-t
        [logq-abort type-substitute var not found [identity tv]]]

      [type/wildcard -] t
      [type/primitive -] t
      [type/exp -] t

      [type/tuple ts]
      [type/tuple [list-map a ts [go a]]]

      [type/pointer mt pt]
      [type/pointer [go mt] [go pt]]

      [type/array at opt-et]
      [type/array [go at] [option-map go opt-et]]

      [type/record fs]
      [type/record [list-map f fs [pair [pair/fst f] [go [pair/snd f]]]]]

      [type/union ts]
      [type/union [list-map a ts [go a]]]

      [type/apply-custom tn args]
      [type/apply-custom tn [list-map a args [go a]]]

      [type/func tf]
      [type/func
        [type-func
          [type-func/type-parameters tf]
          [list-map pp [type-func/parameters tf] [go pp]]
          [go [type-func/result tf]]]]

      [logq-abort type-substitute not implemented [identity t]]]]
    outer-t]]

[type value-kind [] [union [constant] [mutable]]]

[def value-kind-constant [value-kind/constant]]
[def value-kind-mutable [value-kind/mutable]]

[type memory-exp []
  [record
    [type primitive-type]
    [init-size name]
    [max-size [option name]]]]

[type import-kind-decl []
  [union
    [value value-kind type]
    [memory memory-exp]
    [function [list [pair name type]] type]]]

[type
  top-decl []
  [union
    [import name [list [pair name import-kind-decl]]]
    [value value-kind name exp]
    [memory name memory-exp]
    [function exp-function]
    [export [list name]]]]

[type local-context-kind []
  [union
    [func [transient-kv-map word i32]]
    [let] [loop] [type-decl]]]

[type local-var-desc []
  [record
    [type type]
    [wat-name word]]]

[defn set-param-desc [param-ctx n t]
  [let [w [name/word n]]
    [set-kv-map param-ctx w [local-var-desc t w]]]]

[type local-context []
  [union
    [empty]
    [frame [local-context] [transient-kv-map word local-var-desc] local-context-kind]]]

[defn local-context-make [outer vars kind]
  [local-context/frame outer vars kind]]

[def local-context-empty [local-context/empty]]

[defn local-context-make-func [param-ctx]
  [local-context-make local-context-empty param-ctx [local-context-kind/func [transient-kv-map]]]]

[defn try-get-enclosing-loop-context [lctx]
  [loop [cur lctx]
    [match cur
      [local-context/empty]
      [option/none]

      [local-context/frame outer names kind]
      [match kind
        [local-context-kind/loop]
        [option/some names]

        [local-context-kind/let]
        [continue cur outer]

        [local-context-kind/func -]
        [option/none]]]]]

[defn get-enclosing-func-context [lctx]
  [loop [cur lctx]
    [match cur
      [local-context/empty]
      [logq-abort get-enclosing-func-context not in a function]

      [local-context/frame outer names kind]
      [match kind
        [local-context-kind/func fctx]
        fctx

        [continue cur outer]]]]]

[type functor-desc []
  [record
    [parameters [list [pair name type-kind]]]
    [body exp]]]

[type memory-desc []
  [record
    [type primitive-type]
    [init-size i32]
    [max-size [option i32]]]]

[defn mem-exp-to-mem-kind [mem-exp]
  [memory-desc
    [memory-exp/type mem-exp]
    [word-to-int [name/word [memory-exp/init-size mem-exp]]]
    [option-map
      [func f [max] [word-to-int [name/word max]]]
      [memory-exp/max-size mem-exp]]]]

[type value-desc []
  [record
    [kind value-kind]]]

[type top-desc-kind []
  [union
    [functor functor-desc]
    [memory memory-desc]
    [value value-desc]]]

[type imported-or-here [] [union [imported] [here]]]

[type top-desc []
  [record
    [kind top-desc-kind]
    [imported imported-or-here]]]

[type local-name-desc []
  [record
    [context-kind local-context-kind]
    [desc local-var-desc]]]

[type desc-kind []
  [union
    [local local-name-desc]
    [top top-desc]]]

[type name-desc []
  [record
    [type type]
    [kind desc-kind]]]

[type exp2inst-compiler []
  [record
    [exp-to-inst [func [exp] wat-inst]]
    [exps-to-inst [func [[list exp]] wat-inst]]
    [glocals [growable-list [pair word word]]]]]

[defn try-get-type-exp [t]
  [match t
    [type/exp e]
    [option/some e]
    [option/none]]]

[defn starts-with-dash [w]
  [eq [char-code-at w 0] [word-to-char-code -]]]

[defmacro error [form .. message]
  [flist [quote error-form-fn] form [quote-list message]]]

[defmacro error-name [form .. message]
  [flist [quote error-name-fn] form [quote-list message]]]

[defmacro error-exp [exp .. message]
  [flist [quote error-exp-fn] exp [quote-list message]]]

[defn prim-types-to-load-inst-name [dst src]
  [let [prefix [concat-words [primitive-type/name dst] [word .load]]]
    [if [is-identical dst src]
      prefix
      [do
        [assert [primitive-type-is-integer src] load expected integer type source]
        [concat-words prefix
          [concat-words [int-to-word [primitive-type/bits src]]
            [concat-words [word -] [if [eq-word [primitive-type/prefix src] [word u]] [word u] [word s]]]]]]]]]

[defn prim-types-to-store-inst-name [target-prim value-prim]
  [if [and [is-identical target-prim value-prim] [primitive-is-wasm-value-type target-prim]]
    [concat-words [primitive-type/name target-prim] [word .store]]
    [if-not [or [is-identical value-prim type-primitive-i32]
                [is-identical value-prim type-primitive-i64]]
      [concat-words
        [word i32.store]
        [int-to-word [primitive-type/bits target-prim]]]
      [do
        [assert [primitive-type-is-integer target-prim] store expected integer type]
        [concat-words
          [concat-words [primitive-type/name value-prim] [word .store]]
          [int-to-word [primitive-type/bits target-prim]]]]]]]

[defn try-get-int-const [e]
  [match e
    [exp/integer pt i]
    [do
      [assert [is-identical pt type-primitive-i32] try-get-int-const expected i32]
      [option/some i]]
    [option/none]]]

[defn mk-exp-i32-add [a b]
  [exp/intrinsic [name [word i32.add]] [list] [list a b]]]

[defn mk-exp-i32 [bi] [exp/integer type-primitive-i32 bi]]

[defn mk-exp-i32-i32 [i] [mk-exp-i32 [i32-to-bigint i]]]

[defn int-exp-add [a b]
  [if-let [i [try-get-int-const a]]
    [if [is-identical i [bigint 0]]
      b
      [if-let [j [try-get-int-const b]]
        [mk-exp-i32 [intrinsic bigint.add i j]]
        [mk-exp-i32-add a b]]]
    [if-let [j [try-get-int-const b]]
      [if [is-identical j [bigint 0]]
        a
        [mk-exp-i32-add a b]]
      [mk-exp-i32-add a b]]]]

[def int-const-0 [mk-exp-i32 [bigint 0]]]
[def int-const-1 [mk-exp-i32 [bigint 1]]]

[defn try-get-i32-add-const [e]
  [match e
    [exp/intrinsic n - args]
    [let [a [first args] b [second args]]
      [if [eq-word [name/word n] [word i32.add]]
        [if-let [i [try-get-int-const a]]
          [if-let [j [try-get-int-const b]]
            [option/some [pair int-const-0 [intrinsic bigint.add i j]]]
            [option/some [pair b i]]]
          [if-let [j [try-get-int-const b]]
            [option/some [pair a j]]
            [option/none]]]
        [option/none]]]
    [option/none]]]

[defn mk-exp-i32-mul [a b]
  [exp/intrinsic [name [word i32.mul]] [list] [list a b]]]

[defn int-exp-mul [a b]
  [if-let [i [try-get-int-const a]]
    [ifs
      [is-identical i [bigint 0]] int-const-0
      [is-identical i [bigint 1]] b
      [if-let [j [try-get-int-const b]]
        [mk-exp-i32 [intrinsic bigint.mul i j]]
        [mk-exp-i32-mul a b]]]
    [if-let [j [try-get-int-const b]]
      [ifs
        [is-identical j [bigint 0]] int-const-0
        [is-identical j [bigint 1]] a
        [mk-exp-i32-mul a b]]
      [mk-exp-i32-mul a b]]]]

[def type-kind-datatype [type-kind/datatype]]
[def type-kind-non-datatype [type-kind/non-datatype]]
[def empty-type-env [transient-kv-map]]

[type type-signature []
  [record
    [kind type-kind]
    [params [list [pair name type-kind]]]
    [param-map [transient-kv-map word type-kind]]]]

[type type-desc []
  [record
    [syntax-type type]
    [canonical-type type]]]

[defn get-exp-var [e]
  [match e
    [exp/var n] [name/word n]
    [logq-abort get-exp-var not a var [identity e]]]]

[defn pairwise-pairs-check [l]
  [assert-not [is-odd [size l]] pairwise-pairs-check expected even number of elements]
  [pairwise-pairs l]]

[defn make-compiler []
[let
  [gerrors [growable-list]
   name-to-desc [transient-kv-map]
   top-names [transient-kv-map]
   value-constants [transient-kv-map]
   top-funcs [transient-kv-map]
   exp-to-form [transient-kv-map]
   active-data-map [transient-kv-map]
   active-data-map-offsets [transient-kv-map]
   datas [growable-list]
   name-to-form [transient-kv-map]
   custom-type-signatures [transient-kv-map]
   custom-types [transient-kv-map]
   custom-types-recursive [set]
   gen-fn-specs-by-name [transient-kv-map]
   wat-funcs [growable-list]
   type-var-name-to-kind [transient-kv-map]]
[letfn [
[func error-form-fn [form message-form]
  [push gerrors [pair form message-form]]
  [log-location form]
  [logq error [identity message-form]]
  ]

[func error-exp-fn [exp message-form]
  [logq-abort error-exp [identity exp] [identity message-form]]]

[func error-name-fn [name message-form]
  [error-form-fn [get name-to-form name] message-form]]

[func get-word [f]
  [if-let [w [try-get-word f]]
    w
    [do
      [error f expected word]
      [word --not-a-word--]]]]
[func get-list [f]
  [if-let [w [try-get-list f]]
    w
    [do
      [error f expected list]
      [list]]]]
[func form-to-name [f]
  [if-let [w [try-get-word f]]
    [let [n [name w]]
      [set-kv-map name-to-form n f]
      n]
    [do
      [log-location f]
      [logq-abort expected word [identity f]]]]]

[func form-to-word-report [f]
  [if-let [w [try-get-word f]]
    w
    [do
      [log-location f]
      [logq-abort form-to-word-report expected word [identity f]]]]]

[func try-get-name [lctx name-word]
  [loop [cur lctx]
    [match cur
      [local-context/empty]
      [if-let [td [try-get top-names name-word]]
        [option/some [name-desc [pair/fst td] [desc-kind/top [pair/snd td]]]]
        [option/none]]

      [local-context/frame outer names kind]
      [if-let [ldesc [try-get names name-word]]
        [option/some [name-desc [local-var-desc/type ldesc] [desc-kind/local [local-name-desc kind ldesc]]]]
        [continue cur outer]]]]]

[func try-lookup-bind-name [lctx name]
  [let
    [name-word [name/word name]
     opt-desc [try-get-name lctx name-word]]
    [when-let [desc opt-desc]
      [set-kv-map name-to-desc name desc]]
    opt-desc]]

[func lookup-bind-name [lctx name]
  [if-let [desc [try-lookup-bind-name lctx name]]
    desc
    [do
      [error-name name not found]
      [logq-abort lookup-bind-name [identity name]]]]]

[func form-to-exp-type-kind-env [type-kind-env lctx form]
  [match form
    [form/word w]
    [let [n [form-to-name form]]
      [lookup-bind-name lctx n]
      [exp/var n]]

    [form/list l]
    [do
      [when [is-empty l]
        [log-location form]
        [logq-abort empty-list]]
      [let
        [ff [first l]
         proc-form
         [func form-to-exp-type-kind-env-proc-form []
          [let [fe [form-to-exp-type-kind-env type-kind-env lctx ff]]
            [match [type-of fe]
              [type/func tf]
              [let
                [tparams [type-func/type-parameters tf]
                 params [type-func/parameters tf]
                 args [rest l]
                 cargs [list-map arg args [form-to-exp-type-kind-env type-kind-env lctx arg]]]
                [assert [eq [size params] [size args]]
                  form-to-exp expected same number of arguments [identity fe]
[size params] [size args]
                  ]
                ; todo start checking assignability again when we have type env
                [for-each carg cargs [type-of carg]]
                [exp/call fe cargs]]

              [type/functor tparams tbody]
              [let [args [rest l]]
                [assert [eq [size tparams] [size args]] functor call expected same number of arguments]
                [let [targs [list-map arg args [form-to-type-type-env type-kind-env lctx arg]]]
                  [for i 0 [size tparams]
                    [let [pp [at tparams i]
                          pk [pair/snd pp]
                          targ [at targs i]]
                      [when-let [tk [type-to-type-kind-opt type-kind-env targ]]
                        [when-not [type-kind-equals pk tk]
                          [logq-abort call-functor expected same type [identity tk] [identity pk]]]]]]
                  [match fe
                    [exp/var fn]
                    [exp/call-functor fn targs]

                    [logq-abort can only call named functors]]]]

              [logq-abort form-to-exp-type-kind-env not a function [identity ff]]]]]]
        [match ff
          [form/word fw]
          [if-let [- [try-get-name lctx fw]]
            [proc-form]
            [form-special-to-exp type-kind-env lctx fw l]]

          [form/list -]
          [proc-form]]]]]]

[func common-super-type [t1 t2]
  [ifs
    [type-empty-is t1] t2
    [type-empty-is t2] t1
    [type-assignable t1 t2] t1
    [type-assignable t2 t1] t2
    [if-let [p1 [try-get-primitive t1]]
      [if-let [p2 [try-get-primitive t2]]
        [if [is-identical p1 p2]
          [type/primitive p1]
          [logq-abort common-super-type exp types do not match [identity p1] [identity p2]]]
        [logq-abort common-super-type not implemented p2 [identity t1] [identity t2]]]
      [match t1
        [type/exp e1]
        [match t2
          [type/exp e2]
          [if
            [exp-equals e1 e2]
            t1

            [match e1
              [exp/integer pt1 i1]
              [match e2
                [exp/integer pt2 i2]
                [if [is-identical pt1 pt2]
                  [type/primitive pt1]
                  [logq-abort common-super-type exp types do not match [identity e1] [identity e2]]]]]]
          [logq-abort common-super-type not implemented e2 [identity t1] [identity t2]]]
        [do
          [log t1]
          [log t2]
          [logq-abort common-super-type not implemented e3]]
          ]]]]

[func form-to-type [outer-form]
  [form-to-type-type-env empty-type-env local-context-empty outer-form]]

[func type-kind-equals [tk1 tk2]
  [or [is-identical tk1 tk2]
    [match tk1
      [type-kind/datatype]
      [match tk2
        [type-kind/datatype]
        true
        false]

      [type-kind/exp e1]
      [match tk2
        [type-kind/exp e2]
        [type-equals e1 e2]

        false]

      [logq-abort type-kind-equals [identity tk1] [identity tk2]]]]]

[func type-to-type-kind-opt [type-env arg]
  [match arg
    [type/var n] [option/some [get type-env [name/word n]]]
    [type/wildcard wcn] [option/none]
    [type/exp e] [option/some [type-kind/exp [type-of e]]]
    [type/memory mem-name] [option/some [type-kind/memory [get-mem-type [name/word mem-name]]]]
    [type/apply-custom tn -args] [option/some [type-signature/kind [get custom-type-signatures [name/word tn]]]]
    [type/primitive -] [option/some type-kind-datatype]
    [type/pointer - --] [option/some type-kind-datatype]
    [type/tuple -] [option/some type-kind-datatype]
    [type/record -] [option/some type-kind-datatype]
    [type/union -] [option/some type-kind-datatype]
    [type/array - --] [option/some type-kind-datatype]
    [type/func -] [option/some type-kind-non-datatype]
    [type/functor - --] [option/some type-kind-non-datatype]
    [logq-abort type-to-type-kind [identity arg]]]]

[func form-to-type-type-env [type-env lctx outer-form]
  [letfn [
  [func go-f2t-te [form]
    [match form
    [form/word w]
    [if [starts-with-dash w]
      [type/wildcard [form-to-name form]]
      [let [n [form-to-name form]]
        [if-let [tkind [try-get type-env [name/word n]]]
          [set-kv-map type-var-name-to-kind n tkind]
          [do
            [logq-abort tenv type var not found [name/word n] [identity type-env]]
            [error-name n type var not found]]]
        [type/var n]]]

    [form/list l]
    [if [is-empty l]
      [type/tuple [list]]
      [let [type-name-word [form-to-word-report [first l]]
            n-of-args [dec [size l]]]
        [if-let [custom-type-signature [try-get custom-type-signatures type-name-word]]
          [let [type-params [type-signature/params custom-type-signature]
                targs [list-map a [rest l] [go-f2t-te a]]]
            [assert [eq n-of-args [size type-params]] form-to-type expected same number of arguments
              [identity type-name-word] [size type-params] [identity n-of-args]]
            [for i 0 [size type-params]
              [let
                [tp [at type-params i]
                targ [at targs i]]
                [when-let [arg-kind [type-to-type-kind-opt type-env targ]]
                  [when-not [type-kind-equals [pair/snd tp] arg-kind]
                    [logq-abort form-to-type type mismatch [identity targ] [identity tp]]]]]]
            [type/apply-custom [form-to-name [first l]] targs]]
          [switch type-name-word
            [[word tuple]]
            [type/tuple [list-map t [rest l] [go-f2t-te t]]]

            [[word record]]
            [type/record
              [list-map pf [rest l]
                [let [p [get-list pf]]
                  [pair [form-to-name [first p]] [go-f2t-te [second p]]]]]]

            [[word union]]
            [type/union [list-map a [rest l] [go-f2t-te a]]]

            [[word pointer]]
            [do
              [assert [eq n-of-args 2] form-to-type expected 2 elements [identity type-name-word] [identity n-of-args]]
              [let [mt [go-f2t-te [second l]]
                    target-type [go-f2t-te [third l]]]
                [type/pointer mt target-type]]]

            [[word exp]]
            [let [be [form-to-exp-type-kind-env type-env lctx [second l]]]
              [type/exp [if-let [c [try-resolve-constant be]] c be]]]

            [[word array]]
            [ifs
              [eq [size l] 2]
              [type/array [go-f2t-te [second l]] [option/none]]

              [eq [size l] 3]
              [type/array [go-f2t-te [second l]] [option/some [go-f2t-te [third l]]]]

              [logq-abort array expected 2 or 3 elements]]

            [if-let [p [try-get primitive-types-by-name type-name-word]]
              [do
                [assert [eq n-of-args 0] form-to-type primitive takes no arguments [identity type-name-word]]
                [type/primitive p]]
              [logq-abort not implemented form-to-type [identity form]]]]]]]]]]
    [go-f2t-te outer-form]]]

[func get-mem-type [mem-name-word]
  [match [top-desc/kind [pair/snd [get top-names mem-name-word]]]
    [top-desc-kind/memory mt] [memory-desc/type mt]

    [logq-abort get-mem-type not a memory]]]

[func get-memory-exp-type [mem-name-exp]
  [match [type-of mem-name-exp]
    [type/memory mem-name] [get-mem-type [name/word mem-name]]
    [logq-abort not a type/memory [identity mem-name-exp]]]]

[func get-memory-pointer-type [t]
  [if-let [mem-texp [try-get-type-exp t]]
    [get-memory-exp-type mem-texp]
    [logq-abort get-memory-pointer-type expected memory type [identity t]]]]

[func get-memory-offset-atom [mem-name-word]
  [if-let [offset-atom [try-get active-data-map-offsets mem-name-word]]
    offset-atom
    [let [oa [atom initial-memory-offset]]
      [set-kv-map active-data-map-offsets mem-name-word oa]
      oa]]]

[func form-special-to-exp [type-kind-env lctx fw l]
  [switch fw
    [[word if]]
    [let [c [form-to-exp-type-kind-env type-kind-env lctx [second l]]
          t [form-to-exp-type-kind-env type-kind-env lctx [third l]]
          e [if [eq [size l] 4] [form-to-exp-type-kind-env type-kind-env lctx [fourth l]] [exp/do [list]]]
          tt [type-of t]
          te [type-of e]]
      [when-not [type-assignable type-i32 [type-of c]] [logq-abort if condition not i32]]
      [logq form-special-to-exp common-super-type [identity fw] [identity c] [identity t] [identity e]]
      [common-super-type tt te]
      [exp/if c t e]]

    ; make these as (compile-time) macros instead
    [[word when]]
    [let
      [c [form-to-exp-type-kind-env type-kind-env lctx [second l]]
       bodies [list-map b [slice l 2 [size l]] [form-to-exp-type-kind-env type-kind-env lctx b]]
       t [exp/do bodies]
       tt [type-of t]]
      [when-not [type-assignable type-i32 [type-of c]] [logq-abort if condition not i32]]
      [logq form-special-to-exp common-super-type [identity fw]]
      [common-super-type tt type-tuple-empty]
      [exp/if c t [exp/do [list]]]]

    [[word ifs]]
    [let [s [size l]]
      [assert-not [is-odd s] ifs requires an odd number of arguments]
      [loop
        [i [dec s]
         res [form-to-exp-type-kind-env type-kind-env lctx [at l -1]]]
        [if [eq i 1]
          res
          [continue
            res
            [exp/if
              [form-to-exp-type-kind-env type-kind-env lctx [at l [sub i 2]]]
              [form-to-exp-type-kind-env type-kind-env lctx [at l [dec i]]]
              res]
            i [sub i 2]]]]]

    [[word and]]
    [let
      [clauses [rest l]
       s [size clauses]
       expanded
        [if [is-zero s]
          [quote [i32 1]]
          [loop
            [i [dec s]
            res [at clauses -1]]
            [if [eq i 0]
              res
              [continue
                res [flist [quote if] [at clauses [dec i]] res [quote [i32 0]]]
                i [dec i]]]]]]
      [form-to-exp-type-kind-env type-kind-env lctx expanded]]

    [[word or]]
    [let
      [clauses [rest l]
       s [size clauses]
       expanded
        [if [is-zero s]
          [quote [i32 0]]
          [loop [i [dec s] res [at clauses -1]]
            [if [eq i 0]
              res
              [continue
                res
                [let [w [genword]]
                  [flist [quote let] [flist w [at clauses [dec i]]]
                    [flist [quote if] w w res]]]
                i [dec i]]]]]]
      [form-to-exp-type-kind-env type-kind-env lctx expanded]]

    [[word cast]]
    [exp/cast [form-to-type-type-env type-kind-env lctx [second l]] [form-to-exp-type-kind-env type-kind-env lctx [third l]]]

    [[word annotation]]
    [exp/annotation [form-to-type-type-env type-kind-env lctx [second l]] [form-to-exp-type-kind-env type-kind-env lctx [third l]]]

    [[word deref]]
    [exp/deref [form-to-exp-type-kind-env type-kind-env lctx [second l]]]

    [[word assign]]
    [let [dst [form-to-exp-type-kind-env type-kind-env lctx [second l]]
          src [form-to-exp-type-kind-env type-kind-env lctx [third l]]
          tdst [type-of dst]
          tsrc [type-of src]]
      [when-not [type-assignable tdst tsrc]
        [logq dst [identity tdst]]
        [logq src [identity tsrc]]
        [logq-abort typing assign failed [identity fw] [identity l]]]
      [exp/assign dst src]]

    [[word passign] [word pinit]]
    [let [dst [form-to-exp-type-kind-env type-kind-env lctx [second l]]
          src [form-to-exp-type-kind-env type-kind-env lctx [third l]]
          tdst [pair/snd [get-pointer-args [type-of dst]]]
          tsrc [type-of src]
          is-init [eq-word [word pinit] fw]]
      [when-not [type-assignable tdst tsrc]
        [logq-abort typing [identity fw] failed [identity l]]]
      [when is-init
        [when-not [type-assignable tsrc tdst]
          [logq-abort pinit did not init all data]]]
      [exp/passign is-init dst src]]

    [[word intrinsic]]
    [let [intrinsic-name [form-to-name [second l]]
          arg-forms [slice l 2 [size l]]
          it [intrinsic-type-from-name [name/word intrinsic-name]]
          imm-params [intrinsic-type/immediate-parameters it]
          params [intrinsic-type/parameters it]
          arity-imm [size imm-params]
          arity-exp [size params]
          arity-total [add arity-imm arity-exp]
          gimm-args [growable-list]
          gargs [growable-list]]
      [assert [eq arity-total [size arg-forms]] intrinsic
        [identity intrinsic-name] expected [identity arity-total] arguments but got [size arg-forms]]
      [for i 0 arity-imm
        [let [p [at imm-params i]
              arg-form [at arg-forms i]]
          [todo assert arg is constant]
          [match p
            [immediate-type/memory]
            [let [mem-name [form-to-name arg-form]]
              [get-mem-type [name/word mem-name]]
              [push gimm-args [imm-arg/memory mem-name]]]]]]
      [for i 0 arity-exp
        [let [p [at params i]
              arg-form [at arg-forms [add arity-imm i]]
              arg [form-to-exp-type-kind-env type-kind-env lctx arg-form]
              ta [type-of arg]]
          [assert [type-assignable p ta] intrinsic [identity intrinsic-name] expected [identity p] but got [identity ta]]
          [push gargs arg]]]
      [exp/intrinsic
        intrinsic-name
        [clone-growable-to-frozen-list gimm-args]
        [clone-growable-to-frozen-list gargs]]]

    [[word let] [word loop]]
    [let
      [vars [transient-kv-map]
       is-let [eq-word fw [word let]]
       lck [if is-let [local-context-kind/let] [local-context-kind/loop]]
       local-var-counts [get-enclosing-func-context lctx]
       add-var
       [func av [n t]
        [let
          [nw [name/word n]
           wat-name
           [if-let [c [try-get local-var-counts nw]]
            [do
              [set-kv-map local-var-counts nw [inc c]]
              [concat-words nw [int-to-word c]]]
            [do
              [set-kv-map local-var-counts nw 1]
              nw]]
           ldesc [local-var-desc t wat-name]]
          [set-kv-map name-to-desc n [name-desc t [desc-kind/local [local-name-desc lck ldesc]]]]
          [set-kv-map vars nw ldesc]]]
       let-loop-ctx [local-context-make lctx vars lck]]
      [exp/let-loop
        [if is-let [let-or-loop/let] [let-or-loop/loop]]
        [list-map p [pairwise-pairs-check [get-list [second l]]]
          [let [pexp [form-to-exp-type-kind-env type-kind-env let-loop-ctx [pair/snd p]]
                types [get-tuple-type-elements [type-of pexp]]]
            [match [pair/fst p]
              [form/word -]
              [let [pname [form-to-name [pair/fst p]]]
                [assert [eq [size types] 1] [identity fw] expected 1 element tuple [identity pname]]
                [add-var pname [first types]]
                [pair [list pname] pexp]]

              [form/list pname-forms]
              [let [pnames [list-map pf pname-forms [form-to-name pf]]]
                [assert [eq [size pnames] [size types]] [identity fw] expected same number of names as types [identity pnames] [identity types]]
                [for i 0 [size pnames]
                  [add-var [at pnames i] [at types i]]]
                [pair pnames pexp]]]]]
        [list-map b [slice l 2 [size l]] [form-to-exp-type-kind-env type-kind-env let-loop-ctx b]]]]

    [[word continue]]
    [if-let [loop-vars [try-get-enclosing-loop-context lctx]]
      [do
        [assert [is-odd [size l]] expected pairs of assignments]
        [exp/continue
        [list-map p [pairwise-pairs-check [rest l]]
          [let [n [form-to-name [pair/fst p]]
                e [form-to-exp-type-kind-env type-kind-env lctx [pair/snd p]]]
            [if-let [ldesc [try-get loop-vars [name/word n]]]
              [do
                [assert [type-assignable [local-var-desc/type ldesc] [type-of e]] continue expected assignable type [identity n] [identity ldesc] [type-of e]]
                [set-kv-map name-to-desc n [name-desc [local-var-desc/type ldesc] [desc-kind/local [local-name-desc [local-context-kind/loop] ldesc]]]]]
              [logq-abort continue not a loop var]]
            [pair n e]]]]]
      [logq-abort continue not in loop]]

    [[word func]]
    [let
      [vars [transient-kv-map]
       param-ctx [local-context-make-func vars]
       params
       [list-map p [pairwise-pairs-check [get-list [second l]]]
          [let [pname [form-to-name [pair/fst p]]
                pt [form-to-type-type-env type-kind-env lctx [pair/snd p]]]
            [set-param-desc vars pname pt]
            [pair pname pt]]]
       result [form-to-type-type-env type-kind-env param-ctx [third l]] ; todo should we pass lctx instead?
       bodies
       [list-map b [slice l 3 [size l]] [form-to-exp-type-kind-env type-kind-env param-ctx b]]
       tf [type-func [list] [list-map p params [pair/snd p]] result]]
      [exp/func [exp-function fw [option/none] tf [list-map p params [pair/fst p]] bodies]]]

    [[word do]]
    [exp/do [list-map b [rest l] [form-to-exp-type-kind-env type-kind-env lctx b]]]

    [[word size-of-type]]
    [exp/size-of-type [form-to-type-type-env type-kind-env lctx [second l]]]

    [[word size-of-exp]]
    [exp/size-of-exp [form-to-exp-type-kind-env type-kind-env lctx [second l]]]

    [[word pindex]]
    [exp/pindex
      [form-to-exp-type-kind-env type-kind-env lctx [second l]]
      [form-to-exp-type-kind-env type-kind-env lctx [third l]]]

    [[word pfield]]
    [let [pexp [form-to-exp-type-kind-env type-kind-env lctx [second l]]
          field-name [form-to-name [third l]]]
      [exp/pfield pexp field-name]]

    [[word offset-of]]
    [let [t [form-to-type-type-env type-kind-env lctx [second l]]
          field-name [form-to-name [third l]]]
      [match [expand-custom-n t]
        [type/record fields]
        [exp/offset-of t field-name]

        [logq-abort offset-of not a record [identity t]]]]

    [[word array]]
    [let [telem [form-to-type-type-env type-kind-env lctx [second l]]]
      [exp/array
        telem
        [list-map ef [slice l 2 [size l]]
          [let [ee [form-to-exp-type-kind-env type-kind-env lctx ef]
                t-cur-elem [type-of ee]]
            [when-not [type-assignable telem t-cur-elem]
              [logq-abort array expected assignable type
                [identity telem]
                [identity t-cur-elem]]]
            ee]]]]

    [[word text]]
    [let [gl [growable-list]
          w [form-to-word-report [second l]]]
      [for i 0 [word-byte-size w]
        [push gl [exp/integer type-primitive-u8 [i32-to-bigint [char-code-at w i]]]]]
      [exp/array type-u8 [clone-growable-to-frozen-list gl]]]

    [[word tuple]]
    [exp/tuple
      [list-map e [rest l] [form-to-exp-type-kind-env type-kind-env lctx e]]]

    [[word record]]
    [exp/record
      [list-map p [pairwise-pairs-check [rest l]]
        [pair [form-to-name [pair/fst p]] [form-to-exp-type-kind-env type-kind-env lctx [pair/snd p]]]]]

    [[word data]]
    [let
      [mem-name-exp [form-to-exp-type-kind-env type-kind-env lctx [second l]]
       data-exp [form-to-exp-type-kind-env type-kind-env lctx [third l]]]
      [exp/data mem-name-exp data-exp]]

    [[word memory-static-top]]
    [let
      [mem-name-exp [form-to-exp-type-kind-env type-kind-env lctx [second l]]]
      [get-memory-exp-type mem-name-exp]
      [exp/memory-static-top mem-name-exp]]

    [[word instantiate]]
    [exp/instantiate
      [form-to-exp-type-kind-env type-kind-env lctx [second l]]
      [list-map a [slice l 2 [size l]] [form-to-type-type-env type-kind-env lctx a]]]

    [[word reify]]
    [exp/reify [form-to-type-type-env type-kind-env lctx [second l]]]

    [if-let [pt [try-get primitive-types-by-name fw]]
      [let [n [form-to-name [second l]]]
        [switch [primitive-type/prefix pt]
          [[word i] [word u]]
          [let [i [word-to-bigint [name/word n]]
                range [primitive-integer-type-min-max-range pt]]
            [when [intrinsic bigint.lt-s i [pair/fst range]] [error [second l] literal below min]]
            [when [intrinsic bigint.lt-s [pair/snd range] i] [error [second l] literal above max]]
            [exp/integer pt i]]

          [[word f]]
          [let [f [word-to-f64 [name/word n]]]
            [todo range check on f32]
            [exp/float pt f]]

          [logq-abort unsupported literal type]]]
      [logq-abort form-special-to-exp not impl [identity fw]]]]]

[func get-name-desc-from-name [n]
  [if-let [desc [try-get name-to-desc n]]
    desc
    [logq-abort get-name-desc-from-name not found [name/word n]]]]

[func get-top-desc-from-name-desc [nd]
  [match [name-desc/kind nd]
    [desc-kind/top td] td
    [logq-abort get-top-desc-from-name-desc not a global]]]

[func get-local-desc-from-name-desc [nd]
  [match [name-desc/kind nd]
    [desc-kind/local ld] ld
    [logq-abort get-local-desc-from-name-desc not a local]]]

[func get-functor-desc-from-top-desc-kind [tdk]
  [match tdk
    [top-desc-kind/functor fd] fd
    [logq-abort not a functor]]]

[func get-functor-desc [fn]
  [get-functor-desc-from-top-desc-kind
    [top-desc/kind
      [get-top-desc-from-name-desc
        [get-name-desc-from-name fn]]]]]

[func names-same-binding [n1 n2]
  [and
    [eq-word [name/word n1] [name/word n2]]
    [let
      [d1 [name-desc/kind [get-name-desc-from-name n1]]
       d2 [name-desc/kind [get-name-desc-from-name n2]]]
      [match d1
        [desc-kind/local ld1]
        false

        [desc-kind/top td1]
        [match d2
          [desc-kind/top td2]
          [is-identical td1 td2]
          false]]]]]

[func exp-equals [e1 e2]
  [todo consider const evaling the two expressions]
  [match e1
    [exp/integer pt1 i1]
    [match e2
      [exp/integer pt2 i2]
      [and [is-identical pt1 pt2] [is-identical i1 i2]]

      false]

    [exp/var n1]
    [match e2
      [exp/var n2]
      [names-same-binding n1 n2]
      false]
    false]]

[func type-assignable [tdst tsrc]
  [match [go-tai [transient-kv-map] tdst tsrc]
    [result/ok -] true
    [result/error err]
    [do
      [log err]
      false]]]

[func go-tais [tenv dargs sargs]
  [assert [eq [size dargs] [size sargs]] equal num of types]
  [loop [i 0 n [size dargs] cur-tenv tenv]
    [if [lt-s i n]
      [result-bind
        [go-tai cur-tenv [at dargs i] [at sargs i]]
        ntenv
        [continue i [inc i] cur-tenv ntenv]]
      [result/ok cur-tenv]]]]

[func go-tai [tenv param-t arg-t]
  [match param-t
    [type/primitive dpt]
    [match [expand-custom-n arg-t]
      [type/pointer mt t]
      [if [is-identical dpt [get-memory-pointer-type mt]]
        [result/ok tenv]
        [result/error [qlist pointer type doesnt match]]]

      [type/exp se]
      [match se
        [exp/integer spt -]
        [if [is-identical dpt spt]
          [result/ok tenv]
          [result/error [qlist primitive type does not match exp]]]

        [result/error [qlist primitive only integer supported]]]

      [type/primitive spt]
      [if
        [or
          [is-identical dpt spt]
          [and [primitive-type-is-integer dpt] [primitive-type-is-integer spt]]]
        [result/ok tenv]
        [result/error [qlist primitive type does not match]]]

      [result/error [qlist primitive type does not match]]]

    [type/var n]
    [do
      [if-let [bound [try-get tenv [name/word n]]]
        [if [type-assignable bound arg-t]
          [result/ok tenv]
          [result/error [qlist type-assignable-infer expected assignable type [identity bound] [identity arg-t]]]]
        [let [ctenv [kv-map-copy tenv]]
          [set-kv-map ctenv [name/word n] arg-t]
          [result/ok ctenv]]]]

    [type/wildcard -]
    [result/ok tenv]

    [type/pointer dmem dtarget]
    [match [expand-custom-n arg-t]
      [type/pointer smem starget]
      [result-bind [go-tai tenv dmem smem] nenv [go-tai nenv dtarget starget]]

      [result/error [qlist type-assignable-infer not a pointer]]]

    [type/exp e]
    [match [expand-custom-if-non-rec arg-t]
      [type/exp ae]
      [if [exp-equals e ae]
        [result/ok tenv]
        [result/error [qlist type-assignable-infer type/exp expected same type]]]

      [result/error [qlist type-assignable-infer not an exp [identity arg-t]]]]

    [type/array det dopts]
    [match arg-t
      [type/array set sopts]
      [let [elems-ass [go-tai tenv det set]]
        [match dopts
          [option/none]
          elems-ass

          [option/some ds]
          [if-let [ss sopts]
            [result-bind elems-ass nenv [go-tai nenv ds ss]]
            elems-ass]]]

        [result/error [qlist type-assignable-infer not an array]]]

    [type/tuple dts]
    [match arg-t
      [type/tuple sts]
      [if [lt-s [size dts] [size sts]]
        [result/error [qlist fewer tuple elements in destination than in source]]
        [go-tais tenv dts sts]]

      [result/error [qlist not a tuple [identity arg-t]]]]

    [type/union dus]
    [match arg-t
      [type/union sus]
      [do
        [assert [eq [size dus] [size sus]] union sizes do not match]
        [go-tais tenv dus sus]]

      [type/apply-custom stn sargs]
      [go-tai tenv param-t [expand-custom-n arg-t]]

      [loop [i 0 n [size dus]]
        [if [lt-s i n]
          [let [res [go-tai tenv [at dus i] arg-t]]
            [match res
              [result/error -] [continue i [inc i]]
              [result/ok -] res]]
          [result/error [qlist no union match]]]]]

    [type/record dfs]
    [match arg-t
      [type/record sfs]
      [if [lt-s [size dfs] [size sfs]]
        [result/error [qlist fewer fields in destination than in source]]
        [loop [i 0 n [size sfs] cur-tenv tenv]
          [if [lt-s i n]
            [let [df [at dfs i] sf [at sfs i]]
              [if [eq-word [name/word [pair/fst df]] [name/word [pair/fst sf]]]
                [result-bind
                  [go-tai cur-tenv [pair/snd df] [pair/snd sf]]
                  nenv
                  [continue i [inc i] cur-tenv nenv]]
                [result/error [qlist not same field names]]]]
            [result/ok cur-tenv]]]]

      [type/apply-custom stn sargs]
      [go-tai tenv param-t [expand-custom-1 stn sargs]]

      [result/error [qlist not a record [identity arg-t]]]]

    [type/apply-custom ptn pargs]
    [match arg-t
      [type/apply-custom atn aargs]
      [if [eq-word [name/word ptn] [name/word atn]]
        [go-tais tenv pargs aargs]
        [go-tai tenv [expand-custom-n param-t] [expand-custom-n arg-t]]]

      [go-tai tenv [expand-custom-n param-t] arg-t]]

    [result/error [qlist type-assignable-infer not impl [identity param-t] [identity arg-t]]]]]

[func types-equal [ts1 ts2]
  [and
    [eq [size ts1] [size ts2]]
    [loop [i 0 n [size ts1]]
      [if [lt-s i n]
        [if [type-equals [at ts1 i] [at ts2 i]]
          [continue i [inc i]]
          false]
        true]]]]

[func type-equals [t1 t2]
  [or [is-identical t1 t2]
    [match t1
    [type/primitive p1]
    [match t2
      [type/primitive p2]
      [is-identical p1 p2]
      false]

    [type/tuple ts1]
    [match t2
      [type/tuple ts2]
      [types-equal ts1 ts2]
      false]

    [type/record ps1]
    [match t2
      [type/record ps2]
      [and
        [eq [size ps1] [size ps2]]
        [loop [i 0 n [size ps1]]
          [if [lt-s i n]
            [if [let [p1 [at ps1 i] p2 [at ps2 i]]
                  [and [eq-word [name/word [pair/fst p1]] [name/word [pair/fst p2]]]
                       [type-equals [pair/snd p1] [pair/snd p2]]]]
              [continue i [inc i]]
              false]
            true]]]
      false]

    [type/union ts1]
    [match t2
      [type/union ts2]
      [and
        [eq [size ts1] [size ts2]]
        [loop [i 0 n [size ts1]]
          [if [lt-s i n]
            [if [type-equals [at ts1 i] [at ts2 i]]
              [continue i [inc i]]
              false]
            true]]]
      false]

    [type/pointer m1 t1]
    [match t2
      [type/pointer m2 t2]
      [and
        [type-equals m1 m2]
        [type-equals t1 t2]]
      false]

    [type/exp e1]
    [match t2
      [type/exp e2]
      [exp-equals e1 e2]
      false]

    [type/array t1 opt-s1]
    [match t2
      [type/array t2 opt-s2]
      [and
        [type-equals t1 t2]
        [match opt-s1
          [option/none]
          [match opt-s2
            [option/none]
            true

            [option/some s2]
            false]

          [option/some s1]
          [match opt-s2
            [option/none]
            false

            [option/some s2]
            [type-equals s1 s2]]]]
      false]

    [type/var n1]
    [match t2
      [type/var n2]
      [eq-word [name/word n1] [name/word n2]]
      false]

    [type/apply-custom tn1 args1]
    [match t2
      [type/apply-custom tn2 args2]
      [if [eq-word [name/word tn1] [name/word tn2]]
        [types-equal args1 args2]
        [type-equals [expand-custom-if-non-rec t1] [expand-custom-if-non-rec t2]]]

      [type-equals [expand-custom-if-non-rec t1] t2]]

    [logq-abort type-equals [identity t1] [identity t2]]]]]

[func type-ofs [bodies]
  [if [is-empty bodies]
    type-tuple-empty
    [type-of [last bodies]]]]

[func expand-custom-1 [type-name args]
  [let
    [type-name-word [name/word type-name]
     type-params [type-signature/params [get custom-type-signatures type-name-word]]
     - [assert [eq [size args] [size type-params]] expand-custom-1 expected same number of arguments]
     canon-type [type-desc/canonical-type [get custom-types type-name-word]]]
    [if [is-empty args]
      canon-type
      [let [tenv [transient-kv-map]]
        [for i 0 [size args]
          [set-kv-map tenv [name/word [pair/fst [at type-params i]]] [at args i]]]
        [type-substitute tenv canon-type]]]]]

[func type-recursive-is [tn]
  [set-has custom-types-recursive [name/word tn]]]

[func expand-custom-if-non-rec [targ]
  [match targ
    [type/apply-custom type-name args]
    [let [type-name-word [name/word type-name]]
      [if [set-has custom-types-recursive type-name-word]
        targ
        [expand-custom-1 type-name args]]]

    targ]]

[func expand-custom-n [targ]
  [match targ
    [type/apply-custom type-name args]
    [expand-custom-n [expand-custom-1 type-name args]]

    targ]]

[func make-type-env [parameter-names targs]
  [assert [eq [size parameter-names] [size targs]] make-type-env expected same number of arguments
    [identity parameter-names] [identity targs]]
  [let [functor-type-env [transient-kv-map]]
    [for i 0 [size targs]
      [set-kv-map functor-type-env [at parameter-names i] [at targs i]]]
    functor-type-env]]

[func functor-desc-to-type-env [fd targs]
  [assert [eq [size targs] [size [functor-desc/parameters fd]]] call-functor expected same number of arguments]
  [let [functor-type-env [transient-kv-map]]
    [for i 0 [size targs]
      [set-kv-map functor-type-env [name/word [pair/fst [at [functor-desc/parameters fd] i]]] [at targs i]]]
    functor-type-env]]

[func get-field-type [t field-name-word]
  [match t
    [type/record field-types]
    [loop [n [size field-types]
            i 0]
      [if [lt-s i n]
        [let [fp [at field-types i]]
          [if [eq-word [name/word [pair/fst fp]] field-name-word]
            [pair/snd fp]
            [continue i [inc i]]]]
        [logq-abort field not found [identity field-name-word] [identity field-types]]]]

    [type/union utypes]
    [if [is-empty utypes]
      type-empty
      [loop [i 1 n [size utypes] field-type [get-field-type [first utypes] field-name-word]]
        [if [lt-s i n]
          [do
            [logq common-super-type get-field-type]
            [continue
              field-type [common-super-type field-type [get-field-type [at utypes i] field-name-word]]
              i [inc i]]]
          field-type]]]

    [type/apply-custom tn args]
    [get-field-type [expand-custom-1 tn args] field-name-word]

    [logq-abort get-field-type not implemented field [identity t]]]]

[func get-index-type [t index-exp]
  [match t
    [type/array elem-type -]
    elem-type

    [type/tuple elem-types]
    [match index-exp
      [exp/integer pt i]
      [do
        [assert [is-identical pt type-primitive-i32] index expected i32]
        [at elem-types [bigint-to-i32 i]]]

      [logq-abort indexing of tuples only allowed with constants [identity index-exp]]]
    [logq-abort indexing only allowed for array and tuple types [identity t]]]]

[func get-pointer-args [t]
  [match [expand-custom-n t]
    [type/pointer m p]
    [pair m p]

    [logq-abort get-pointer-args not a pointer [identity t]]]]

[func get-function-type [t]
  [match [expand-custom-n t]
    [type/func tf]
    tf

    [logq-abort get-function-type not a func [identity t]]]]

[func get-tuple-type-elements [t]
  [let [et [expand-custom-n t]]
    [match et
      [type/tuple es]
      es

      [list et]]]]

[func type-of [exp]
  [match exp
    [exp/integer pt n]
    [type/primitive pt]

    [exp/float pt f]
    [type/primitive pt]

    [exp/if c t e]
    [common-super-type [type-of t] [type-of e]]

    [exp/call fexp args]
    [match [type-of fexp]
      [type/func tf]
      [let [tps [type-func/type-parameters tf]]
        [if [is-empty tps]
          [type-func/result tf]
          [match [go-tais [transient-kv-map] [type-func/parameters tf] [list-map arg args [type-of arg]]]
            [result/ok tenv] [type-substitute tenv [type-func/result tf]]
            [result/error -] [do

;              [log-location [exp-location exp]]
              [logq-abort type-of call args not assignable [identity fexp] [identity tf] [identity args]]]]]]

      [logq-abort not a func]]

    [exp/instantiate fexp targs]
    [match [type-of fexp]
      [type/func tf]
      [let
        [tenv [make-type-env [list-map tpn [type-func/type-parameters tf] [name/word [pair/fst tpn]]] targs]]
        [type-substitute tenv [type/func [type-func [list] [type-func/parameters tf] [type-func/result tf]]]]]

      [logq-abort not a value [type-of fexp]]]

    [exp/call-functor fname targs]
    [let [fd [get-functor-desc fname]]
      [type-substitute [functor-desc-to-type-env fd targs] [type-of [functor-desc/body fd]]]]

    [exp/cast t e]
    t

    [exp/annotation t e]
    t

    [exp/var n]
    [name-desc/type [get-name-desc-from-name n]]

    [exp/intrinsic intrinsic-name imm-args args]
    [intrinsic-type/result [intrinsic-type-from-name [name/word intrinsic-name]]]

    [exp/deref target]
    [match [expand-custom-n [type-of target]]
      [type/pointer - t]
      t
      [logq-abort type-of not a pointer [identity target] [type-of target]]]

    [exp/assign dst src]
    type-tuple-empty

    [exp/passign -is-init dst src]
    type-tuple-empty

    [exp/let-loop ll-kind bindings bodies]
    [type-ofs bodies]

    [exp/continue bindings]
    type-empty

    [exp/do bodies]
    [type-ofs bodies]

    [exp/size-of-type -t]
    type-i32

    [exp/size-of-exp -e]
    type-i32

    [exp/pindex p-target-exp index-exp]
    [let
      [pp [get-pointer-args [type-of p-target-exp]]]
      [type/pointer [pair/fst pp] [get-index-type [pair/snd pp] index-exp]]]

    [exp/pfield p-rec-exp field-name]
    [let
      [pp [get-pointer-args [type-of p-rec-exp]]]
      [type/pointer [pair/fst pp] [get-field-type [pair/snd pp] [name/word field-name]]]]

    [exp/offset-of -t -field-name]
    type-i32

    [exp/array elem-type elems]
    [type/array
      elem-type
      [option/some [type/exp [exp/integer type-primitive-i32 [i32-to-bigint [size elems]]]]]]

    [exp/tuple elems]
    [if [eq [size elems] 1]
      [type-of [first elems]]
      [type/tuple [list-map e elems [type-of e]]]]

    [exp/record pairs]
    [type/record [list-map p pairs [pair [pair/fst p] [type-of [pair/snd p]]]]]

    [exp/data mem-name data-exp]
    [type/pointer [type/exp mem-name] [type-of data-exp]]

    [exp/memory-static-top mem-name-exp]
    [type/primitive [get-memory-exp-type mem-name-exp]]

    [exp/func ef]
    [type/func [exp-function/type ef]]

    [exp/reify t]
    [match t
      [type/var sz]
      [match [get type-var-name-to-kind sz]
        [type-kind/exp t] t

        [logq-abort reify not an exp [identity t]]]]

    [logq-abort type-of not implemented [identity exp]]]]

[func form-list-to-mem-exp [l]
  [assert [or [eq [size l] 3] [eq [size l] 4]] memory expected 3 or 4 elements]
  [let
    [mt [form-to-type [second l]]
     init-size-name [form-to-name [third l]]
     init-size [word-to-int [name/word init-size-name]]
     - [assert [lt-s 0 init-size] memory init-size must be greater than or equal to 0]
     opt-max
     [if [eq [size l] 3]
       [option/none]
       [let [n [form-to-name [fourth l]] ms [word-to-int [name/word n]]]
        [assert [lt-s init-size ms] memory max-size must be greater than init-size]
        [option/some n]]]]
    [todo check type and size parse and are consistent]
    [match mt
      [type/primitive mpt]
      [do
        [assert [or [type-equals mt type-i32] [type-equals mt type-i64]] memory expected i32 or i64]
        [memory-exp mpt init-size-name opt-max]]
      [logq-abort not implemented memory type [identity mt]]]]]

[func form-to-import-kind [form]
  [let [l [get-list form]]
    [assert-not [is-empty l] form-to-import-kind expected non-empty list]
    [switch [form-to-word-report [first l]]
      [[word memory]]
      [import-kind-decl/memory [form-list-to-mem-exp l]]

      [[word func]]
      [do
        [assert [eq [size l] 3] import func expected 2 elements]
        [import-kind-decl/function
          [list-map pp [pairwise-pairs-check [get-list [second l]]]
            [pair [form-to-name [pair/fst pp]] [form-to-type [pair/snd pp]]]]
          [form-to-type [third l]]]]

      [logq-abort not implemented import-kind [first l]]]]]

[func bind-top [name type desc]
  [let
    [w [name/word name]]
    [set-kv-map name-to-desc name [name-desc type [desc-kind/top desc]]]
    [when [has top-names w]
      [error-name name name already defined]]
    [set-kv-map top-names w [pair type desc]]]]

[func form-to-type-kind [form]
  [match form
    [form/word w]
    [switch w
      [[word datatype]] type-kind-datatype
      [logq-abort type unknown kind]]

    [form/list ll]
    [switch [form-to-word-report [first ll]]
      [[word exp]] [type-kind/exp [form-to-type [second ll]]]
      [logq-abort type unknown kind]]]]

[func try-resolve-constant [exp]
  [match exp
    [exp/var n]
    [if-let [desc [try-get name-to-desc n]]
      [let [t [name-desc/type desc]]
        [match [name-desc/kind desc]
          [desc-kind/top td]
          [match [top-desc/kind td]
            [top-desc-kind/value vd]
            [if [is-identical [value-desc/kind vd] value-kind-constant]
              [option/some [get value-constants [name/word n]]]
              [option/none]]
            [option/none]]

          ; default
          [option/none]]]
      [logq-abort try-resolve-constant name not found [identity n]]]
    [option/none]]]

[func expand-custom-non-rec [param-map]
  [func go-ecnr [t]
    [match t
      [type/primitive -]
      t

      [type/var n]
      [do
        [if-let [tk [try-get param-map [name/word n]]]
;          [when-not [is-identical tk type-kind-datatype]
;            [logq-abort expand-custom-non-rec not datatype [identity tk]]]
          [do]
          [logq-abort expand-custom-non-rec not found [identity n]]]
        t]

      [type/wildcard -]
      t

      [type/pointer tm tt]
      [type/pointer [go-ecnr tm] [go-ecnr tt]]

      [type/array et opt-s]
      [type/array [go-ecnr et] [option-map go-ecnr opt-s]]

      [type/tuple ts]
      [type/tuple [list-map tt ts [go-ecnr tt]]]

      [type/record fields]
      [type/record [list-map fp fields [pair [pair/fst fp] [go-ecnr [pair/snd fp]]]]]

      [type/union utypes]
      ; merge union of unions, and sort the types...
      [type/union [list-map ut utypes [go-ecnr ut]]]

      [type/exp -]
      t

      [type/func -]
      [logq-abort func not allowed in datatype]

      [type/functor - --]
      [logq-abort functor not allowed in datatype]

      [type/apply-custom type-name args]
      [let
        [type-name-word [name/word type-name]
         type-params [type-signature/params [get custom-type-signatures type-name-word]]]
        [assert [eq [size args] [size type-params]] expand-custom-non-rec type arity mismatch]
        [if-let [custom-type-desc [try-get custom-types type-name-word]]
          [let [canon-type [type-desc/canonical-type custom-type-desc]]
            [if [is-empty args]
              canon-type
              [let [tenv [transient-kv-map]]
                [for i 0 [size args]
                  [set-kv-map tenv [name/word [pair/fst [at type-params i]]] [go-ecnr [at args i]]]]
                [type-substitute tenv canon-type]]]]
            ; we cannot expand recursive types as it would never finish
            [do
              [logq type is recursive [identity type-name-word]]
              [set-add custom-types-recursive type-name-word]
              [type/apply-custom type-name [list-map a args [go-ecnr a]]]]]]

      [logq-abort expand-custom-non-rec not implemented [identity t]]]]]

[func top-forms-to-top-decls [forms]
  [let
    [top-decls [growable-list]]
    [for-each form forms
    [let [l [get-list form]]
    [if [is-empty l]
      [error form expected non-empty list]
      [let [f [first l]
            fw [get-word f]]
        [when [has top-names fw]
          [error f top-level calls not yet implemented]]
        [switch fw
          [[word def] [word mutable]]
          [do
            [when-not [eq [size l] 3] [error form expected def name exp-form]]
            [let
              [name-form [second l]
               fname [form-to-name name-form]
               be [form-to-exp-type-kind-env empty-type-env local-context-empty [third l]]
               is-mutable [eq-word fw [word mutable]]
               kind [if is-mutable value-kind-mutable value-kind-constant]
               resolved-be [if-let [c [[exp-eval [transient-kv-map] [transient-kv-map]] be]] c be]]
              [when-not is-mutable
                [set-kv-map value-constants [name/word fname] resolved-be]]
              [bind-top fname
                [type-of be]
                [top-desc [top-desc-kind/value [value-desc kind]] [imported-or-here/here]]]
              [push top-decls [top-decl/value kind fname resolved-be]]]]

          [[word memory]]
          [let [mem-name [form-to-name [second l]]
                mem-exp [form-list-to-mem-exp [rest l]]]
            [bind-top mem-name
              [type/memory mem-name]
              [top-desc [top-desc-kind/memory [mem-exp-to-mem-kind mem-exp]] [imported-or-here/here]]]
            [push top-decls [top-decl/memory mem-name mem-exp]]]

          [[word export]]
          [push top-decls
            [top-decl/export
              [list-map fe [rest l]
                [let [n [form-to-name fe]]
                  [lookup-bind-name local-context-empty n]
                  n]]]]

          [[word datatype]]
          [let [type-desc-list [growable-list]]
            [for-3 i 1 [size l]
              [let
                [type-name-word [form-to-word-report [at l i]]
                 param-form [at l [inc i]]
                 param-map [transient-kv-map]
                 type-params
                 [list-map param-pair [pairwise-pairs-check [get-list param-form]]
                  [let [pn [form-to-name [pair/fst param-pair]]
                        pk [form-to-type-kind [pair/snd param-pair]]]
                    [set-kv-map param-map [name/word pn] pk]
                    [pair pn pk]]]]
                [set-kv-map custom-type-signatures type-name-word [type-signature type-kind-datatype type-params param-map]]]]
            [for-3 i 1 [size l]
              [let
                [type-name-word [form-to-word-report [at l i]]
                 type-sig [get custom-type-signatures type-name-word]
                 param-map [type-signature/param-map type-sig]]
                [let
                  [datatype [form-to-type-type-env param-map local-context-empty [at l [add 2 i]]]
                   ed [[expand-custom-non-rec param-map] datatype]]
                  [todo check type has datatype kind and parameters inside does]
                  [push type-desc-list [pair type-name-word [type-desc datatype ed]]]]]]
            [for-each p [clone-growable-to-frozen-list type-desc-list]
              [set-kv-map custom-types [pair/fst p] [pair/snd p]]]]

          [[word import]]
          [let
            [mod-name [form-to-name [second l]]
             import-exps
              [list-map import [slice l 2 [size l]]
                [let [
                  import-list [get-list import]
                  m [form-to-name [first import-list]]
                  ik [form-to-import-kind [second import-list]]
                  t
                  [match ik
                    [import-kind-decl/function ps rt]
                    [type/func [type-func [list] [list-map p ps [pair/snd p]] rt]]

                    [import-kind-decl/memory mem-exp]
                    [type/memory m]

                    [logq-abort not implemented type-of import]]
                  ikd
                  [match ik
                    [import-kind-decl/function ps rt]
                    [top-desc-kind/value [value-desc value-kind-constant]]

                    [import-kind-decl/memory mem-exp]
                    [top-desc-kind/memory [mem-exp-to-mem-kind mem-exp]]

                    [logq-abort not implemented type-of import]]]
                  [bind-top m t [top-desc ikd [imported-or-here/imported]]]
                  [pair m ik]]]]
            [push top-decls [top-decl/import mod-name import-exps]]]

          [[word functor]]
          [do
            [when-not [eq [size l] 4] [error form expected functor name params return-type bodies]]
            [let
              [name-form [second l]
               type-params-list [get-list [third l]]
               result-form [fourth l]
               tparam-ctx [transient-kv-map]
               tparameters
               [list-map p [pairwise-pairs-check type-params-list]
                 [let [pname [form-to-name [pair/fst p]]
                       pkind [form-to-type-kind [pair/snd p]]]
                  [set-kv-map tparam-ctx [name/word pname] pkind]
                  [pair pname pkind]]]
               exp [form-to-exp-type-kind-env tparam-ctx local-context-empty result-form]]
              [bind-top [form-to-name name-form]
                [type/functor tparameters [type-of exp]]
                [top-desc
                  [top-desc-kind/functor [functor-desc tparameters exp]]
                  [imported-or-here/here]]]]]

          [[word defn] [word def-comp-fn]]
          [do
            [when [lt-s [size l] 3]
              [error form function expected name params return-type bodies]]
            [let
              [name-form [second l]
               fname [form-to-name name-form]
               is-defn [eq-word fw [word defn]]
               params-list [get-list [third l]]
               return-type-form [fourth l]
               param-pairs [pairwise-pairs-check params-list]
               param-names [list-map p param-pairs [form-to-name [pair/fst p]]]
               param-types [list-map p param-pairs [form-to-type [pair/snd p]]]
               return-type [form-to-type return-type-form]
               tf [type-func [list] param-types return-type]
               param-ctx [transient-kv-map]
               lctx [local-context-make-func param-ctx]]
              [bind-top fname
                [type/func tf]
                [top-desc
                  [top-desc-kind/value [value-desc value-kind-constant]]
                  [imported-or-here/here]]]
              [for i 0 [size param-names]
                [set-param-desc param-ctx [at param-names i] [at param-types i]]]
              [let
                [cbodies [list-map body [slice l 4 [size l]] [form-to-exp-type-kind-env empty-type-env lctx body]]
                 inferred-return-type [type-ofs cbodies]
                 exp-func [exp-function fw [option/some fname] tf param-names cbodies]]
                [set-kv-map top-funcs [name/word fname] exp-func]
                [match [go-tai [transient-kv-map] return-type inferred-return-type]
                  [result/ok -] [do]
                  [result/error error] [do [log error]
                    [log return-type]
                    [log inferred-return-type]
                    [logq-abort [identity fw] error in return type [name/word fname]]]]
                [when is-defn
                  [push top-decls [top-decl/function exp-func]]]]]]

          [[word genfn] [word comptimefn]]
          [do
            [when [lt-s [size l] 4]
              [error form expected genfn name params bodies]]
            [let
              [name-form [second l]
               type-params-list [get-list [third l]]
               params-list [get-list [fourth l]]
               return-type-form [at l 4]
               tparam-ctx [transient-kv-map]
               tparameters
               [list-map p [pairwise-pairs-check type-params-list]
                 [let [pname [form-to-name [pair/fst p]]
                       pkind [form-to-type-kind [pair/snd p]]]
                  [set-kv-map tparam-ctx [name/word pname] pkind]
                  [pair pname pkind]]]
               param-pairs [pairwise-pairs-check params-list]
               param-names [list-map p param-pairs [form-to-name [pair/fst p]]]
               param-types [list-map p param-pairs [form-to-type-type-env tparam-ctx local-context-empty [pair/snd p]]]
               return-type [form-to-type-type-env tparam-ctx local-context-empty return-type-form]
               tf [type-func tparameters param-types return-type]
               param-ctx [transient-kv-map]
               lctx [local-context-make-func param-ctx]
               fname [form-to-name name-form]]
              [bind-top fname
                [type/func tf]
                [top-desc
                  [top-desc-kind/value [value-desc value-kind-constant]]
                  [imported-or-here/here]]]
              [for i 0 [size param-names]
                [set-param-desc param-ctx [at param-names i] [at param-types i]]]
              [let
                [cbodies [list-map body [slice l 5 [size l]] [form-to-exp-type-kind-env tparam-ctx lctx body]]
                 inferred-return-type [type-ofs cbodies]
                 exp-func [exp-function fw [option/some fname] tf param-names cbodies]]
                [set-kv-map top-funcs [name/word fname] exp-func]
                [match [go-tai [transient-kv-map] return-type inferred-return-type]
                  [result/ok -] [do]
                  [result/error error] [do [log error] [logq-abort error in genfn return type]]]
                [do]]]]

          [logq-abort not implemented [identity fw]]]]]]]
    [clone-growable-to-frozen-list top-decls]]]

[func lift-primitive [p]
  [if [primitive-is-wasm-value-type p]
    p
    [if [primitive-type-is-integer p]
      type-primitive-i64
      [logq-abort not implemented lift-primitive [identity p]]]]]

[func type-to-wat-type [t]
  [primitive-type/name
    [match [expand-custom-n t]
      [type/primitive p]
      [lift-primitive p]

      [type/exp e]
      [match e
        [exp/integer pt -]
        [lift-primitive pt]

        [logq-abort not implemented type-to-wat-type [identity e]]]

      [type/pointer mt -]
      [get-memory-pointer-type mt]

      [logq-abort type-to-wat-type [identity t]]]]]

[func type-to-wat-types [type]
  [match [expand-custom-n type]
    [type/tuple types]
    [list-map t types [type-to-wat-type t]]

    [type/record fields]
    [list-map field fields [type-to-wat-type [pair/snd field]]]

    [type/union types]
    [if [is-empty types]
      [list]
      [logq-abort not implemented type-to-wat-types [identity type]]]

    [list [type-to-wat-type type]]]]

[func try-get-primitive [type]
  [match [expand-custom-n type]
    [type/exp e]
    [match e
      [exp/integer pt -] [option/some pt]
      [exp/float pt -] [option/some pt]
      [exp/var n] [try-get-primitive [name-desc/type [get-name-desc-from-name n]]]
      [option/none]]
    [type/primitive p] [option/some p]
    [type/pointer mt -] [option/some [get-memory-pointer-type mt]]
    [option/none]]]

[func type-to-primitive [t]
  [if-let [pt [try-get-primitive t]]
    pt
    [logq-abort not a primitive type [identity t]]]]

[func type-to-size-of-exp [t]
  [match [expand-custom-n t]
    [type/primitive p]
    [mk-exp-i32-i32 [primitive-type/bytes p]]

    [type/exp e]
    [type-to-size-of-exp [type-of e]]

    [type/pointer mt t]
    [mk-exp-i32-i32 [primitive-type/bytes [get-memory-pointer-type mt]]]

    [type/array et opt-st]
    [if-let [size-type opt-st]
      [match size-type
        [type/exp size-exp]
        [int-exp-mul [type-to-size-of-exp et] size-exp]

        [logq-abort type-to-size-of-exp array size not an exp type [identity size-type]]]
      [logq-abort type-to-size-of-exp no size given [identity t]]]

    [type/tuple types]
    [loop [i 0
           n [size types]
           sum int-const-0]
      [if [lt-s i n]
        [continue
          sum [int-exp-add sum [type-to-size-of-exp [at types i]]]
          i [inc i]]
        sum]]

    [type/record fields]
    [loop [i 0
           n [size fields]
           sum int-const-0]
      [if [lt-s i n]
        [continue
          sum [int-exp-add sum [type-to-size-of-exp [pair/snd [at fields i]]]]
          i [inc i]]
        sum]]

    [logq-abort not implemented type-to-size-of-exp [identity t]]]]

[func infer-type-env-from-args [fexp type-env args]
  [let
    [tf
      [match [type-of fexp]
        [type/func tf] tf
        [logq-abort not a function]]
     type-parameters [type-func/type-parameters tf]]
    [if [is-empty type-parameters]
      [transient-kv-map]
      [match [go-tais [transient-kv-map] [type-func/parameters tf] [list-map arg args [type-substitute type-env [type-of arg]]]]
        [result/ok inferred-tenv]
        inferred-tenv

        [result/error -] [logq-abort exp-to-inst call args not assignable [identity fexp] [identity tf] [identity args]]]]]]

[func exp-eval [type-env const-param-env]
  [func ee [e]
    [match e
      [exp/integer - --]
      [option/some e]

      [exp/float pt f]
      [option/some e]

      [exp/var v]
      [match [name-desc/kind [get-name-desc-from-name v]]
        [desc-kind/top td]
        [try-get value-constants [name/word v]]

        [desc-kind/local ld]
        [match [local-name-desc/context-kind ld]
          ; it is a parameter
          [local-context-kind/func -]
          [do
            ; in def-comp-fn parameters are constants
            [try-get const-param-env [name/word v]]]

          [option/none]]]

      [exp/call fexp args]
      [let
        [tenv [infer-type-env-from-args fexp type-env args]
         efunc [get top-funcs [get-exp-var fexp]]]
        [if [eq-word [word comptimefn] [exp-function/kind efunc]]
          [let [params [exp-function/parameters efunc]
                param-env [transient-kv-map]]
            [assert [eq [size params] [size args]] call expected same number of arguments]
            [for i 0 [size args]
              [set-kv-map param-env [name/word [at params i]] [at args i]]]
            [let
              [nee [exp-eval tenv param-env]
               bodies [exp-function/bodies efunc]]
              [assert [eq 1 [size bodies]] only allow single body comp func]
              [nee [first bodies]]]]
          ; not comp time
          [option/none]]]

      [exp/cast - e]
      [ee e]

      [exp/annotation - ae]
      [ee ae]

      [exp/data mem-name-exp data-exp]
      [let
        [mem-name-word [get-exp-var mem-name-exp]
         bprinter [empty-printer]
         exp-to-bytes
          [func e2b [e]
            [match e
              [exp/integer pt n]
              [let [n-bytes [primitive-type/bytes pt]]
                [assert [eq [intrinsic i32.rem-s [printer-index bprinter] n-bytes] [i32 0]]
                  exp-to-bytes expected natural alignment [identity pt] [identity n]]
                [assert [primitive-type-is-integer pt] exp-to-bytes expected integer type [identity pt]]
                [print-bigint bprinter n-bytes n]]

              [exp/float pt f]
              [let [n-bytes [primitive-type/bytes pt]]
                [assert [eq [intrinsic i32.rem-s [printer-index bprinter] n-bytes] [i32 0]]
                  exp-to-bytes expected natural alignment [identity pt] ]
                [assert [eq-word [primitive-type/prefix pt] [word f]] exp-to-bytes expected float type [identity pt]]
                [loop
                  [i 0
                  fba [f64-to-byte-array f]]
                  [when [lt-s i n-bytes]
                    [print-byte bprinter [byte-array-get fba i]]
                    [continue i [inc i]]]]]

              [exp/array - es]
              ; todo we should check that the element size will make the array aligned
              [for-each elem es [e2b elem]]

              [exp/tuple es]
              [for-each elem es [e2b elem]]

              [exp/record fields]
              [for-each field fields [e2b [pair/snd field]]]

              [if-let [c [ee e]]
                [e2b c]
                [logq-abort not a constant [identity e]]]]]
         - [exp-to-bytes data-exp]
         bytes [printer-to-byte-array bprinter]
         n-of-bytes [byte-array-size bytes]
         offset-atom [get-memory-offset-atom mem-name-word]
         current-offset [atom-get offset-atom]]
        [assert-not [eq n-of-bytes 0] expected non-empty data]
        [atom-set offset-atom [add current-offset [memory-align n-of-bytes]]]
        [push datas [data-active mem-name-word current-offset bytes]]
        [option/some
          [exp/integer
            [get-mem-type mem-name-word]
            [i32-to-bigint current-offset]]]]

      [exp/reify t]
      [match [expand-custom-n [type-substitute type-env t]]
        [type/exp e]
        [ee e]
        [logq-abort not implemented exp-eval reify [identity t]]]

      [option/none]]]]

[func mk-exp-to-inst-compiler [type-env const-env]
  [let
    [glocals [growable-list]]
  [letfn [
[func type-to-size-of-exp-current-tenv [t]
  [type-to-size-of-exp [type-substitute type-env t]]]

[func calc-field-offset [t field-name-word]
  [match [expand-custom-n t]
    [type/record field-types]
    [loop [i 0
          res int-const-0
          n [size field-types]]
      [if [lt-s i n]
        [let [fp [at field-types i]]
          [if [eq-word [name/word [pair/fst fp]] field-name-word]
            res
            [continue
              res [int-exp-add res [type-to-size-of-exp-current-tenv [pair/snd fp]]]
              i [inc i]]]]
        [logq-abort field not found [identity field-name-word]]]]

    [type/union utypes]
    [if [is-empty utypes]
      [logq-abort union type empty does not allow field access]
      [let [first-offset [calc-field-offset [first utypes] field-name-word]]
        [loop [i 1 n [size utypes]]
          [if [lt-s i n]
            [let [fp [calc-field-offset [at utypes i] field-name-word]]
              [when-not [exp-equals first-offset fp]
                [logq-abort union type field offsets do not match]]
              [continue i [inc i]]]
            first-offset]]]]

    [logq-abort not implemented calc-field-offset [identity t]]]]

[func calc-index-offset [t index-exp]
  [match t
    [type/array elem-type -]
    [int-exp-mul index-exp [type-to-size-of-exp-current-tenv elem-type]]

    [type/tuple elem-types]
    [if-let [ie [try-get-int-const index-exp]]
      [let [n [size elem-types]]
        [assert [intrinsic bigint.lt-s ie [i32-to-bigint n]] index out of bounds]
        [loop [i 0 acc int-const-0]
          [if [is-identical ie [i32-to-bigint i]]
            acc
            [continue
              acc [int-exp-add acc [type-to-size-of-exp-current-tenv [at elem-types i]]]
              i [inc i]]]]]
      [logq-abort indexing of tuples only allowed with constants [identity index-exp]]]

    [logq-abort not implemented calc-index-offset index [identity t]]]]

[func try-get-constant [e]
  [match e
    [exp/integer - --]
    [option/some e]

    [exp/var v]
    [match [name-desc/kind [get-name-desc-from-name v]]
      [desc-kind/top td]
      [try-get value-constants [name/word v]]

      [desc-kind/local ld]
      [match [local-name-desc/context-kind ld]
        [local-context-kind/func -]
        [do
          ; in def-comp-fn parameters are constants
          [try-get const-env [name/word v]]]

        [option/none]]]

    [exp/cast - e]
    [try-get-constant e]

    [option/none]]]

[func get-constant [e]
  [option-default [try-get-constant e] e]]

[func exp-to-string [e]
  [match e
    [exp/integer pt n] [bigint-to-word n]
    [exp/var n] [name/word n]
    [logq-abort not implemented exp-to-string [identity e]]]]

[func type-to-string [t]
  [let [et [expand-custom-if-non-rec t]]
    [match et
    [type/wildcard -] [word wildcard]
    [type/primitive pt] [primitive-type/name pt]
    [type/pointer tmem ttar] [concat-words [type-to-string tmem] [concat-words [word -] [type-to-string ttar]]]
    [type/exp e] [exp-to-string e]
    [type/union uts] [concat-words [word union] [word-join [word -] [list-map ut uts [type-to-string ut]]]]
    [type/record fields]
    [concat-words [word record]
      [word-join [word -] [list-map fp fields [concat-words [name/word [pair/fst fp]] [concat-words [word -] [type-to-string [pair/snd fp]]]]]]]
    [type/tuple ts] [concat-words [word tuple] [word-join [word -] [list-map tt ts [type-to-string tt]]]]
    [type/array et opt-s]
    [concat-words [word array]
      [if-let [size-type opt-s]
        [concat-words [type-to-string et] [concat-words [word -] [type-to-string size-type]]]
        [type-to-string et]]]
    [type/apply-custom tn targs]
    [if [is-empty targs]
      [name/word tn]
      [concat-words [name/word tn]
        [concat-words [word -]
          [word-join [word -] [list-map ta targs [type-to-string ta]]]]]]

    [logq-abort type-to-string not implemented [identity et]]]]]

[func type-to-wat-types-current [t]
  [type-to-wat-types [type-substitute type-env t]]]

[func type-substitute-expand [t]
  [expand-custom-n [type-substitute type-env t]]]

[func add-specialized [fnw tenv type-args args]
  [let[
    subst-types [list-map ta type-args [type-substitute type-env ta]]
    types-str [word-join [word -] [list-map ta subst-types [type-to-string ta]]]
    spec-name [concat-words fnw [concat-words [word --] types-str]]
    specs-targs
    [if-let [specs [try-get gen-fn-specs-by-name fnw]]
      specs
      [let [specs [transient-kv-map]]
        [set-kv-map gen-fn-specs-by-name fnw specs]
        specs]]
    type-arg-params [growable-list]
    type-arg-exps [growable-list]
    type-arg-exp-iterator
    [type-iterate
      [func f [t]
        [match t
          [type/exp e]
          [match e
            [exp/integer -pt -n]
            [do]

            [exp/var vn]
            [match [name-desc/kind [get-name-desc-from-name vn]]
              [desc-kind/top td]
              [do
                ; we do not pass it as it is available globally
                ]

              [desc-kind/local ld]
              [do
                [push type-arg-params [pair [name/word vn] [word i32]]]
                [push type-arg-exps e]]]

            [do
              [logq-abort type exp in type arg not supported yet [identity e]]]]

          [do]]]]]
  [for-each type-arg subst-types
    [type-arg-exp-iterator type-arg]]
  [when-not [has specs-targs types-str]
    [add-func spec-name tenv [get top-funcs fnw] [clone-growable-to-frozen-list type-arg-params]]
    [set-kv-map specs-targs types-str subst-types]]
  [wat-inst/call spec-name
    [list-map arg [concat [clone-growable-to-frozen-list type-arg-exps] args]
      [exp-to-inst arg]]]]]

[func exp-to-inst [exp]
  [match exp
    [exp/integer pt n]
    [[switch [primitive-type/name pt]
      [[word i32]] wat-inst/i32.const
      [[word u32]] wat-inst/i32.const
      [[word i64]] wat-inst/i64.const
      [logq-abort not implemented exp-to-inst integer [identity pt]]]
      [bigint-to-word n]]

    [exp/float pt f]
    [[switch [primitive-type/name pt]
      [[word f32]] wat-inst/f32.const
      [[word f64]] wat-inst/f64.const
      [logq-abort not implemented exp-to-inst float [identity pt]]] [f64-to-word f]]

    [exp/var n]
    [let
      [ndesc [get-name-desc-from-name n]
       ntype [name-desc/type ndesc]]
      [match [name-desc/kind ndesc]
        [desc-kind/top td]
        [match [top-desc/kind td]
          [top-desc-kind/value vd]
          [do
            [match ntype
              [type/func -]
              [logq-abort not allowed function as value]

              [type/tuple ts]
              [logq-abort not implemented global tuples]

              [do]]
            [wat-inst/global.get [name/word n]]]

          [logq-abort not implemented exp-to-inst var [identity n] [identity td]]]

        [desc-kind/local ldesc]
        [let
          [wat-name [local-var-desc/wat-name [local-name-desc/desc ldesc]]]
          [match ntype
            [type/tuple ts]
            [let [ginsts [growable-list]]
              [for i 0 [size ts]
                [push ginsts [wat-inst/local.get [concat-words wat-name [int-to-word i]]]]]
              [wat-inst/instructions [clone-growable-to-frozen-list ginsts]]]

            [wat-inst/local.get wat-name]]]]]

    [exp/intrinsic n imm-args args]
    [let [intrin-t [intrinsic-type-from-name [name/word n]]
          imm [intrinsic-type/immediate-parameters intrin-t]
          n-of-imm [size [intrinsic-type/immediate-parameters intrin-t]]
          wimm-args
          [list-map iarg imm-args
            [match iarg
              [imm-arg/memory mem-name]
              [wat-immediate/memory [name/word mem-name]]]]]
      [wat-inst/instruction
        [wasm-name-to-wat-byte-array [name/word n]]
        wimm-args
        [list-map arg args [exp-to-inst arg]]]]

    [exp/call fexp args]
    [match fexp
      [exp/var fn]
      [if
        [match [top-desc/imported [pair/snd [get top-names [name/word fn]]]]
          [imported-or-here/imported] true
          false]
        [wat-inst/call [name/word fn] [list-map arg args [exp-to-inst arg]]]
        [let
          [tenv [infer-type-env-from-args fexp type-env args]
           efunc [get top-funcs [get-exp-var fexp]]]
          [if [eq-word [word comptimefn] [exp-function/kind efunc]]
            [let [params [exp-function/parameters efunc]
                  param-env [transient-kv-map]]
              [assert [eq [size params] [size args]] call expected same number of arguments]
              [for i 0 [size args]
                [set-kv-map param-env [name/word [at params i]] [at args i]]]
              [let
                [comp [mk-exp-to-inst-compiler tenv param-env]
                  es2i [exp2inst-compiler/exps-to-inst comp]]
                [es2i [exp-function/bodies efunc]]]]
            ; not comp time
            [let
              [type-parameters [type-func/type-parameters [get-function-type [type-of fexp]]]]
              [if [is-empty type-parameters]
                ; no type args so we can just emit a call
                [wat-inst/call [name/word fn] [list-map arg args [exp-to-inst arg]]]
                ; infer type arguments from expression arguments
                [let
                  [type-args [list-map tp type-parameters [get tenv [name/word [pair/fst tp]]]]]
                  [add-specialized [name/word fn] tenv type-args args]]]]]]]

      [exp/instantiate fexp type-args]
      [let
        [itf
          [match [type-of fexp]
            [type/func tf] tf
            [logq-abort instantiate only works on functions]]
          itype-parameters [type-func/type-parameters itf]
          subst-types [list-map ta type-args [type-substitute type-env ta]]
          ntenv [make-type-env [list-map tpn itype-parameters [name/word [pair/fst tpn]]] subst-types]]
        [add-specialized [get-exp-var fexp] ntenv type-args args]]

      [logq-abort not implemented exp-to-inst call [identity fexp] [identity args]]]

    [exp/instantiate fexp type-args]
    [logq-abort top level instantiate is not currently supported]

    [exp/call-functor fname targs]
    [let
      [fd [get-functor-desc fname]
       targs-subst [list-map ta targs [type-substitute type-env ta]]
       functor-type-env [functor-desc-to-type-env fd targs-subst]
       empty-const-env [transient-kv-map]
       comp [mk-exp-to-inst-compiler functor-type-env empty-const-env]
       e2i [exp2inst-compiler/exp-to-inst comp]]
      [e2i [functor-desc/body fd]]]

    [exp/reify t]
    [match [type-substitute-expand t]
      [type/exp e] [exp-to-inst e]
      [logq-abort not implemented exp-to-inst reify [identity t]]]

    [exp/if c t e]
    [wat-inst/if
      [type-to-wat-types-current [type-of exp]]
      [exp-to-inst c] [exp-to-inst t] [exp-to-inst e]]

    [exp/do es]
    [exps-to-inst es]

    [exp/size-of-type t]
    [exp-to-inst [type-to-size-of-exp-current-tenv t]]

    [exp/size-of-exp e]
    [exp-to-inst [type-to-size-of-exp-current-tenv [type-of [get-constant e]]]]

    [exp/let-loop ll-kind bindings bodies]
    [let
      [bind-insts
       [list-map b bindings
        [let [ns [pair/fst b]
              e [pair/snd b]
              gset-insts [growable-list]]
          [for i 0 [size ns]
            [push glocals
              [let
                [n [at ns i]
                 ndesc [get-name-desc-from-name n]
                 ldesc [get-local-desc-from-name-desc ndesc]
                 wat-name [local-var-desc/wat-name [local-name-desc/desc ldesc]]
                 t [name-desc/type ndesc]]
                [push gset-insts [wat-inst/local.set-no wat-name]]
                [pair wat-name [type-to-wat-type [type-substitute type-env t]]]]]]
          [wat-inst/instructions
            [concat
              [list [exp-to-inst e]]
              [reverse [clone-growable-to-frozen-list gset-insts]]]]]]]
      [match ll-kind
        [let-or-loop/let]
        [wat-inst/instructions
          [concat bind-insts [list [exps-to-inst bodies]]]]

        [let-or-loop/loop]
        [wat-inst/instructions
          [concat bind-insts
            [list
              [wat-inst/loop
                [word loop-label]
                [type-to-wat-types-current [type-ofs bodies]]
                [exps-to-inst bodies]]]]]]]

    [exp/continue assignments]
    [wat-inst/instructions
      [concat
        [list-map a assignments
          [let
            [n [pair/fst a]
             ndesc [get-name-desc-from-name n]
             ldesc [get-local-desc-from-name-desc ndesc]
             wat-name [local-var-desc/wat-name [local-name-desc/desc ldesc]]]
            [wat-inst/local.set wat-name [exp-to-inst [pair/snd a]]]]]
        [list [wat-inst/br [word loop-label]]]]]

    [exp/tuple elems]
    [wat-inst/instructions [list-map elem elems [exp-to-inst elem]]]

    [exp/record fields]
    [wat-inst/instructions [list-map field fields [exp-to-inst [pair/snd field]]]]

    [exp/pfield p-target-exp field-name]
    [let
      [pp [get-pointer-args [type-of p-target-exp]]]
      [exp-to-inst [int-exp-add p-target-exp [calc-field-offset [pair/snd pp] [name/word field-name]]]]]

    [exp/offset-of t-rec field-name]
    [exp-to-inst [calc-field-offset t-rec [name/word field-name]]]

    [exp/pindex p-target-exp index-exp]
    [let
      [pp [get-pointer-args [type-of p-target-exp]]]
      [exp-to-inst [int-exp-add p-target-exp [calc-index-offset [pair/snd pp] index-exp]]]]

    [exp/assign dst src]
    [match dst
      [exp/var n]
      [wat-inst/global.set [name/word n] [exp-to-inst src]]

      [logq-abort not implemented exp-to-inst assign [identity dst]]]

    [exp/deref target]
    [let
     [ptup [get-pointer-args [type-of target]]
      mem-name-some [option/some [get-exp-var [option-get [try-get-type-exp [pair/fst ptup]]]]]
      ginsts [growable-list]
      do-it
      [func di [ttarget cur-target]
        [match ttarget
          [type/tuple elem-types]
          [loop [i 0 n [size elem-types] acc cur-target]
            [when [lt-s i n]
              [let [telem [at elem-types i]]
                [di telem acc]
                [continue i [inc i] acc [int-exp-add acc [type-to-size-of-exp-current-tenv telem]]]]]]

          [type/record fields]
          [loop [i 0 n [size fields] acc cur-target]
            [when [lt-s i n]
              [let [telem [pair/snd [at fields i]]]
                [di telem acc]
                [continue i [inc i] acc [int-exp-add acc [type-to-size-of-exp-current-tenv telem]]]]]]

          [let [target-prim [type-to-primitive ttarget]]
            [push ginsts
              [wat-inst/load-opt
                [wasm-name-to-wat-byte-array
                  [prim-types-to-load-inst-name
                    [if [primitive-is-wasm-value-type target-prim] target-prim type-primitive-i64]
                    target-prim]]
                [wat-inst-memargs-opt
                  mem-name-some
                  [option/none]
                  [option/none]]
                [exp-to-inst target]]]]]]]
      [do-it [type-substitute type-env [pair/snd ptup]] target]
      [wat-inst/instructions [clone-growable-to-frozen-list ginsts]]]

    [exp/passign is-init target src]
    [let
    [ptup [get-pointer-args [type-of target]]
     mem-name-some [option/some [get-exp-var [option-get [try-get-type-exp [pair/fst ptup]]]]]
     ginsts [growable-list]
     add-prim
      [func add-prim [target-offset dst-prim src-prim wat-src]
        [let
          [intr-name [prim-types-to-store-inst-name dst-prim src-prim]
           p-p-offset [int-exp-add target target-offset]
           exp-const-pair-opt [try-get-i32-add-const p-p-offset]
           offset-opt [option-map pair/snd exp-const-pair-opt]
           trimmed-target [option-default [option-map pair/fst exp-const-pair-opt] p-p-offset]]
          [push ginsts
            [wat-inst/store-opt
              [wasm-name-to-wat-byte-array intr-name]
              [wat-inst-memargs-opt
                mem-name-some
                [option-map bigint-to-word offset-opt]
                [option/none]]
              [exp-to-inst trimmed-target]
              wat-src]]]]
     assign-exp
     [func assign-exp [target-offset tdst src]
        [match src
          [exp/var src-name]
          [match [type-substitute-expand [type-of src]]
            [type/tuple elem-types]
            [let [vn-src [name/word src-name]]
              [loop [i 0 n [size elem-types] acc int-const-0]
                [when [lt-s i n]
                  [let
                    [telem [type-substitute-expand [at elem-types i]]
                     ptelem [type-to-primitive telem]]
                    [add-prim
                      acc
                      ptelem
                      ptelem
                      [wat-inst/local.get [concat-words vn-src [int-to-word i]]]]
                    [continue i [inc i] acc [int-exp-add acc [type-to-size-of-exp-current-tenv telem]]]]]]]

            [type/record fields]
            [let [vn-src [name/word src-name]]
              [loop [i 0 n [size fields] acc int-const-0]
                [when [lt-s i n]
                  [let
                    [field [at fields i]
                     telem [type-substitute-expand [pair/snd field]]
                     ptelem [type-to-primitive telem]]
                    [add-prim
                      acc
                      ptelem
                      ptelem
                      [wat-inst/local.get [concat-words vn-src [name/word [pair/fst field]]]]]
                    [continue i [inc i] acc [int-exp-add acc [type-to-size-of-exp-current-tenv telem]]]]]]]

            [add-prim target-offset [type-to-primitive [type-substitute-expand tdst]] [type-to-primitive [type-substitute-expand [type-of src]]] [exp-to-inst src]]]

          [exp/array tvalue-elem elems]
          [do
            [assert-not [may-side-effect target] assign target cannot have side effects when assigning arrays]
            [let
              [size-of-int-exp [type-to-size-of-exp-current-tenv tvalue-elem]]
              [loop [i 0 n [size elems]]
                [when [lt-s i n]
                  [assign-exp
                    [int-exp-add target-offset [int-exp-mul [mk-exp-i32-i32 i] size-of-int-exp]]
                    tvalue-elem
                    [at elems i]]
                  [continue i [inc i]]]]]]

          [exp/tuple elems]
          [do
            [assert-not [may-side-effect target] assign target cannot have side effects when assigning tuples]
            [loop [i 0 n [size elems] acc int-const-0]
              [when [lt-s i n]
                [let
                  [elem [at elems i]
                   telem [type-of elem]]
                  [assign-exp [int-exp-add target-offset acc] telem elem]
                  [continue i [inc i] acc [int-exp-add acc [type-to-size-of-exp-current-tenv telem]]]]]]]

          [exp/record fields]
          [do
            [assert-not [may-side-effect target] assign target cannot have side effects when assigning record]
            [loop [i 0 n [size fields] acc int-const-0]
              [when [lt-s i n]
                [let
                  [field-exp [pair/snd [at fields i]]
                   tfield [type-of field-exp]]
                  [assign-exp [int-exp-add target-offset acc] tfield field-exp]
                  [continue i [inc i] acc [int-exp-add acc [type-to-size-of-exp-current-tenv tfield]]]]]]]

          [add-prim
            target-offset
            [type-to-primitive [type-substitute-expand [type-of src]]]
            [type-to-primitive [type-substitute-expand [type-of src]]]
            [exp-to-inst src]]]]
     tdst [pair/snd ptup]
     orig-offset int-const-0]
    [assign-exp orig-offset tdst src]
    [wat-inst/instructions [clone-growable-to-frozen-list ginsts]]]

    [exp/data mem-name-exp data-exp]
    [let [ee [exp-eval type-env const-env]]
      [if-let [c [ee exp]]
        [exp-to-inst c]
        [logq-abort could not const eval data]]]

    [exp/memory-static-top mem-name]
    [let [mem-name-word [get-exp-var mem-name]
          mem-type [get-mem-type mem-name-word]
          offset-atom [get-memory-offset-atom mem-name-word]]
      [wat-inst/lazy-integer-const [primitive-type/name mem-type] offset-atom]]

    [exp/cast t e]
    [exp-to-inst e]

    [exp/annotation t e]
    [exp-to-inst e]

    [logq-abort exp-to-inst not implemented [identity exp]]]]

[func exps-to-inst [forms]
  [wat-inst/instructions
    [if [is-empty forms]
      [list]
      [concat
        [list-map form [slice forms 0 [dec [size forms]]]
          [loop [res [exp-to-inst form] i [size [type-to-wat-types-current [type-of form]]]]
              [if i
                [continue
                  res [wat-inst-word [word drop] res]
                  i [dec i]]
                res]]]
        [list [exp-to-inst [last forms]]]]]]]]
  [exp2inst-compiler exp-to-inst exps-to-inst glocals]]]]

[func mem-exp-to-wat-memory [mem-exp]
  [wat-memory
    [ifs
      [is-identical [memory-exp/type mem-exp] type-primitive-i32] [memory-kind/i32]
      [is-identical [memory-exp/type mem-exp] type-primitive-i64] [memory-kind/i64]
      [logq-abort not implemented memory-kind [memory-exp/type mem-exp]]]
    [word-to-int [name/word [memory-exp/init-size mem-exp]]]
    [if-let [max [memory-exp/max-size mem-exp]]
      [option/some [word-to-int [name/word max]]]
      [option/none]]]]

[func add-func [fname type-inst-env f extra-parameters]
  [let
    [comp [mk-exp-to-inst-compiler type-inst-env [transient-kv-map]]
     es2i [exp2inst-compiler/exps-to-inst comp]
     inst [es2i [exp-function/bodies f]]
     tf [exp-function/type f]
     locals [clone-growable-to-frozen-list [exp2inst-compiler/glocals comp]]
     param-types [type-func/parameters tf]
     param-names [exp-function/parameters f]
     gparams [growable-list]]
    [for-each extra extra-parameters
      [push gparams extra]]
    [for i 0 [size param-names]
      [let [pt [at param-types i]
            pnw [name/word [at param-names i]]
            ept [expand-custom-n [type-substitute type-inst-env pt]]]
        [match ept
          [type/tuple types]
          [for j 0 [size types]
            [push gparams
              [pair [concat-words pnw [int-to-word j]] [type-to-wat-type [at types j]]]]]

          [type/record fields]
          [for j 0 [size fields]
            [push gparams
              [let [field [at fields j]]
                [pair [concat-words pnw [name/word [pair/fst field]]] [type-to-wat-type [pair/snd field]]]]]]

          [push gparams [pair pnw [type-to-wat-type ept]]]]]]
    [push wat-funcs
      [wat-func
        fname
        [clone-growable-to-frozen-list gparams]
        locals
        [type-to-wat-types [type-substitute type-inst-env [type-func/result tf]]]
        inst]]]]

[func compile [tops]
  [let
    [imports [growable-list]
     memories [growable-list]
     globals [growable-list]
     exports [growable-list]
     wdata [growable-list]]
    [for-each top tops
      [match top
        [top-decl/memory n mem-exp]
        [push memories
          [pair
            [name/word n]
            [mem-exp-to-wat-memory mem-exp]]]

        [top-decl/import mod-name exp-imports]
        [let [mod-name-word [name/word mod-name]]
          [for-each import-pair exp-imports
            [let [n [pair/fst import-pair]
                  nw [name/word n]
                  ik [pair/snd import-pair]]
              [push
                imports
                [pair
                  [pair mod-name-word nw]
                  [match ik
                    [import-kind-decl/function ps rt]
                    [wat-import-kind/func
                      nw
                      [list-map p ps [type-to-wat-type [pair/snd p]]]
                      [type-to-wat-types rt]]

                    [import-kind-decl/memory mem-exp]
                    [wat-import-kind/memory
                      nw
                      [mem-exp-to-wat-memory mem-exp]]]]]]]]

        [top-decl/export names]
        [for-each n names
          [push exports
            [let [nw [name/word n]
                  ndesc [get-name-desc-from-name n]
                  ekind
                  [match [top-desc/kind [get-top-desc-from-name-desc ndesc]]
                    [top-desc-kind/value -]
                    [match [name-desc/type ndesc]
                      [type/func -] [export-kind/func]
                      [export-kind/global]]
                    [top-desc-kind/memory -] [export-kind/memory]]]
              [pair nw [pair ekind nw]]]]]

        [top-decl/value k def-name oexp]
        [let [expand-functor-calls
          [func expand-functor-calls [tenv exp]
            [match exp
              [exp/func f]
              [add-func [name/word def-name] tenv f [list]]

              [exp/call-functor fn targs]
              [let
                [fd [get-functor-desc fn]
                 functor-type-env [functor-desc-to-type-env fd targs]]
                [expand-functor-calls functor-type-env [functor-desc/body fd]]]

              [let
                [const-env [transient-kv-map]
                 type-inst-env [transient-kv-map]
                 e2ic [mk-exp-to-inst-compiler type-inst-env const-env]
                 e2i [exp2inst-compiler/exp-to-inst e2ic]
                 inst [e2i exp]]
                [assert [is-empty [clone-growable-to-frozen-list [exp2inst-compiler/glocals e2ic]]] compile expected no locals]
                [push
                  globals
                  [wat-global
                    [name/word def-name]
                    [match k
                      [value-kind/mutable] [mut/var]
                      [value-kind/constant] [mut/const]]
                    [type-to-wat-type [type-of exp]]
                    inst]]]]]]
              [expand-functor-calls [transient-kv-map] oexp]]

        [top-decl/function f]
        [add-func [name/word [option-get [exp-function/name f]]] [transient-kv-map] f [list]]
        ]]
    [for-each data [clone-growable-to-frozen-list datas]
      [push wdata
        [wat-data/active
          [data-active/mem-name data]
          [wat-inst/i32.const [int-to-word [data-active/address data]]]
          [data-active/bytes data]]]]
    [wat-output
      imports
      memories
      globals
      wat-funcs
      exports
      wdata]]]

]
[func f2o [forms]
  [let
    [tops [top-forms-to-top-decls forms]
     output [compile tops]
     errors [clone-growable-to-frozen-list gerrors]]
    [when-not [is-empty errors]
      [logq listing errors]
      [log errors]
      [for-each e errors
        [logq error [identity e]]]
      [logq-abort aborting because of errors]]
    [comment [for-each top-form tops [log top-form]]]
    output]]
]
]]
