[load check2.wuns]

[type memory-kind []
  [union
    [i32]
    [i64]]]

[type lldef-desc []
  [union
    [memory memory-kind]
    [any]
    [func i32]]]

[type lllocal-var-kind []
  [union
    [param]
    [let]
    [loop]
    [func-internal-self i32]]]

[type lltype-desc []
  [union
    [var word]
    [apply word [list lltype-desc]]]]

[type field-desc []
  [record
    [type lltype-desc]]]

[type user-type-desc []
  [union
    [record [transient-kv-map word field-desc] [list [pair word field-desc]]]]]

[type llctx []
  [record
    [lldef-ctx [transient-kv-map word lldef-desc]]
    [form-to-ldesc [transient-kv-map form lllocal-var-kind]]
    [user-type-params [transient-kv-map word [list syntax-word]]]
    [user-types [transient-kv-map word user-type-desc]]]]

[def ascii-underscore [i32 95]]

[comment wuns does not have underscores so we convert dashes to underscores]
[defn wasm-name-to-wat-bytes [w]
  [let [sw [word-byte-size w]
        res [growable-list]]
    [for i 0 sw
      [push res
        [let [c [char-code-at w i]] [if [eq c [word-to-char-code -]] ascii-underscore c]]]]
    [clone-growable-to-frozen-list res]]]

[defn wasm-name-to-wat-byte-array [w]
  [let [sw [word-byte-size w]
        res [byte-array sw]]
    [for i 0 sw
      [byte-array-set res i
        [let [c [char-code-at w i]] [if [eq c [word-to-char-code -]] ascii-underscore c]]]]
    res]]

[defn get-func-type [t]
  [match [normalize-type t]
    [ctype/inst inst-type]
    [match inst-type
      [inst-type/func func-type]
      func-type

      [logq-abort get-func-type expected a func type]]

    [logq-abort get-func-type expected a func type]]]

[defn get-apply-type [t]
  [match [normalize-type t]
    [ctype/inst inst-type]
    [match inst-type
      [inst-type/apply type-name type-args]
      [pair type-name type-args]

      [logq-abort get-apply-type expected an apply type]]

    [logq-abort get-apply-type expected an apply type]]]

[defn syntax-word-get-form [sw]
  [if-let [f [syntax-word/opt-form sw]]
    f
    [logq-abort syntax-word-get-form expected a form]]]

[type llliteral []
  [union
    [i32 syntax-word]
    [i64 syntax-word]
    [f32 syntax-word]
    [f64 syntax-word]]]

[defn push-error [form msg]
  [log form]
  [log msg]
  [log-location form]
  [logq-abort push-error error]]

[defn get-list [form]
  [match form
    [form/list l] l
    [do
      [push-error form [quote [expected list]]]
      [list]]]]

[defn llbuiltin-type-arity-ok [type-name n-of-args]
  [if-let [ok [builtin-type-arity-ok type-name n-of-args]]
    [option/some ok]
    [switch type-name
      [[word pointer]]
      [option/some [eq 2 n-of-args]]
      [option/none]]]]

[type lltype []
  [union
    [var syntax-word]
    [apply syntax-word [list lltype]]]]

[todo we should let type params shadow builtin types in case more builtins are added]

[defn form-to-lltype [ctx type-param-map form]
  [match form
    [form/word w]
    [if-let [arity-ok [llbuiltin-type-arity-ok w 0]]
      [do
        [when-not arity-ok
          [push-error form [quote [wrong number of type arguments to builtin]]]]
        [lltype/apply [sword form] [list]]]
      [if [has type-param-map w]
        [lltype/var [sword form]]
        [if-let [type-params [try-get [llctx/user-type-params ctx] w]]
          [do
            [when-not [eq [size type-params] 0] [push-error form [quote [expected no type params]]]]
            [lltype/apply [sword form] [list]]]
          [push-error form [quote [undefined type or type param]]]]]]

    [form/list l]
    [let [sw [sword [first l]] fw [syntax-word/word sw]]
      [assert-not [eq-word fw [word type-scheme]] unexpected type-scheme]
      [let [n-of-args [dec [size l]]]
        [if-let [arity-ok [llbuiltin-type-arity-ok fw n-of-args]]
          [do
            [when-not arity-ok
              [push-error form [quote [wrong number of type arguments to builtin]]]]
            [switch fw
              [[word pointer]]
              [do
                [lltype/apply sw
                  [list
                    [lltype/apply [sword [second l]] [list]]
                    [form-to-lltype ctx type-param-map [third l]]]]]

              [lltype/apply sw [list-map arg [rest l] [form-to-lltype ctx type-param-map arg]]]]]
          [do
            [lltype/apply sw [list-map arg [rest l] [form-to-lltype ctx type-param-map arg]]]]]]]]]

[type
  llexp []
  [union
    [var syntax-word]
    [literal llliteral]
    [intrinsic syntax-word [list syntax-word] [list llexp]]
    [if llexp llexp llexp]
    [let [list [pair syntax-word llexp]] [list llexp]]
    [loop [list [pair syntax-word llexp]] [list llexp]]
    [continue [list [pair syntax-word llexp]]]
    [do [list llexp]]
    [call syntax-word [list llexp]]

    [cast lltype llexp]
    [deref llexp]
    [assign llexp llexp]
    [field llexp syntax-word]
    ]]

[defn llexp-recur [f]
  [func go [bform]
    [when
      [f bform]
      [match bform
        [llexp/var sw]
        [do]

        [llexp/literal l]
        [do]

        [llexp/intrinsic w imm-args args]
        [for-each a args [go a]]

        [llexp/call fn args]
        [do
          [for-each a args [go a]]]

        [llexp/if c t e]
        [do [go c] [go t] [go e]]

        [llexp/do bs]
        [for-each b bs [go b]]

        [llexp/let bs body]
        [do
          [for-each b bs [go [pair/snd b]]]
          [for-each b body [go b]]]

        [llexp/loop bs body]
        [do
          [for-each b bs [go [pair/snd b]]]
          [for-each b body [go b]]]

        [llexp/continue ass]
        [for-each as ass
          [go [pair/snd as]]]

        [llexp/cast t e]
        [go e]

        [llexp/deref target]
        [go target]

        [llexp/assign target value]
        [do [go target] [go value]]

        [llexp/field target field-name]
        [go target]

        [do
          [log bform]
          [logq-abort llform-recur not implemented]]]]]]

[defn set-local [ctx lvars f kind]
  [let [w [form-to-word f]]
    [when [has lvars w] [push-error f [quote [redeclaring local]]]]
    [set-kv-map lvars w kind]
    [set-kv-map [llctx/form-to-ldesc ctx] f kind]]]

[defn form-to-llexp [ctx lstack form]
  [let
    [lldef-ctx [llctx/lldef-ctx ctx]]
    [match form
      [form/word w]
      [let [sname [sword form]
            bf [llexp/var sname]
            form-to-ldesc [llctx/form-to-ldesc ctx]
            ]

        [if-let [ldesc [try-get-local lstack w]]
          [set-kv-map form-to-ldesc form ldesc]
          [if-let [ddesc [try-get lldef-ctx w]]
            [do]
            [push-error form [quote [undefined word]]]]]
        bf]

      [form/list l]
      [let [n-of-args [dec [size l]]
            assert-n-args [func ana [n] [when-not [eq n-of-args n] [push-error form [quote [expected n-of-args arguments]]]]]
            get-arg [func get-arg [i] [if [lt-s i n-of-args] [at l [inc i]] [quote no-such-arg]]]
            - [assert-not [is-empty l] list was empty]
            first-form [first l]]
        [match first-form
          [form/word first-word]
          [switch first-word
            [[word i32]]
            [llexp/literal [llliteral/i32 [sword [get-arg 0]]]]

            [[word i64]]
            [llexp/literal [llliteral/i64 [sword [get-arg 0]]]]

            [[word f32]]
            [llexp/literal [llliteral/f32 [sword [get-arg 0]]]]

            [[word f64]]
            [llexp/literal [llliteral/f64 [sword [get-arg 0]]]]

            [[word v128] [word word]]
            [logq-abort form-to-llexp not implemented [identity first-form]]

            [[word intrinsic]]
            [let [inst-sname [sword [get-arg 0]]
                  inst-name [syntax-word/word inst-sname]]
              [if [or [is-i32-bin-inst inst-name] [is-f64-bin-inst inst-name] [is-f64-comp-inst inst-name]]
                [do
                  [assert-n-args 3]
                  [llexp/intrinsic inst-sname [list] [list-map arg [slice l 2 [size l]] [form-to-llexp ctx lstack arg]]]]
                [switch inst-name
                  [[word unreachable]]
                  [do
                    [assert-n-args 1]
                    [llexp/intrinsic inst-sname [list] [list-map arg [slice l 2 [size l]] [form-to-llexp ctx lstack arg]]]]

                  [[word i32.load] [word i32.load8-u]]
                  [do
                    [todo we need to check the memory is deffed as a memory]
                    [assert-n-args 5]
                    [llexp/intrinsic inst-sname
                      [list
                        [sword [get-arg 1]]
                        [sword [get-arg 2]]
                        [sword [get-arg 3]]]
                      [list [form-to-llexp ctx lstack [get-arg 4]]]]]

                  [[word i32.store] [word i32.store8]]
                  [do
                    [assert-n-args 6]
                    [llexp/intrinsic inst-sname
                      [list
                        [sword [get-arg 1]]
                        [sword [get-arg 2]]
                        [sword [get-arg 3]]]
                      [list
                        [form-to-llexp ctx lstack [get-arg 4]]
                        [form-to-llexp ctx lstack [get-arg 5]]]]]

                  [do
                    [log form]
                    [logq-abort form-to-llexp not implemented]]]]]

            [[word if]]
            [do
              [assert-n-args 3]
              [llexp/if [form-to-llexp ctx lstack [get-arg 0]] [form-to-llexp ctx lstack [get-arg 1]] [form-to-llexp ctx lstack [get-arg 2]]]]

            [[word do]]
            [llexp/do [list-map arg [rest l] [form-to-llexp ctx lstack arg]]]

            [[word loop]]
            [let
              [bindings [get-list [get-arg 0]]
                lvars [transient-kv-map]
                lctx [local-context lvars [local-context-kind/loop]]
                new-lstack [local-stack/frame lstack lctx]]
              [when [lt-s n-of-args 2] [push-error form [quote [expected at least 2 arguments]]]]
              [llexp/loop
                [list-map p [pairwise bindings]
                  [let [name [first p]
                        sname [sword name]
                        name-word [syntax-word/word sname]
                        be [form-to-llexp ctx new-lstack [second p]]
                        ldesc [lllocal-var-kind/loop]]
                    [when-let [ldesc [try-get-local lstack name-word]]
                      [push-error name [quote [loop var shadows local]]]]
                    [set-local ctx lvars name ldesc]
                    [pair sname be]]]
                [list-map f [slice l 2 [size l]] [form-to-llexp ctx new-lstack f]]]]

            [[word continue]]
            [let [loop-vars
                    [if-let [loop-context [try-get-enclosing-loop-context lstack]]
                      [local-context/vars loop-context]
                      [do
                        [push-error form [quote [not in a loop context]]]
                        [transient-kv-map]]]]
              [llexp/continue
                [list-map p [pairwise-pairs [rest l]]
                  [let [name [pair/fst p]
                        sname [sword name]
                        name-word [syntax-word/word sname]
                        be [form-to-llexp ctx lstack [pair/snd p]]]
                    [if-let [ldesc [try-get loop-vars name-word]]
                      [set-kv-map [llctx/form-to-ldesc ctx] name ldesc]
                      [push-error name [quote [not a loop var of the current loop]]]]
                    [pair sname be]]]]]

            [[word let]]
            [let
              [bindings [get-list [get-arg 0]]
               lvars [transient-kv-map]
               ctx-let [local-context lvars [local-context-kind/let]]
               new-lstack [local-stack/frame lstack ctx-let]
               ldesc [lllocal-var-kind/let]]
              [when [lt-s n-of-args 2] [push-error form [quote [expected at least 2 arguments]]]]
              [llexp/let
                [list-map p [pairwise bindings]
                  [let [name [first p]
                        sname [sword name]
                        name-word [syntax-word/word sname]
                        be [form-to-llexp ctx new-lstack [second p]]]
                    [when-let [ldesc2 [try-get-local lstack name-word]]
                      [push-error name [quote [let var shadows local]]]]
                    [set-local ctx lvars name ldesc]
                    [pair sname be]]]
                [list-map f [slice l 2 [size l]] [form-to-llexp ctx new-lstack f]]]]

            [[word cast]]
            [do
              [assert-n-args 2]
              [llexp/cast
                [form-to-lltype ctx [transient-kv-map] [get-arg 0]]
                [form-to-llexp ctx lstack [get-arg 1]]]]

            [[word deref]]
            [do
              [assert-n-args 1]
              [llexp/deref
                [form-to-llexp ctx lstack [get-arg 0]]]]

            [[word assign]]
            [do
              [assert-n-args 2]
              [llexp/assign
                [form-to-llexp ctx lstack [get-arg 0]]
                [form-to-llexp ctx lstack [get-arg 1]]]]

            [[word field]]
            [do
              [assert-n-args 2]
              [llexp/field
                [form-to-llexp ctx lstack [get-arg 0]]
                [sword [get-arg 1]]]]

            [do
              [if-let [ldesc [try-get-local lstack first-word]]
                [match ldesc
                  [lllocal-var-kind/func-internal-self arity]
                  [assert-n-args arity]

                  [logq-abort form-to-llexp only rec calls allowed]]
                [if-let [llddesc [try-get lldef-ctx first-word]]
                  [do
                    [match llddesc
                      [lldef-desc/func arity]
                      [assert-n-args arity]

                      [logq-abort form-to-llexp not a func]]]
                  [do
                    [logq-abort form-to-llexp def not found [identity first-form]]]
                  ]]
                [llexp/call [sword first-form] [list-map arg [rest l] [form-to-llexp ctx lstack arg]]]]]

          [form/list fl]
          [logq-abort form-to-llexp direct calls not implemented]]]]]]

[def type-f32 [make-type [word f32]]]
[def type-i64 [make-type [word i64]]]

[defn llliteral-to-type [l]
  [match l
    [llliteral/i32 -] type-i32
    [llliteral/i64 -] type-i64
    [llliteral/f32 -] type-f32
    [llliteral/f64 -] type-f64
    [logq-abort llliteral-to-type not implemented]]]

[defn is-syntactic-llvalue [bform]
  [match bform
    [llexp/literal l] 1
    [llexp/var f] 1
    0]]

[type llcheck-context []
  [record
    [messages [growable-list check-message]]
    [def-var-types [transient-kv-map word check-type-scheme]]
    [type-var-counter [atom i32]]
    [type-annotations [transient-kv-map js-value ctype]]
    [bind-ctx llctx]]]

[defn lltry-get-var-type [gctx local-ctx var-name]
  [if-let [ltype [try-get-local local-ctx var-name]]
    [option/some ltype]
    [try-get [llcheck-context/def-var-types gctx] var-name]]]

[defn get-specialized-var [gctx level lctx w]
  [if-let [type-scheme [lltry-get-var-type gctx lctx w]]
    [specialize-type-scheme [llcheck-context/type-var-counter gctx] level type-scheme]
    [do
      [log w]
      [logq-abort llvariable not found [identity w]]
      [generate-fresh-type-var-atom [llcheck-context/type-var-counter gctx] level]]]]

[defn llunify-report [gctx t1 t2 bst]
  [for-each error [unify t1 t2]
    [log [ctype-to-form t1]]
    [log [ctype-to-form t2]]
    [logq-abort llunify-report error]]]

[defn llannotate [gctx bst type]
  [set-kv-map [llcheck-context/type-annotations gctx] [to-js-value bst] type]
  type]

[defn type-memory [mem-name] [make-type [word memory] [make-type mem-name]]]
[defn type-pointer [mem target] [make-type [word pointer] mem target]]

[defn lltype-to-lltype-desc [t]
  [match t
    [lltype/var w] [lltype-desc/var [syntax-word/word w]]
    [lltype/apply w args] [lltype-desc/apply [syntax-word/word w] [list-map a args [lltype-to-lltype-desc a]]]]]

[defn llinstantiate-type-desc [type-var-env syntax-type]
  [match syntax-type
    [lltype-desc/var tv]
    [get type-var-env tv]

    [lltype-desc/apply type-name targs]
    [switch type-name
      [[word i32]]
      type-i32

      [[word f64]]
      type-f64

      [[word word]]
      [logq-abort llinstantiate-type-desc not implemented]

      [[word pointer]]
      [let [mem [first targs] target [second targs]]
        [type-pointer
          [match mem
            [lltype-desc/apply mem-name mem-args]
            [type-memory mem-name]

            [logq-abort llinstantiate-type-desc unexpected mem]]
          [llinstantiate-type-desc type-var-env target]]]

      [make-type-list
        type-name
        [list-map ta targs [llinstantiate-type-desc type-var-env ta]]]]]]


[defn llinstantiate-syntax-type [type-var-env syntax-type]
  [match syntax-type
    [lltype/var tv]
    [get type-var-env [syntax-word/word tv]]

    [lltype/apply type-name targs]
    [switch [syntax-word/word type-name]
      [[word i32]]
      type-i32

      [[word f64]]
      type-f64

      [[word word]]
      [logq-abort llinstantiate-syntax-type not implemented]

      [[word pointer]]
      [let [mem [first targs] target [second targs]]
        [type-pointer
          [match mem
            [lltype/apply mem-name mem-args]
            [type-memory [syntax-word/word mem-name]]

            [logq-abort llinstantiate-syntax-type unexpected mem]]
          [llinstantiate-syntax-type type-var-env target]]]

      [make-type-list
        [syntax-word/word type-name]
        [list-map ta targs [llinstantiate-syntax-type type-var-env ta]]]]]]

[defn mem-name-from-mem-type [tmem]
  [pair/fst [get-apply-type [first [pair/snd [get-apply-type tmem]]]]]]

[defn infer-llexp [gctx level lctx bform]
  [match bform
    [llexp/var w]
    [get-specialized-var gctx level lctx [syntax-word/word w]]

    [llexp/literal l]
    [llliteral-to-type l]

    [llexp/do bodies]
    [if [is-empty bodies]
      type-empty-tuple
      [do
        [for i 0 [dec [size bodies]]
          [infer-llexp gctx level lctx [at bodies i]]]
        [infer-llexp gctx level lctx [last bodies]]]]

    [llexp/intrinsic inst-name imm-args iargs]
    [let [w [syntax-word/word inst-name]]
      [ifs
        [is-i32-bin-inst w]
        [let [a [at iargs 0] b [at iargs 1]]
          [llunify-report gctx type-i32 [infer-llexp gctx level lctx a] a]
          [llunify-report gctx type-i32 [infer-llexp gctx level lctx b] b]
          type-i32]

        [is-f64-bin-inst w]
        [let [a [at iargs 0] b [at iargs 1]]
          [llunify-report gctx type-f64 [infer-llexp gctx level lctx a] a]
          [llunify-report gctx type-f64 [infer-llexp gctx level lctx b] b]
          type-f64]

        [is-f64-comp-inst w]
        [let [a [at iargs 0] b [at iargs 1]]
          [llunify-report gctx type-f64 [infer-llexp gctx level lctx a] a]
          [llunify-report gctx type-f64 [infer-llexp gctx level lctx b] b]
          type-i32]

        [switch w
          [[word unreachable]]
          type-empty-tuple

          [[word i32.load] [word i32.load8-u]]
          [let
            [addr [first iargs]]
            [llunify-report gctx type-i32 [infer-llexp gctx level lctx addr] addr]
            type-i32]

          [[word i32.store] [word i32.store8]]
          [let
            [addr [first iargs]
             value [second iargs]]
            [llunify-report gctx type-i32 [infer-llexp gctx level lctx addr] addr]
            [llunify-report gctx type-i32 [infer-llexp gctx level lctx value] value]
            type-empty-tuple]

          [logq-abort bin intrinsic not implemented]]]]

    [llexp/if cond then else]
    [let
      [cond-type [infer-llexp gctx level lctx cond]
       then-type [infer-llexp gctx level lctx then]
       else-type [infer-llexp gctx level lctx else]]
      [llunify-report gctx type-i32 cond-type cond]
      [llunify-report gctx then-type else-type then]
      [llannotate gctx bform then-type]]

    [llexp/let bindings bodies]
    [let
      [var-types [transient-kv-map]
       let-ctx [make-local-context var-types lctx [local-context-kind/let]]
       level-1 [inc level]]
      [for-each binding bindings
        [let
          [var [pair/fst binding]
           value [pair/snd binding]
           val-type [infer-llexp gctx level-1 let-ctx value]
           general-val-type
            [if [is-syntactic-llvalue value]
              [generalize level val-type]
              [mk-empty-type-scheme val-type]]]
          [set-kv-map var-types [syntax-word/word var] general-val-type]]]
      [if [is-empty bodies]
        type-empty-tuple
        [do
          [for i 0 [dec [size bodies]]
            [infer-llexp gctx level let-ctx [at bodies i]]]
          [infer-llexp gctx level let-ctx [last bodies]]]]]

    [llexp/loop bindings bodies]
    [let
      [var-types [transient-kv-map]
       loop-ctx [make-local-context var-types lctx [local-context-kind/loop]]
       level-1 [inc level]]
      [for-each binding bindings
        [let
          [var [pair/fst binding]
            value [pair/snd binding]
            val-type [infer-llexp gctx level-1 loop-ctx value]
            general-val-type [mk-empty-type-scheme val-type]]
          [llannotate gctx value val-type]
          [set-kv-map var-types [syntax-word/word var] general-val-type]]]
      [llannotate gctx bform
        [if [is-empty bodies]
          type-empty-tuple
          [do
            [for i 0 [dec [size bodies]]
              [infer-llexp gctx level loop-ctx [at bodies i]]]
            [infer-llexp gctx level loop-ctx [last bodies]]]]]]

    [llexp/continue assignments]
    [do
      [when-let [loop-context [try-get-enclosing-loop-context lctx]]
        [for-each assignment assignments
          [let
            [loop-vars [local-context/vars loop-context]
              loop-var-type-scheme [get loop-vars [syntax-word/word [pair/fst assignment]]]
              value [pair/snd assignment]
              val-type [infer-llexp gctx level lctx value]]
            [llunify-report gctx [check-type-scheme/type loop-var-type-scheme] val-type value]]]]
      [generate-fresh-type-var-atom [llcheck-context/type-var-counter gctx] level]]

    [llexp/call fname-sword args]
    [let
      [spec-func-type [get-specialized-var gctx level lctx [syntax-word/word fname-sword]]
       arg-types [list-map-fn [func f [arg] [infer-llexp gctx level lctx arg]] args]
       t-res [generate-fresh-type-var-atom [llcheck-context/type-var-counter gctx] level]
       t-func [type-func-no-rest arg-types t-res]]
      [llunify-report gctx spec-func-type t-func bform]
      [llannotate gctx bform t-res]]

    [llexp/cast cast-type value]
    [let
      [tv [infer-llexp gctx level lctx value]
       inst-type [llinstantiate-syntax-type [transient-kv-map] cast-type]
       inst-app-t [get-apply-type inst-type]]
      [todo when casting to pointer we should check if the value is i32 or i64 depending on the memory]
      [switch [pair/fst inst-app-t]
        [[word pointer]]
        [let [mem-name [mem-name-from-mem-type [first [pair/snd inst-app-t]]]]
          [if-let [dd [try-get [llctx/lldef-ctx [llcheck-context/bind-ctx gctx]] mem-name]]
            [match dd
              [lldef-desc/memory kind]
              [match kind
                [memory-kind/i32]
                [do
                  [todo check if value is i32 or pointer to same memory with castable target type]]
                [memory-kind/i64]
                [do
                  [todo check if value is i64 or pointer to same memory with castable target type]]]

              [logq-abort not implemented translate-top-form deref inst-type/apply]]
            [logq-abort not implemented translate-top-form deref inst-type/apply]]]
        [do]]

      inst-type]

    [llexp/deref value]
    [let [t-mem [generate-fresh-type-var-atom [llcheck-context/type-var-counter gctx] level]
          t-res [generate-fresh-type-var-atom [llcheck-context/type-var-counter gctx] level]
          pt [type-pointer t-mem t-res]]
      [llunify-report gctx pt [infer-llexp gctx level lctx value] value]
      [llannotate gctx value pt]
      [llannotate gctx bform t-res]]

    [llexp/assign target value]
    [let [t-mem [generate-fresh-type-var-atom [llcheck-context/type-var-counter gctx] level]
          t-res [generate-fresh-type-var-atom [llcheck-context/type-var-counter gctx] level]
          pt [type-pointer t-mem t-res]]
      [llunify-report gctx pt [infer-llexp gctx level lctx target] target]
      [llunify-report gctx t-res [infer-llexp gctx level lctx value] value]
      [llannotate gctx target pt]
      type-empty-tuple]

    [llexp/field target field-name]
    [let
      [ttarget [infer-llexp gctx level lctx target]
       t-mem [generate-fresh-type-var-atom [llcheck-context/type-var-counter gctx] level]
       t-res [generate-fresh-type-var-atom [llcheck-context/type-var-counter gctx] level]
       pt [type-pointer t-mem t-res]]
      [llannotate gctx target pt]
      [llunify-report gctx ttarget pt target]
      [let [type-name [pair/fst [get-apply-type t-res]]]
        [if-let [type-desc [try-get [llctx/user-types [llcheck-context/bind-ctx gctx]] type-name]]
          [match type-desc
            [user-type-desc/record field-map field-list]
            [if-let [fd [try-get field-map [syntax-word/word field-name]]]
              [let [ft [llinstantiate-type-desc [transient-kv-map] [field-desc/type fd]]
                    pft [type-pointer t-mem ft]]
                [llannotate gctx bform pft]]
              [logq-abort infer-llexp field not found [identity field-name]]]
            [logq-abort infer-llexp not a record type]]

          [logq-abort infer-llexp type not found [identity type-name]]]]]

    [do
      [log bform]
      [logq-abort infer-llexp not implemented]]]]

[defn infer-forms [gctx level lctx bodies]
  [if [is-empty bodies]
    type-empty-tuple
    [do
      [for i 0 [dec [size bodies]]
        [infer-llexp gctx level lctx [at bodies i]]]
      [infer-llexp gctx level lctx [last bodies]]]]]

[defn form-to-llexp-empty [ctx form]
  [form-to-llexp ctx [local-stack/empty] form]]

[type data []
  [union
    [bytes [list syntax-word]]
    [i32 [list syntax-word]]
    [f64 [list syntax-word]]
    ]]

[defn datas-to-byte-array [datas]
  [let
    [n-datas [size datas]
     total-size
      [loop [i 0 sum 0]
        [if [le-s n-datas i]
          sum
          [continue
            sum [add sum [match [at datas i]
                          [data/bytes bs] [size bs]
                          [data/i32 is] [mul [size is] 4]
                          [data/f64 fs] [mul [size fs] 8]]]
            i [inc i]
            ]]]
     ba [byte-array total-size]]
    [loop [i 0 offset 0]
      [if [le-s n-datas i]
        ba
        [match [at datas i]
          [data/bytes bs]
          [do
            [for j 0 [size bs]
              [byte-array-set ba [add offset j] [word-to-int [syntax-word/word [at bs j]]]]]
            [continue
              i [inc i]
              offset [add offset [size bs]]]]

          [data/i32 is]
          [do
            [loop [j 0 sis [size is]]
              [when [lt-s j sis]
                [byte-array-set-byte-array ba [add offset [mul j 4]]
                  [i32-to-byte-array [word-to-int [syntax-word/word [at is j]]]]]
                [continue j [inc j]]]]
            [continue
              i [inc i]
              offset [add offset [mul [size is] 4]]]]

          [data/f64 fs]
          [do
            [loop [j 0 sfs [size fs]]
              [when [lt-s j sfs]
                [byte-array-set-byte-array ba [add offset [mul j 8]]
                  [f64-to-byte-array [word-to-f64 [syntax-word/word [at fs j]]]]]
                [continue j [inc j]]]]
            [continue
              i [inc i]
              offset [add offset [mul [size fs] 8]]]]

            ]]]
      ba]]

[type lltype-decl-kind []
  [union
    [record [list [pair syntax-word lltype]]]
    ]]

[type lltop []
  [union
    [memory syntax-word memory-kind syntax-word [option syntax-word]]
    [type syntax-word [list syntax-word] lltype-decl-kind]
    [data-active syntax-word llexp [list data]]
    [def syntax-word llexp]
    [defn syntax-word [list syntax-word] [list llexp]]
    [export [list syntax-word]]
]]

[defn set-ll-def [ctx form def-desc]
  [set-kv-map [llctx/lldef-ctx ctx] [form-to-word form] def-desc]]

[defn form-to-lltop [ctx form]
  [let
    [report-error [func r [msg] [push-error form msg]]
     l [form-to-list form]
     n-of-args [dec [size l]]
     assert-n-args [func ana [n] [when-not [eq n-of-args n] [report-error [quote [expected n-of-args arguments]]]]]
     get-arg [func get-arg [i] [if [lt-s i n-of-args] [at l [inc i]] [quote 0]]]
     first-form [first l]]
    [match first-form
      [form/word first-word]
      [switch first-word
        [[word data]]
        [lltop/data-active
          [sword [get-arg 1]]
          [form-to-llexp-empty ctx [get-arg 2]]
          [list-map a [slice l 4 [size l]]
            [let [dl [get-list a]]
              [let [data-first [form-to-word [first dl]]]
                [switch data-first
                  [[word bytes]]
                  [data/bytes [list-map b [rest dl] [sword b]]]
                  [[word i32]]
                  [data/i32 [list-map b [rest dl] [sword b]]]
                  [[word f64]]
                  [data/f64 [list-map b [rest dl] [sword b]]]
                  [logq-abort form-to-lltop data kind not recognized]]]]]]

        [[word memory]]
        [let [mem-name [sword [get-arg 1]]
              kind
              [switch [form-to-word [get-arg 0]]
                [[word i32]] [memory-kind/i32]
                [[word i64]] [memory-kind/i64]
                [logq-abort form-to-lltop memory kind not recognized]]]
          [set-ll-def ctx [get-arg 1] [lldef-desc/memory kind]]
          [lltop/memory
            mem-name
            kind
            [sword [get-arg 2]]
            [if [lt-s n-of-args 3] [option/none] [option/some [sword [get-arg 3]]]]]]

        [[word type]]
        [do
          [assert-n-args 3]
          [let
            [type-name-form [get-arg 0]
             type-params [get-list [get-arg 1]]
             type-decl-list [get-list [get-arg 2]]
             type-env [transient-kv-map]]
            [assert-not [is-empty type-decl-list] empty type decl list]
            [for-each type-param type-params
              [let [tp [form-to-word type-param]]
                [assert-not [has type-env tp] duplicate type param]
                [set-kv-map type-env tp [lltype/var [sword type-param]]]]]
            [set-kv-map [llctx/user-type-params ctx] [form-to-word type-name-form] [list-map tp type-params [sword tp]]]
            [lltop/type [sword type-name-form] [list-map tp type-params [sword tp]]
              [switch [form-to-word [first type-decl-list]]
                [[word record]]
                [let [field-map [transient-kv-map]
                      field-list [growable-list]]
                  [for-each p [rest type-decl-list]
                    [let [ll [get-list p]]
                      [let [field-name [form-to-word [first ll]]
                            fd [field-desc [lltype-to-lltype-desc [form-to-lltype ctx type-env [second ll]]]]]
                        [push field-list [pair field-name fd]]
                        [set-kv-map field-map field-name fd]]]]
                  [set-kv-map [llctx/user-types ctx] [form-to-word type-name-form]
                    [user-type-desc/record field-map [clone-growable-to-frozen-list field-list]]]
                  [lltype-decl-kind/record [list]]]

                [logq-abort form-to-lltop type kind not implemented]]]]]

        [[word def]]
        [let [name-form [get-arg 0]]
          [assert-n-args 2]
          [set-ll-def ctx name-form [lldef-desc/any]]
          [lltop/def [sword name-form] [form-to-llexp-empty ctx [get-arg 1]]]]

        [[word defn]]
        [let [name-form [get-arg 0]
              params [get-list [get-arg 1]]
              bodies [slice l 3 [size l]]
              lvars [transient-kv-map]
              lctx [local-context lvars [local-context-kind/let]]
              lstack [local-stack/frame [local-stack/empty] lctx]]
          [set-ll-def ctx name-form [lldef-desc/func [size params]]]
          [set-local ctx lvars name-form [lllocal-var-kind/func-internal-self [size params]]]
          [assert-not [and [lt-s 1 [size params]] [eq-word [form-to-word [at params -2]] [word ..]]]
            rest param not implemented]
          [lltop/defn
            [sword name-form]
            [list-map p params
              [do
                [set-local ctx lvars p [lllocal-var-kind/param]]
                [sword p]]]
            [list-map b bodies [form-to-llexp ctx lstack b]]]]

        [[word export]]
        [lltop/export
          [list-map f [rest l]
            [let [sw [sword f]]
              [if-let [ddesc [try-get [llctx/lldef-ctx ctx] [syntax-word/word sw]]]
                [do]
                [push-error f [quote [not a defined name]]]]
              sw]]]

        [do
          [log form]
          [logq-abort form-to-lltop not implemented]]]

      [form/list fl]
      [logq-abort direct call at top not supported]]]]
   [comment   [memory syntax-word syntax-word [option syntax-word]]
    [data-active syntax-word llexp [list data]]
    [def syntax-word llexp]
    [defn syntax-word [list syntax-word] [list llexp]]
    [export [list syntax-word]] ]

[defn infer-lltop [gctx lltop]
  [match lltop
    [lltop/memory mem-name mem-kind mem-size mem-export]
    [do]

    [lltop/type type-name type-params type-decls]
    [do]

    [lltop/data-active mem-name mem-expr datas]
    [do]

    [lltop/def var value]
    [let
      [value-type [infer-llexp gctx 1 [local-stack/empty] value]
       general-val-type
        [if [is-syntactic-llvalue value]
          [generalize 0 value-type]
          [mk-empty-type-scheme value-type]]]
        [set-kv-map [llcheck-context/def-var-types gctx] [syntax-word/word var] general-val-type]]

    [lltop/defn fname params bodies]
    [let
      [level-1 1
       gen-func-type [generate-fresh-type-var-atom [llcheck-context/type-var-counter gctx] level-1]
       func-type-scheme [mk-empty-type-scheme gen-func-type]
       param-ctx [transient-kv-map]
       func-ctx [make-local-context param-ctx [local-stack/empty] [local-context-kind/func]]
       reg-params [growable-list]]
      [set-kv-map param-ctx [syntax-word/word fname] func-type-scheme]
      [for-each param params
        [let [tv [generate-fresh-type-var-atom [llcheck-context/type-var-counter gctx] level-1]]
          [set-kv-map param-ctx [syntax-word/word param] [mk-empty-type-scheme tv]]
          [push reg-params tv]]]
      [let [return-type [infer-forms gctx level-1 func-ctx bodies]]
        [llunify-report gctx
          gen-func-type
          [ctype/inst
            [inst-type/func
              [func-type
                [clone-growable-to-frozen-list reg-params]
                [option/none]
                return-type
                [function-kind/func]]]]
          lltop]
        [llannotate gctx lltop gen-func-type]
        [set-kv-map [llcheck-context/def-var-types gctx] [syntax-word/word fname] [generalize 0 gen-func-type]]
        [do]]]

    [lltop/export es]
    [let [bind-ctx [llcheck-context/bind-ctx gctx]
          lldef-ctx [llctx/lldef-ctx bind-ctx]]
      [for-each e es
        [match [get lldef-ctx [syntax-word/word e]]
          [lldef-desc/memory kind] [do]
          [do
            [llannotate gctx e [get-specialized-var gctx 0 [local-stack/empty] [syntax-word/word e]]]
            [do]]]]]
]]

[defn get-ctype [gctx bform]
  [match bform
    [llexp/literal l]
    [match l
      [llliteral/i32 i] type-i32
      [llliteral/f64 f] type-f64
      [logq-abort get-ctype literal not implemented]]

    [llexp/intrinsic inst-name imm ica]
    [ifs
      [is-i32-bin-inst [syntax-word/word inst-name]]
      type-i32

      [is-f64-bin-inst [syntax-word/word inst-name]]
      type-f64

      [is-f64-comp-inst [syntax-word/word inst-name]]
      type-i32

      [logq-abort intrinsic not implemented]]

    [llexp/do forms]
    [if [is-empty forms]
      type-empty-tuple
      [get-ctype gctx [last forms]]]

    [llexp/let bindings forms]
    [if [is-empty forms]
      type-empty-tuple
      [get-ctype gctx [last forms]]]

    [llexp/loop bindings forms]
    [if [is-empty forms]
      type-empty-tuple
      [get-ctype gctx [last forms]]]

    [llexp/cast cast-type value]
    [llinstantiate-syntax-type [transient-kv-map] cast-type]

    [llexp/assign target value]
    type-empty-tuple

    [if-let [anno [try-get [llcheck-context/type-annotations gctx] [to-js-value bform]]]
      anno
      [do
        [log bform]
        [logq-abort get-ctype-from-form-or-annotation expected an annotation]]]]]

[type wat-type-basic []
  [union
    [i32]
    [i64]
    [f32]
    [f64]]]

[type wat-inst-memargs []
  [record
    [memory word]
    [offset word]
    [alignment word]]]

[type wat-inst []
  [union
    [i32.const word]
    [i64.const word]
    [f32.const word]
    [f64.const word]
    [local.get word]
    [local.set word wat-inst]
    [global.get word]
    [inst byte-array [list wat-inst]]
    [load byte-array wat-inst-memargs wat-inst]
    [store byte-array wat-inst-memargs wat-inst wat-inst]
    [if [list wat-type-basic] wat-inst wat-inst wat-inst]
    [call word [list wat-inst]]
    [instructions [list wat-inst]]
    [loop word [list wat-type-basic] wat-inst]
    [br word]]]

[type output-func []
  [record
    [name word]
    [parameters [list [pair word wat-type-basic]]]
    [locals [list [pair word wat-type-basic]]]
    [result [list wat-type-basic]]
    [body wat-inst]]]

[type import-kind []
  [union
    [memory word i32]]]

[type export-kind []
  [union [func] [global] [memory]]]

[type wat-global []
  [record
    [name word]
    [type wat-type-basic]
    [value wat-inst]]]

[type wat-data []
  [union
    [active word wat-inst byte-array]]]

[type wat-memory []
  [record
    [kind memory-kind]
    [name word]
    [initial i32]
    [maximum [option i32]]]]

[type wat-output []
  [record
    [imports [growable-list [pair [list word] import-kind]]]
    [memories [growable-list wat-memory]]
    [globals [growable-list wat-global]]
    [funcs [growable-list output-func]]
    [exports [growable-list [pair word [pair export-kind word]]]]
    [datas [growable-list wat-data]]]]

[type translate-context []
  [record
    [output wat-output]
    [check-context llcheck-context]
    ]]

[defn llctx-from-translate [tctx]
  [llcheck-context/bind-ctx
     [translate-context/check-context tctx]]]

[defn translate-type [tctx it]
  [match [normalize-type it]
    [ctype/inst inst-type]
    [match inst-type
      [inst-type/apply type-name type-args]
      [switch type-name
        [[word i32]] [wat-type-basic/i32]
        [[word f64]] [wat-type-basic/f64]
        [[word pointer]]
        [let
          [mem-name [mem-name-from-mem-type [first type-args]]]
          [if-let [mem [try-get [llctx/lldef-ctx [llctx-from-translate tctx]] mem-name]]
            [match mem
              [lldef-desc/memory kind]
              [match kind
                [memory-kind/i32]
                [do
                  [todo check pointer memory type]
                  [wat-type-basic/i32]]
                [memory-kind/i64]
                [do
                  [todo check pointer memory type]
                  [wat-type-basic/i64]]]
              [logq-abort translate-type memory not found]]
            [logq-abort translate-type memory not found]]]
        [do [log it] [logq-abort not implemented translate-type inst-type/apply]]]

      [do [log it] [logq-abort not implemented translate-type inst-type/apply]]]
    [do [log it] [logq-abort not implemented translate-type inst-type/apply]]]]

[defn translate-types [tctx it]
  [match [normalize-type it]
    [ctype/inst inst-type]
    [match inst-type
      [inst-type/apply type-name type-args]
      [switch type-name
        [[word tuple]] [list-map ta type-args [translate-type tctx ta]]

        [list [translate-type tctx it]]]
      [do [log it] [logq-abort not implemented translate-types inst-type/apply]]]
    [do [log it] [logq-abort not implemented translate-types inst-type/apply]]]]

[defn get-annotation [tctx bst]
  [if-let [anno [try-get [llcheck-context/type-annotations [translate-context/check-context tctx]] [to-js-value bst]]]
    anno
    [do
      [log bst]
      [logq-abort get-annotation expected an annotation]]]]

[defn make-wat-output []
  [wat-output
    [growable-list]
    [growable-list]
    [growable-list]
    [growable-list]
    [growable-list]
    [growable-list]]]

[def drop-name-byte-array [wasm-name-to-wat-byte-array [word drop]]]

[defn wat-inst-drop [i]
  [wat-inst/inst drop-name-byte-array [list i]]]

[defn sizeof [type-env t]
  [match t
    [lltype-desc/var tv]
    [logq-abort sizeof not implemented]
    [lltype-desc/apply type-name type-args]
    [switch type-name
      [[word i32]] 4
      [[word f64]] 8
      [logq-abort not implemented translate-top-form deref inst-type/apply]]]]

[defn translate-top-form [tctx bform]
  [let [output [translate-context/output tctx]
        cctx [translate-context/check-context tctx]
        form-to-ldesc [llctx/form-to-ldesc [llctx-from-translate tctx]]
        type-annos [llcheck-context/type-annotations cctx]
        ldesc-to-index [transient-kv-map]
        lvar-to-name
          [func lvar-to-name [lvar-sname]
            [if-let [ldesc [try-get form-to-ldesc [syntax-word-get-form lvar-sname]]]
              [let [w [syntax-word/word lvar-sname]]
                w]
              [do
                [log lvar-sname]
                [logq-abort lvar-to-name expected local var]]]]
        get-form-types [func get-form-types [form] [translate-types tctx [get-ctype cctx form]]]]
  [letfn
    [
  [func go-forms [forms]
    [if [is-empty forms]
      [list]
      [concat
        [list-map form [slice forms 0 [dec [size forms]]]
          [loop [res [go form] i [size [get-form-types form]]]
              [if i
                [continue
                  res [wat-inst-drop res]
                  i [dec i]]
                res]]]
        [list [go [last forms]]]]]]
  [func go [form]
    [match form
      [llexp/var sw]
      [let [w [syntax-word/word sw]]
        [if-let [ldesc [try-get form-to-ldesc [syntax-word-get-form sw]]]
          [do
            [if-let [index [try-get ldesc-to-index ldesc]]
              [wat-inst/local.get [concat-words w [int-to-word index]]]
              [wat-inst/local.get w]]]
          [wat-inst/global.get w]]]

      [llexp/literal l]
      [match l
        [llliteral/i32 i] [wat-inst/i32.const [syntax-word/word i]]
        [llliteral/i64 i] [wat-inst/i64.const [syntax-word/word i]]
        [llliteral/f32 f] [wat-inst/f32.const [syntax-word/word f]]
        [llliteral/f64 f] [wat-inst/f64.const [syntax-word/word f]]
        ]

      [llexp/do forms]
      [wat-inst/instructions [go-forms forms]]

      [llexp/if cond true false]
      [wat-inst/if
        [get-form-types form]
        [go cond]
        [go true]
        [go false]]

      [llexp/intrinsic inst-name imm-args args]
      [wat-inst/inst
        [wasm-name-to-wat-byte-array [syntax-word/word inst-name]]
        [list-map arg args [go arg]]]

      [llexp/call w args]
      [wat-inst/call [syntax-word/word w] [list-map a args [go a]]]

      [llexp/let bindings body]
      [wat-inst/instructions
        [concat
          [list-map b bindings
            [wat-inst/local.set [lvar-to-name [pair/fst b]] [go [pair/snd b]]]]
          [go-forms body]]]

      [llexp/loop bindings body]
      [wat-inst/instructions
        [concat
          [list-map b bindings
            [wat-inst/local.set [lvar-to-name [pair/fst b]] [go [pair/snd b]]]]
          [list
            [wat-inst/loop
              [word loop-label]
              [get-form-types form]
              [wat-inst/instructions
                [go-forms body]]]]]]

      [llexp/continue assignments]
      [wat-inst/instructions
        [concat
          [list-map a assignments
            [wat-inst/local.set [lvar-to-name [pair/fst a]] [go [pair/snd a]]]]
          [list [wat-inst/br [word loop-label]]]]]

      [llexp/cast cast-type value]
      [go value]

      [llexp/deref target]
      [let
        [pt [get-apply-type [get-ctype cctx target]]]
        [assert [eq-word [pair/fst pt] [word pointer]]]
        [let [ptargs [pair/snd pt]
              tmem [first ptargs]
              mem-name [mem-name-from-mem-type tmem]
              target-ap-t [get-apply-type [second ptargs]]
              ttarget-name [pair/fst target-ap-t]
              load-inst-name
              [switch ttarget-name
                [[word i32]] [word i32.load]
                [[word f64]] [word f64.load]
                [[word pointer]]
                [if-let [dd [try-get [llctx/lldef-ctx [llctx-from-translate tctx]] [mem-name-from-mem-type [first [pair/snd target-ap-t]]]]]
                  [match dd
                    [lldef-desc/memory kind]
                    [match kind
                      [memory-kind/i32] [word i32.load]
                      [memory-kind/i64] [word i64.load]]

                    [logq-abort not implemented translate-top-form deref inst-type/apply]]
                  [logq-abort not implemented translate-top-form deref inst-type/apply]]
                [logq-abort not implemented translate-top-form deref inst-type/apply]]]
        [wat-inst/load
          [wasm-name-to-wat-byte-array load-inst-name]
          [wat-inst-memargs
            mem-name
            [word 0]
            [word 1]]
          [go target]]]]

      [llexp/field target field-name]
      [let
        [pt [get-apply-type [get-ctype cctx target]]
         field-name-word [syntax-word/word field-name]]
        [assert [eq-word [pair/fst pt] [word pointer]]]
        [let [ptargs [pair/snd pt]
              tmem [first ptargs]
              mem-name [mem-name-from-mem-type tmem]
              ttarget [get-apply-type [second ptargs]]
              ttarget-name [pair/fst ttarget]
              bctx [llctx-from-translate tctx]
              offset-type
              [if-let [dd [try-get [llctx/user-types bctx] ttarget-name]]
                [match dd
                  [user-type-desc/record field-map field-list]
                  [let
                    [tv [transient-kv-map]]
                    [loop [i 0 offset 0]
                        [if [lt-s i [size field-list]]
                          [let [fp [at field-list i]
                                ft [field-desc/type [pair/snd fp]]]
                            [if [eq-word field-name-word [pair/fst fp]]
                              [pair offset ft]
                              [continue
                                i [inc i]
                                offset [add offset [sizeof tv ft]]]]]
                          [logq-abort field not found]]]]
                  [logq-abort not a record type]]
                [logq-abort not implemented translate-top-form field inst-type/apply]]]
        [wat-inst/inst
          [wasm-name-to-wat-byte-array [word i32.add]]
          [list
            [wat-inst/i32.const [int-to-word [pair/fst offset-type]]]
            [go target]]]]]

      [llexp/assign target value]
      [let
        [pt [get-apply-type [get-ctype cctx target]]]
        [assert [eq-word [pair/fst pt] [word pointer]]]
        [let [ptargs [pair/snd pt]
              tmem [first ptargs]
              mem-name [pair/fst [get-apply-type [first [pair/snd [get-apply-type tmem]]]]]
              ttarget [second ptargs]
              ttarget-name [pair/fst [get-apply-type ttarget]]
              store-inst-name
              [switch ttarget-name
                [[word i32]] [word i32.store]
                [[word f64]] [word f64.store]
                [[word pointer]]
                [if-let [dd [try-get [llctx/lldef-ctx [llctx-from-translate tctx]] mem-name]]
                  [match dd
                    [lldef-desc/memory kind]
                    [match kind
                      [memory-kind/i32] [word i32.store]
                      [memory-kind/i64] [word i64.store]]

                    [logq-abort not implemented translate-top-form deref inst-type/apply]]
                  [logq-abort not implemented translate-top-form deref inst-type/apply]]
                [logq-abort not implemented translate-top-form deref inst-type/apply]]]
        [wat-inst/store
          [wasm-name-to-wat-byte-array store-inst-name]
          [wat-inst-memargs
            mem-name
            [word 0]
            [word 1]]
          [go target]
          [go value]]]]

      [do
        [log form]
        [logq-abort not implemented translate-form]]]]]
  [match bform
    [lltop/memory name kind init-size opt-max]
    [push [wat-output/memories output]
      [wat-memory
        kind
        [syntax-word/word name]
        [word-to-int [syntax-word/word init-size]]
        [if-let [max opt-max]
          [option/some [word-to-int [syntax-word/word max]]]
          [option/none]]]]

    [lltop/def name value]
    [match value
      [llexp/literal l]
      [let
        [t
         [match l
          [llliteral/i32 i] [wat-type-basic/i32]
          [llliteral/f64 f] [wat-type-basic/f64]
          [logq-abort translate-top-form not implemented def literal]]]
        [push [wat-output/globals output]
          [wat-global
            [syntax-word/word name]
            t
            [go value]]]]

      [do
        [log bform]
        [logq-abort translate-top-form def kind not implemented]]]

    [lltop/defn fname params bodies]
    [let [t [get [llcheck-context/type-annotations [translate-context/check-context tctx]] [to-js-value bform]]
          ft [get-func-type t]
          param-types [func-type/params ft]
          gparams [growable-list]
          glocals [growable-list]
          local-names [transient-kv-map]]
      [assert [eq [size params] [size param-types]] expected matching number of parameters and types]
      [for i 0 [size params]
        [push gparams
          [pair [syntax-word/word [at params i]] [translate-type tctx [at param-types i]]]]]
      [let
        [add-binding
          [func ab [b]
            [let [sname [pair/fst b]
                  name [syntax-word/word sname]
                  name-index
                  [if-let [ldesc [try-get form-to-ldesc [syntax-word-get-form sname]]]
                    [let [index [kv-map-size ldesc-to-index]]
                      name]
                    [do
                      [log name]
                      [when-let [form [syntax-word/opt-form sname]]
                        [log-location form]
                        ]
                      [logq-abort translate-top-form expected a local description]]]]
              [push glocals [pair name-index [translate-type tctx [get-ctype cctx [pair/snd b]]]]]]]
         proc
          [llexp-recur
            [func f [bform]
              [match bform
                [llexp/let bs body]
                [for-each b bs [add-binding b]]

                [llexp/loop bs body]
                [for-each b bs [add-binding b]]

                [do]]
              true]]]
        [for-each b bodies [proc b]]]
      [push
        [wat-output/funcs output]
        [output-func
          [syntax-word/word fname]
          [clone-growable-to-frozen-list gparams]
          [clone-growable-to-frozen-list glocals]
          [translate-types tctx [func-type/result ft]]
          [wat-inst/instructions [go-forms bodies]]]]]

    [lltop/export snames]
    [for-each sname snames
      [let [export-kind
            [if-let [dd [try-get [llctx/lldef-ctx [llctx-from-translate tctx]] [syntax-word/word sname]]]
              [match dd
                [lldef-desc/memory kind]
                [export-kind/memory]

                [lldef-desc/func arity]
                [export-kind/func]

                [lldef-desc/any]
                [match [normalize-type [get-annotation tctx sname]]
                  [ctype/inst inst-type]
                  [match inst-type
                    [inst-type/func func-type]
                    [export-kind/func]

                    [export-kind/global]]]]
              [match [normalize-type [get-annotation tctx sname]]
                [ctype/inst inst-type]
                [match inst-type
                  [inst-type/func func-type]
                  [export-kind/func]

                  [export-kind/global]]]]]
        [push
          [wat-output/exports output]
          [pair [syntax-word/word sname] [pair export-kind [syntax-word/word sname]]]]]]

    [lltop/data-active mem-name offset-form datas]
    [do
      [push
        [wat-output/datas output]
        [wat-data/active
          [syntax-word/word mem-name]
          [go offset-form]
          [datas-to-byte-array datas]]]]

      [lltop/type type-name type-params type-decls]
      [do]

    [do
      [log bform]
      [logq-abort not implemented translate-top-form bform]]]]]]

[def ascii-line-feed [i32 10]]
[def ascii-space [i32 32]]
[def ascii-double-quote [i32 34]]
[def ascii-dollar [i32 36]]
[def ascii-left-paren [i32 40]]
[def ascii-right-paren [i32 41]]
[def ascii-equal [i32 61]]
[def ascii-backslash [i32 92]]

[type printer []
  [record
    [bytes [atom byte-array]]
    [index [atom i32]]]]

[defn empty-printer [init-capacity]
  [printer [atom [byte-array init-capacity]] [atom 0]]]

[defn printer-to-byte-array [p]
  [let
    [ci [atom-get [printer/index p]]
     cb [atom-get [printer/bytes p]]
     trimmed [byte-array ci]]
    [for i 0 ci
      [byte-array-set trimmed i [byte-array-get cb i]]]
    trimmed]]

[defn print-byte [printer byte]
  [let [ia [printer/index printer]
        i [atom-get ia]
        ba [printer/bytes printer]
        a [atom-get ba]]
    [assert [lt-s i [byte-array-size a]] printer buffer overflow]
    [byte-array-set a i byte]
    [atom-set [printer/index printer] [inc i]]]]

[defn print-word [printer word]
  [for i 0 [word-byte-size word]
    [print-byte printer [char-code-at word i]]]]

[defn int-to-hex-ascii [i]
  [if [lt-s i [i32 10]]
    [add i [i32 48]]
    [add [sub i [i32 10]] [i32 97]]]]

[defn i32-to-hex-bits [n-bits value]
  [let [gl [growable-list]]
    [loop [n-start [sub n-bits 4]
           index [intrinsic i32.shl [i32 15] n-start]
           i n-start]
      [when index
        [push gl [int-to-hex-ascii [intrinsic i32.shr-u [intrinsic i32.and value index] i]]]
        [continue
          index [intrinsic i32.shr-u index [i32 4]]
          i [sub i 4]]]]
    [code-points-to-word [clone-growable-to-frozen-list gl]]]]

[defn i32-to-hex-32 [value]
  [i32-to-hex-bits [i32 32] value]]

[defn i32-to-hex-8 [value]
  [i32-to-hex-bits [i32 8] value]]

[defn print-string-chars [printer word]
  [for i 0 [byte-array-size word]
    [let [cc [byte-array-get word i]]
      [if [or [lt-s cc [i32 32]] [lt-s [i32 126] cc]]
        [do
          [print-byte printer ascii-backslash]
          [print-word printer [i32-to-hex-8 cc]]]
        [print-byte printer cc]]]]]

[type wat []
  [union
    [word word]
    [byte-array byte-array]
    [dollar word]
    [dqstring word]
    [dqstring-bytes byte-array]
    [seq [list wat]]
    [list [list wat]]
    [eq-pair word word]]]

[defn print-wat [printer wat]
  [match wat
    [wat/word w] [print-word printer w]
    [wat/byte-array ba]
      [for i 0 [byte-array-size ba]
        [print-byte printer [byte-array-get ba i]]]
    [wat/dollar w] [do [print-byte printer ascii-dollar] [print-word printer w]]
    [wat/dqstring w] [do [print-byte printer ascii-double-quote] [print-word printer w] [print-byte printer ascii-double-quote]]
    [wat/dqstring-bytes ba] [do [print-byte printer ascii-double-quote] [print-string-chars printer ba] [print-byte printer ascii-double-quote]]
    [wat/seq l]
      [do
        [when-not [is-empty l]
          [print-wat printer [first l]]
          [for i 1 [size l]
            [print-byte printer ascii-space]
            [print-wat printer [at l i]]]]]
    [wat/list l]
      [do
        [print-byte printer ascii-left-paren]
        [when-not [is-empty l]
          [print-wat printer [first l]]
          [for i 1 [size l]
            [print-byte printer ascii-space]
            [print-wat printer [at l i]]]]
        [print-byte printer ascii-right-paren]]
    [wat/eq-pair w1 w2]
      [do
        [print-word printer w1]
        [print-byte printer ascii-equal]
        [print-word printer w2]]]]

[defn wat-list [.. l] [wat/list l]]

[defn wat-type-basic-to-word [t]
  [match t
    [wat-type-basic/i32] [word i32]
    [wat-type-basic/i64] [word i64]
    [wat-type-basic/f32] [word f32]
    [wat-type-basic/f64] [word f64]]]

[defn wat-concat [.. l] [wat/list [concat-lists l]]]

[defn wat-inst-memargs-to-out [ma]
  [list
    [wat-list [wat/word [word memory]] [wat/dollar [wat-inst-memargs/memory ma]]]
    [wat/eq-pair [word offset] [wat-inst-memargs/offset ma]]
    [wat/eq-pair [word align] [wat-inst-memargs/alignment ma]]]]

[defn wat-inst-to-out [i]
  [match i
    [wat-inst/i32.const w]
    [wat-list [wat/word [word i32.const]] [wat/word w]]

    [wat-inst/i64.const w]
    [wat-list [wat/word [word i64.const]] [wat/word w]]

    [wat-inst/f32.const w]
    [wat-list [wat/word [word f32.const]] [wat/word w]]

    [wat-inst/f64.const w]
    [wat-list [wat/word [word f64.const]] [wat/word w]]

    [wat-inst/inst w args]
    [wat-concat
      [list [wat/byte-array w]] [list-map a args [wat-inst-to-out a]]]

    [wat-inst/local.get w]
    [wat-list [wat/word [word local.get]] [wat/dollar w]]

    [wat-inst/local.set w e]
    [wat-list [wat/word [word local.set]] [wat/dollar w] [wat-inst-to-out e]]

    [wat-inst/global.get w]
    [wat-list [wat/word [word global.get]] [wat/dollar w]]

    [wat-inst/load name ma addr]
    [wat-concat
      [list [wat/byte-array name]]
      [wat-inst-memargs-to-out ma]
      [list [wat-inst-to-out addr]]]

    [wat-inst/store name ma addr value]
    [wat-concat
      [list [wat/byte-array name]]
      [wat-inst-memargs-to-out ma]
      [list [wat-inst-to-out addr] [wat-inst-to-out value]]]

    [wat-inst/instructions insts]
    [wat/seq [list-map inst insts [wat-inst-to-out inst]]]

    [wat-inst/if result-types cond true false]
    [wat-list [wat/word [word if]]
      [wat/list
        [concat [list [wat/word [word result]]]
          [list-map rt result-types [wat/word [wat-type-basic-to-word rt]]]]]
      [wat-inst-to-out cond]
      [wat-list [wat/word [word then]] [wat-inst-to-out true]]
      [wat-list [wat/word [word else]] [wat-inst-to-out false]]]

    [wat-inst/call w args]
    [wat-concat
      [list [wat/word [word call]] [wat/dollar w]]
      [list-map a args [wat-inst-to-out a]]]

    [wat-inst/loop loop-label result-types body]
    [wat-list
      [wat/word [word loop]]
      [wat/dollar loop-label]
      [wat/list
        [concat [list [wat/word [word result]]]
          [list-map rt result-types [wat/word [wat-type-basic-to-word rt]]]]]
      [wat-inst-to-out body]]

    [wat-inst/br w]
    [wat-list [wat/word [word br]] [wat/dollar w]]

    [logq-abort wat-inst-to-out unknown instruction]]]

[defn import-to-wat [import]
  [match [pair/snd import]
    [import-kind/memory name init-size]
    [wat-list
      [wat/word [word memory]]
      [wat/dollar name]
      [wat/word [int-to-word init-size]]]]]

[defn memory-to-wat [mem]
  [wat-list
    [wat/word [word memory]]
    [wat/dollar [wat-memory/name mem]]
    [wat/word [match [wat-memory/kind mem]
      [memory-kind/i32] [word i32]
      [memory-kind/i64] [word i64]]]
    [wat/word [int-to-word [wat-memory/initial mem]]]]]

[defn global-to-wat [global]
  [wat-list
    [wat/word [word global]]
    [wat/dollar [wat-global/name global]]
    [wat/word [wat-type-basic-to-word [wat-global/type global]]]
    [wat-inst-to-out [wat-global/value global]]]]

[defn output-func-to-wat [of]
  [wat-concat
    [list
      [wat/word [word func]]
      [wat/dollar [output-func/name of]]]
    [list-map p [output-func/parameters of]
      [wat-list [wat/word [word param]] [wat/dollar [pair/fst p]] [wat/word [wat-type-basic-to-word [pair/snd p]]]]]
    [list
      [wat-concat
        [list [wat/word [word result]]]
        [list-map rt [output-func/result of] [wat/word [wat-type-basic-to-word rt]]]]]
    [list-map l [output-func/locals of]
      [wat-list [wat/word [word local]] [wat/dollar [pair/fst l]] [wat/word [wat-type-basic-to-word [pair/snd l]]]]]
    [list
      [wat-inst-to-out [output-func/body of]]]]]

[defn export-to-wat [p]
  [wat-concat
    [list
      [wat/word [word export]]
      [wat/dqstring [pair/fst p]]
      [let [kind-pair [pair/snd p]]
        [wat-list
          [wat/word
            [match [pair/fst kind-pair]
              [export-kind/func] [word func]
              [export-kind/memory] [word memory]
              [export-kind/global] [word global]
              [logq-abort export-to-wat unknown export kind]]]
          [wat/dollar [pair/snd kind-pair]]]]]]]

[defn data-to-wat [d]
  [match d
    [wat-data/active mem-name offset data]
    [wat-list
      [wat/word [word data]]
      [wat-list [wat/word [word memory]] [wat/dollar mem-name]]
      [wat-inst-to-out offset]
      [wat/dqstring-bytes data]]]]

[defn output-to-wat [output]
  [wat/seq
    [concat-lists
      [list
        [list-map imp [clone-growable-to-frozen-list [wat-output/imports output]] [import-to-wat imp]]
        [list-map mem [clone-growable-to-frozen-list [wat-output/memories output]] [memory-to-wat mem]]
        [list-map g [clone-growable-to-frozen-list [wat-output/globals output]] [global-to-wat g]]
        [list-map d [clone-growable-to-frozen-list [wat-output/datas output]] [data-to-wat d]]
        [list-map of [clone-growable-to-frozen-list [wat-output/funcs output]] [output-func-to-wat of]]
        [list-map e [clone-growable-to-frozen-list [wat-output/exports output]] [export-to-wat e]]]]]]

[comment  [defn translate-top-forms-async [forms]
  [let
    [converter [mk-form-to-ast]
     sinfo [form-to-ast-converter/syntax-info converter]
     f2t [form-to-ast-converter/form-to-top-async converter]]
    [promise-then
      [promises-seq forms f2t]
      [func then [btops]
        [let
          [bind-errors [clone-growable-to-frozen-list [form-to-ast-converter/errors converter]]
           gctx [make-global-context-from-syntax-info sinfo]
           ctop [checker/check-top [make-checker gctx]]
           output [make-wat-output]
           tctx [translate-context output gctx]
           ]
          [for-each btop btops
            [ctop btop]
            [let [check-errors [clone-growable-to-frozen-list [check-context/messages gctx]]]
              [when-not [is-empty check-errors]
                [for-each error check-errors [log-check-message error]]
                [logq-abort translate-top-forms-async binding errors]]]]
          [for-each btop btops
            [translate-top-form tctx btop]]
          output]]]]] ]

[defn translate-top-forms-sync [forms]
  [let
    [form-to-ldesc [transient-kv-map]
     ctx [llctx [transient-kv-map] form-to-ldesc [transient-kv-map] [transient-kv-map]]
     gctx
     [llcheck-context
      [growable-list]
      [transient-kv-map]
      [atom 0]
      [transient-kv-map]
      ctx]
     output [make-wat-output]
     tctx [translate-context output gctx]]
    [for-each form forms
      [let [btop [form-to-lltop ctx form]]
        [let [check-errors [clone-growable-to-frozen-list [llcheck-context/messages gctx]]]
            [when-not [is-empty check-errors]
              [for-each error check-errors [log-check-message error]]
              [logq-abort translate-top-forms-sync binding errors]]]
        [infer-lltop gctx btop]
        [translate-top-form tctx btop]]]
    output]]

[defmacro def-wasm-extern [name type]
  [flist [quote import] [quote ./runtime-lib/wasm.js] name type]]

[type wasm-module [] [union]]

[def-wasm-extern byte-array-to-wasm-module [func [byte-array] wasm-module]]

[import ./runtime-lib/wabt.js wat-to-byte-array [func [byte-array] byte-array]]

[defn output-to-wat-bytes [output]
  [let [p [empty-printer [i32 10000]]]
    [print-wat p [output-to-wat output]]
    [wat-to-byte-array [printer-to-byte-array p]]]]

[defn translate-top-forms-to-wat-bytes [forms]
  [output-to-wat-bytes [translate-top-forms-sync forms]]]

[defn translate-top-forms-to-module [forms]
  [byte-array-to-wasm-module [output-to-wat-bytes [translate-top-forms-sync forms]]]]
