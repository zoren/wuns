[load bind-infer-low-level.wuns]

[comment a type for integer expressions generated by size-of]
[type integer-exp []
  [union
    [const i32]
    [add integer-exp integer-exp]
    [mul integer-exp integer-exp]
    [exp llexp]]]

[def int-const-0 [integer-exp/const 0]]
[def int-const-1 [integer-exp/const 1]]
[def int-const-2 [integer-exp/const 2]]
[def int-const-4 [integer-exp/const 4]]
[def int-const-8 [integer-exp/const 8]]
[def int-const-16 [integer-exp/const [i32 16]]]

[defn try-get-int-const [e]
  [match e
    [integer-exp/const i] [option/some i]
    [option/none]]]

[defn int-exp-add [a b]
  [if-let [i [try-get-int-const a]]
    [if [eq i 0]
      b
      [if-let [j [try-get-int-const b]]
        [integer-exp/const [add i j]]
        [integer-exp/add a b]]]
    [if-let [j [try-get-int-const b]]
      [if [eq j 0]
        a
        [integer-exp/add a b]]
      [integer-exp/add a b]]]]

[defn int-exp-mul [a b]
  [if-let [i [try-get-int-const a]]
    [ifs
      [eq i 0] int-const-0
      [eq i 1] b
      [if-let [j [try-get-int-const b]]
        [integer-exp/const [mul i j]]
        [integer-exp/mul a b]]]
    [if-let [j [try-get-int-const b]]
      [ifs
        [eq j 0] int-const-0
        [eq j 1] a
        [integer-exp/mul a b]]
      [integer-exp/mul a b]]]]

[defn type-to-size-of-integer-exp [check-ctx]
  [func type-to-size [it]
    [match [normalize-type it]
      [ctype/var tv]
      [logq-abort size-of type var not bound [identity tv]]

      [ctype/inst inst]
      [match inst
        [ctype-inst/literal l]
        int-const-4

        [ctype-inst/primitive pt]
        [integer-exp/const [intrinsic i32.div-s [primitive-type/bits pt] 8]]

        [ctype-inst/record field-list]
        [loop [cur-size int-const-0 i 0 n [size field-list]]
          [if [lt-s i n]
            [let [fd [at field-list i]]
              [continue
                cur-size
                  [int-exp-add cur-size
                    [type-to-size [pair/snd fd]]]
                i [inc i]]]
            cur-size]]

        [ctype-inst/pointer mem-type target-type]
        [let [pt [primitive-type/bits
                  [get-memory-pointer-type
                    [llcheck-context/bind-ctx check-ctx]
                    [mem-name-from-mem-type mem-type]]]]
          [integer-exp/const [intrinsic i32.div-s pt 8]]]

        [ctype-inst/array element-type size-type]
        [let [size-exp
          [match size-type
            [ctype/var tv]
            [logq-abort size-of array not implemented [identity size-type]]

            [ctype/inst inst]
            [match inst
              [ctype-inst/literal l]
              [match l
                [ctype-literal/exp e]
                [integer-exp/exp e]

                [ctype-literal/i32 i]
                [integer-exp/const i]

                [ctype-literal/memory m]
                [logq-abort size-of not implemented memory literal]]

              [logq-abort size-of not implemented]]

            [logq-abort size-of array not implemented [identity size-type]]]]
          [int-exp-mul [type-to-size element-type] size-exp]]

        [ctype-inst/apply type-name type-args]
        [if-let [inst-cuser-desc [try-get [llcheck-context/user-types check-ctx] type-name]]
          [type-to-size [ctype-desc/type inst-cuser-desc]]
          [logq-abort size-of not a user type]]]]]]

[defn get-annotation [cctx bst]
  [if-let [anno [try-get [llcheck-context/type-annotations cctx] [to-js-value bst]]]
    anno
    [logq-abort get-annotation expected an annotation [identity bst]]]]

[defn get-ctype [gctx outer-bform]
  [letfn [
    [func form-to-ctype [bform]
      [match bform
        [llexp/literal l]
        [match l
          [llliteral/i32 i] type-i32
          [llliteral/f64 f] type-f64
          [logq-abort get-ctype literal not implemented]]

        [llexp/intrinsic inst-name imm ica]
        [if-let [param-return-pair [try-get intrinsic-types-map [syntax-word/word inst-name]]]
          [ctype/inst [ctype-inst/primitive [pair/snd param-return-pair]]]
          [logq-abort intrinsic not implemented]]

        [llexp/do forms]
        [forms-to-ctype forms]

        [llexp/let bindings forms]
        [forms-to-ctype forms]

        [llexp/loop bindings forms]
        [forms-to-ctype forms]

        [llexp/assign target value]
        type-empty-tuple

        [llexp/size-of t]
        type-i32

        [get-annotation gctx bform]]]
    [func forms-to-ctype [forms]
      [if [is-empty forms]
        type-empty-tuple
        [form-to-ctype [last forms]]]]]
  [form-to-ctype outer-bform]]]

[type wat-inst-memargs []
  [record
    [memory word]
    [offset word]
    [alignment word]]]

[type wat-inst []
  [union
    [i32.const word]
    [i64.const word]
    [f32.const word]
    [f64.const word]
    [local.get word]
    [local.set word wat-inst]
    [global.get word]
    [inst-word word [list wat-inst]]
    [inst byte-array [list wat-inst]]
    [load byte-array wat-inst-memargs wat-inst]
    [store byte-array wat-inst-memargs wat-inst wat-inst]
    [if [list word] wat-inst wat-inst wat-inst]
    [call word [list wat-inst]]
    [instructions [list wat-inst]]
    [loop word [list word] wat-inst]
    [br word]]]

[def ascii-underscore [i32 95]]

[comment wuns does not have underscores so we convert dashes to underscores]

[defn wasm-name-to-wat-byte-array [w]
  [let [sw [word-byte-size w]
        res [byte-array sw]]
    [for i 0 sw
      [byte-array-set res i
        [let [c [char-code-at w i]] [if [eq c [word-to-char-code -]] ascii-underscore c]]]]
    res]]

[defn wat-inst-word [inst-name .. args]
  [wat-inst/inst-word inst-name args]]

[defn wat-inst-drop [i] [wat-inst-word [word drop] i]]

[defn wat-inst-i32.add [a b] [wat-inst-word [word i32.add] a b]]
[defn wat-inst-i32.mul [a b] [wat-inst-word [word i32.mul] a b]]

[defn datas-to-byte-array [datas]
  [let
    [n-datas [size datas]
     total-size
      [loop [i 0 sum 0]
        [if [le-s n-datas i]
          sum
          [continue
            sum [add sum [match [at datas i]
                          [data/bytes bs] [size bs]
                          [data/i32 is] [mul [size is] 4]
                          [data/f64 fs] [mul [size fs] 8]]]
            i [inc i]
            ]]]
     ba [byte-array total-size]]
    [loop [i 0 offset 0]
      [if [le-s n-datas i]
        ba
        [match [at datas i]
          [data/bytes bs]
          [do
            [for j 0 [size bs]
              [byte-array-set ba [add offset j] [word-to-int [syntax-word/word [at bs j]]]]]
            [continue
              i [inc i]
              offset [add offset [size bs]]]]

          [data/i32 is]
          [do
            [loop [j 0 sis [size is]]
              [when [lt-s j sis]
                [byte-array-set-byte-array ba [add offset [mul j 4]]
                  [i32-to-byte-array [word-to-int [syntax-word/word [at is j]]]]]
                [continue j [inc j]]]]
            [continue
              i [inc i]
              offset [add offset [mul [size is] 4]]]]

          [data/f64 fs]
          [do
            [loop [j 0 sfs [size fs]]
              [when [lt-s j sfs]
                [byte-array-set-byte-array ba [add offset [mul j 8]]
                  [f64-to-byte-array [word-to-f64 [syntax-word/word [at fs j]]]]]
                [continue j [inc j]]]]
            [continue
              i [inc i]
              offset [add offset [mul [size fs] 8]]]]]]]
      ba]]

[defn concat-byte-arrays [byte-arrays]
  [let [total-size
    [loop [i 0 sum 0]
      [if [le-s [size byte-arrays] i]
        sum
        [continue
          sum [add sum [byte-array-size [at byte-arrays i]]]
          i [inc i]]]]
    result [byte-array total-size]]
    [loop [i 0 offset 0]
      [if [le-s [size byte-arrays] i]
        result
        [let [bs [at byte-arrays i]]
          [for j 0 [byte-array-size bs]
            [byte-array-set result [add offset j] [byte-array-get bs j]]]
          [continue
            i [inc i]
            offset [add offset [byte-array-size bs]]]]]]]]

[type wat-data []
  [union
    [active word wat-inst byte-array]]]

[type translate-context []
  [record
    [check-context llcheck-context]
    [function-name-to-typearg-specializations [transient-kv-map word [set word]]]
    [function-name-to-body [transient-kv-map word lldefn]]
    [specialized-names-generated [set word]]
    [func-specs-to-generate [atom [growable-list [pair word [list ctype]]]]]
    [data-active [transient-kv-map word [atom i32]]]
    [datas [growable-list wat-data]]
    ]]

[defn translate-context-empty [llcheck-context datas]
  [translate-context
    llcheck-context
    [transient-kv-map]
    [transient-kv-map]
    [set]
    [atom [growable-list]]
    [transient-kv-map]
    datas]]

[defn translate-type [bind-ctx it]
  [match [normalize-type it]
    [ctype/var tv]
    [logq-abort translate-type not implemented type var [identity tv]]

    [ctype/inst inst]
    [match inst
      [ctype-inst/literal l] [word i32]

      [ctype-inst/primitive pt] [primitive-type/name pt]

      [ctype-inst/pointer mem-type target-type]
      [primitive-type/name
        [get-memory-pointer-type bind-ctx [mem-name-from-mem-type mem-type]]]

      [ctype-inst/union utypes]
      [translate-type bind-ctx [first utypes]]

      [logq-abort not implemented translate-type [identity it]]]]]

[defn translate-types [bind-ctx it]
  [let [nt [normalize-type it]]
    [match nt
      [ctype/var tv] [logq-abort translate-types not implemented [identity nt]]

      [ctype/inst inst]
      [match inst
        [ctype-inst/tuple types]
        [list-map ta types [translate-type bind-ctx ta]]

        [ctype-inst/apply type-name type-args]
        [list [translate-type bind-ctx nt]]

        [ctype-inst/union utypes]
        [list [translate-type bind-ctx [first utypes]]]

        [ctype-inst/primitive pt]
        [list [translate-type bind-ctx nt]]

        [ctype-inst/pointer m t]
        [list [translate-type bind-ctx nt]]

        [do [log it] [logq-abort not implemented translate-types [identity it]]]]]]]

[defn specialized-name-from [bind-ctx fname type-args]
  [loop
    [w fname
     i 0
     s [size type-args]
     t2n
      [func t2n [t]
        [match [normalize-type t]
          [ctype/var tv]
          [match [get-type-var-kind tv]
            [type-var-kind/unlinked i]
            [int-to-type-var-name i]

            [type-var-kind/linked lt] [logq-abort ctype-to-name unreachable type should be normalized]]

          [ctype/inst inst]
          [match inst
            [ctype-inst/literal l]
            [word literal]

            [ctype-inst/primitive pt]
            [primitive-type/name pt]

            [ctype-inst/pointer mem-type target-type]
            [primitive-type/name
              [get-memory-pointer-type bind-ctx [mem-name-from-mem-type mem-type]]]

            [ctype-inst/apply type-name type-args]
            [word-join
              [word -]
              [list-map ta type-args [t2n ta]]]

            [logq-abort not implemented ctype-to-name [identity inst]]]]]]
    [if [lt-s i s]
      [let
        [tn [t2n [at type-args i]]]
        [continue
          w [concat-words [concat-words w [word -]] tn]
          i [inc i]]]
      w]]]

[defn literal-to-wat-inst [l]
  [match l
    [llliteral/i32 i] [wat-inst/i32.const [syntax-word/word i]]
    [llliteral/i64 i] [wat-inst/i64.const [syntax-word/word i]]
    [llliteral/f32 f] [wat-inst/f32.const [syntax-word/word f]]
    [llliteral/f64 f] [wat-inst/f64.const [syntax-word/word f]]]]

[def i32.const-0 [wat-inst/i32.const [word 0]]]
[def i32.const-1 [wat-inst/i32.const [word 1]]]
[def i32.const-2 [wat-inst/i32.const [word 2]]]
[def i32.const-4 [wat-inst/i32.const [word 4]]]
[def i32.const-8 [wat-inst/i32.const [word 8]]]
[def i32.const-16 [wat-inst/i32.const [word 16]]]

[defn add-func-specialization-to-work-set [tctx sname type-args]
  [let [fname-word [syntax-word/word sname]
        gl [atom-get [translate-context/func-specs-to-generate tctx]]
        spec-name [specialized-name-from [llcheck-context/bind-ctx [translate-context/check-context tctx]] fname-word type-args]]
    [when-not [set-has [translate-context/specialized-names-generated tctx] spec-name]
      [push gl [pair fname-word type-args]]]
    spec-name]]

[type translator []
  [record
    [get-locals [func [] [list [pair word word]]]]
    [exps [func [[list llexp]] [list wat-inst]]]
    [exp [func [llexp] wat-inst]]]]

[defn get-pointer-type [t]
  [if-let [inst [try-get-inst-type t]]
    [match inst
      [ctype-inst/pointer mem target]
      [pair [mem-name-from-mem-type mem] [normalize-type target]]
      [logq-abort get-func-type expected a func type [identity t]]]
    [logq-abort get-func-type expected a func type [identity t]]]]

[defn get-array-type [t]
  [if-let [inst [try-get-inst-type t]]
    [match inst
      [ctype-inst/array element-type size-type]
      [pair element-type size-type]
      [logq-abort get-func-type expected a func type [identity t]]]
    [logq-abort get-func-type expected a func type [identity t]]]]

[defn get-memory-kind [llctx mem-name]
  [if-let [kind [try-get-memory-kind llctx mem-name]]
    kind
    [logq-abort get-memory-kind not found [identity mem-name]]]]

[defn make-translator [tctx type-env]
  [let
    [cctx [translate-context/check-context tctx]
     bind-ctx [llcheck-context/bind-ctx cctx]
     form-to-ldesc [llctx/form-to-ldesc bind-ctx]
     lvar-to-name
       [func lvar-to-name [lvar-sname]
         [if-let [ldesc [try-get form-to-ldesc [syntax-word-get-form lvar-sname]]]
           [syntax-word/word lvar-sname]
           [logq-abort lvar-to-name expected local var [identity lvar-sname]]]]
     get-form-types [func get-form-types [form] [translate-types bind-ctx [get-ctype cctx form]]]
     glocals [growable-list]
     add-binding
     [func ab [b]
       [push glocals
         [pair
           [syntax-word/word [pair/fst b]]
           [translate-type bind-ctx [get-ctype cctx [pair/snd b]]]]]]]
  [letfn [
  [func integer-exp-to-wat-inst [e]
    [match e
      [integer-exp/const i] [wat-inst/i32.const [int-to-word i]]
      [integer-exp/add a b] [wat-inst-i32.add [integer-exp-to-wat-inst a] [integer-exp-to-wat-inst b]]
      [integer-exp/mul a b] [wat-inst-i32.mul [integer-exp-to-wat-inst a] [integer-exp-to-wat-inst b]]
      [integer-exp/exp e] [go e]]]

  [func type-to-size-exp1 [t]
    [let [nt [normalize-type t]
          exp-t [copy-type-proper type-env nt]
          type-to-size [type-to-size-of-integer-exp cctx]]
      [type-to-size exp-t]]]

  [func go-forms [forms]
    [if [is-empty forms]
      [list]
      [concat
        [list-map form [slice forms 0 [dec [size forms]]]
          [loop [res [go form] i [size [get-form-types form]]]
              [if i
                [continue
                  res [wat-inst-drop res]
                  i [dec i]]
                res]]]
        [list [go [last forms]]]]]]
  [func go [form]
    [match form
      [llexp/var sw]
      [let [w [syntax-word/word sw]]
        [if-let [ldesc [try-get form-to-ldesc [syntax-word-get-form sw]]]
          [wat-inst/local.get w]
          [wat-inst/global.get w]]]

      [llexp/literal l]
      [literal-to-wat-inst l]

      [llexp/do forms]
      [wat-inst/instructions [go-forms forms]]

      [llexp/if cond true false]
      [wat-inst/if
        [get-form-types form]
        [go cond]
        [go true]
        [go false]]

      [llexp/intrinsic inst-name imm-args args]
      [wat-inst/inst
        [wasm-name-to-wat-byte-array [syntax-word/word inst-name]]
        [list-map arg args [go arg]]]

      [llexp/call sname opt-type-args args]
      [let [tas [get [llcheck-context/type-instantiations cctx] sname]
            spec-type-args [list-map ta tas [copy-type-proper type-env ta]]
            spec-name [add-func-specialization-to-work-set tctx sname spec-type-args]]
        [wat-inst/call spec-name [list-map a args [go a]]]]

      [llexp/let bindings body]
      [wat-inst/instructions
        [concat
          [list-map b bindings
            [do
              [add-binding b]
              [wat-inst/local.set [lvar-to-name [pair/fst b]] [go [pair/snd b]]]]]
          [go-forms body]]]

      [llexp/loop bindings body]
      [wat-inst/instructions
        [concat
          [list-map b bindings
            [do
              [add-binding b]
              [wat-inst/local.set [lvar-to-name [pair/fst b]] [go [pair/snd b]]]]]
          [list
            [wat-inst/loop
              [word loop-label]
              [get-form-types form]
              [wat-inst/instructions
                [go-forms body]]]]]]

      [llexp/continue assignments]
      [wat-inst/instructions
        [concat
          [list-map a assignments
            [wat-inst/local.set [lvar-to-name [pair/fst a]] [go [pair/snd a]]]]
          [list [wat-inst/br [word loop-label]]]]]

      [llexp/cast cast-type value]
      [go value]

      [llexp/deref target]
      [let
        [pt [get-pointer-type [get-ctype cctx target]]
         it [copy-type-proper type-env [pair/snd pt]]]
        [wat-inst/load
          [wasm-name-to-wat-byte-array
            [switch [translate-type bind-ctx it]
            [[word i32]] [word i32.load]
            [[word i64]] [word i64.load]
            [[word f32]] [word f32.load]
            [[word f64]] [word f64.load]
            [[word v128]] [word v128.load]
            [[word u8]] [word i32.load8-u]
            [[word i8]] [word i32.load8-s]
            [[word u16]] [word i32.load16-u]
            [[word i16]] [word i32.load16-s]
            [logq-abort not implemented deref inst-type/apply]]]
          [wat-inst-memargs
            [pair/fst pt]
            [word 0]
            [word 1]]
          [go target]]]

      [llexp/assign target value]
      [let
        [pt [get-pointer-type [get-ctype cctx target]]
         it [copy-type-proper type-env [pair/snd pt]]]
        [wat-inst/store
          [wasm-name-to-wat-byte-array
            [switch [translate-type bind-ctx it]
            [[word i32]] [word i32.store]
            [[word i64]] [word i64.store]
            [[word f32]] [word f32.store]
            [[word f64]] [word f64.store]
            [[word v128]] [word v128.store]
            [[word u8] [word i8]] [word i32.store8]
            [[word u16] [word i16]] [word i32.store16]
            [logq-abort not implemented assign inst-type/apply]]]
          [wat-inst-memargs
            [pair/fst pt]
            [word 0]
            [word 1]]
          [go target]
          [go value]]]

      [llexp/field target field-name]
      [let
        [pt [get-pointer-type [get-ctype cctx target]]
         field-name-word [syntax-word/word field-name]]
        [let [get-offset
              [func g-off [ttarget]
                [let [inst [if-let [i [try-get-inst-type ttarget]] i [logq-abort type not an inst]]]
                  [match inst
                    [ctype-inst/record field-list]
                    [loop [i 0 offset int-const-0]
                      [if [lt-s i [size field-list]]
                        [let [fp [at field-list i]]
                          [if [eq-word field-name-word [pair/fst fp]]
                            offset
                            [continue
                              i [inc i]
                              offset [int-exp-add offset [type-to-size-exp1 [pair/snd fp]]]]]]
                        [logq-abort field not found]]]

                    [ctype-inst/union utypes]
                    [let [fo [g-off [first utypes]]]
                      [if-let [first-offset [try-get-int-const fo]]
                        [for i 1 [size utypes]
                          [if-let [offset [try-get-int-const [g-off [at utypes i]]]]
                            [when-not [eq first-offset offset]
                              [logq-abort field not at constant offset]]
                            [logq-abort field not at constant offset]]]
                        [logq-abort field not at constant offset]]
                      fo]

                    [logq-abort field not a record or union type [identity inst]]]]]]
          [wat-inst-i32.add [integer-exp-to-wat-inst [get-offset [pair/snd pt]]] [go target]]]]

      [llexp/index target index]
      [let
        [pt [get-pointer-type [get-ctype cctx target]]
         array-type [pair/snd pt]
         array-type-pair [get-array-type array-type]
         element-type [pair/fst array-type-pair]
         offset [wat-inst-i32.mul [integer-exp-to-wat-inst [type-to-size-exp1 element-type]] [go index]]]
        [wat-inst-i32.add offset [go target]]]

      [llexp/size-of t]
      [integer-exp-to-wat-inst [type-to-size-exp1 [get-annotation cctx t]]]

      [llexp/is-identical p1 p2]
      [wat-inst-word
        [match [get-memory-kind bind-ctx [pair/fst [get-pointer-type [get-ctype cctx p1]]]]
          [memory-kind/i32] [word i32.eq]
          [memory-kind/i64] [word i64.eq]]
        [go p1] [go p2]]

      [llexp/tuple values]
      [wat-inst/instructions [list-map value values [go value]]]

      [llexp/data smem-name exp]
      [let
        [mem-name [syntax-word/word smem-name]
         data-active [translate-context/data-active tctx]
         current-offset-atom
         [if-let [offset-atom [try-get data-active mem-name]]
          offset-atom
          [let [init-offset [i32 16]
                new-offset-atom [atom init-offset]]
            [set-kv-map data-active mem-name new-offset-atom]
            new-offset-atom]]
         offset [atom-get current-offset-atom]
         pointer-inst
         [[match [get-memory-kind bind-ctx mem-name]
            [memory-kind/i32] wat-inst/i32.const
            [memory-kind/i64] wat-inst/i64.const]
          [int-to-word offset]]
         data-exp-to-byte-array
          [func data-exp-to-byte-array [data-exp]
            [match data-exp
              [data-exp/exp exp]
              [match exp
                [llexp/literal l]
                [match l
                  [llliteral/i32 i]
                  [i32-to-byte-array [word-to-int [syntax-word/word i]]]

                  [llliteral/f64 i]
                  [f64-to-byte-array [word-to-f64 [syntax-word/word i]]]

                  [logq-abort not implemented data [identity exp]]]

                [logq-abort not implemented data [identity exp]]]

              [data-exp/record fields]
              [concat-byte-arrays [list-map f fields [data-exp-to-byte-array [pair/snd f]]]]

              [data-exp/array elems]
              [concat-byte-arrays [list-map e elems [data-exp-to-byte-array e]]]]]
         data-bytes [data-exp-to-byte-array exp]]
        [push
          [translate-context/datas tctx]
          [wat-data/active mem-name pointer-inst data-bytes]]
        [atom-set current-offset-atom [add [byte-array-size data-bytes] offset]]
        pointer-inst]

      [logq-abort not implemented translate-form [identity form]]]]]
    [translator
      [func get-locals [] [clone-growable-to-frozen-list glocals]]
      go-forms
      go]]]]

[type output-func []
  [record
    [name word]
    [parameters [list [pair word word]]]
    [locals [list [pair word word]]]
    [result [list word]]
    [body wat-inst]]]

[defn translate-func [tctx func type-args]
  [let
    [cctx [translate-context/check-context tctx]
     bind-ctx [llcheck-context/bind-ctx cctx]
     form-to-ldesc [llctx/form-to-ldesc bind-ctx]
     lvar-to-name
       [func lvar-to-name [lvar-sname]
         [if-let [ldesc [try-get form-to-ldesc [syntax-word-get-form lvar-sname]]]
           [syntax-word/word lvar-sname]
           [logq-abort lvar-to-name expected local var [identity lvar-sname]]]]
     get-form-types [func get-form-types [form] [translate-types bind-ctx [get-ctype cctx form]]]
     signature [lldefn/signature func]
     fname-word [syntax-word/word [func-sig/name signature]]
     ts [get [llcheck-context/def-var-types cctx] fname-word]
     type-env [transient-kv-map]]
  [if-let [fn-tps [func-sig/type-params signature]]
    [let [type-params [check-type-scheme/named-type-params ts]]
      [assert [eq [size type-params] [size type-args]]
        expected matching number of type parameters and type arguments
        [identity type-params] [identity type-args]]
      [for i 0 [size type-params]
        [set-kv-map type-env [unwrap-type-var-links [pair/snd [at type-params i]]] [at type-args i]]]]
    [let [type-params [check-type-scheme/type-vars ts]]
      [assert [eq [size type-params] [size type-args]] expected matching number of type parameters and type arguments]
      [for i 0 [size type-params]
        [set-kv-map type-env [at type-params i] [at type-args i]]]]]
  [let
    [t [copy-type-proper type-env [check-type-scheme/type ts]]
     ft [get-func-type t]
     param-types [pair/fst ft]
     gparams [growable-list]
     params [func-sig/params signature]
     special-func-name [specialized-name-from bind-ctx fname-word type-args]
     ltranslator [make-translator tctx type-env]]
    [assert [eq [size params] [size param-types]] expected matching number of parameters and types]
    [set-add [translate-context/specialized-names-generated tctx] special-func-name]
    [for i 0 [size params]
      [push gparams
        [pair
          [syntax-word/word [pair/fst [at params i]]]
          [translate-type bind-ctx [lift-data-type [at param-types i]]]]]]
    [comment translation has the side effect of adding locals so we need to run it first]
    [let [tbodies [[translator/exps ltranslator] [lldefn/bodies func]]]
      [output-func
        special-func-name
        [clone-growable-to-frozen-list gparams]
        [[translator/get-locals ltranslator]]
        [translate-types bind-ctx [lift-data-type [pair/snd ft]]]
        [wat-inst/instructions tbodies]]]]]]

[type import-kind []
  [union
    [memory word i32]]]

[type wat-memory []
  [record
    [kind memory-kind]
    [name word]
    [initial i32]
    [maximum [option i32]]]]

[type wat-global []
  [record
    [name word]
    [type word]
    [value wat-inst]]]

[type export-kind []
  [union [func] [global] [memory]]]

[type wat-output []
  [record
    [imports [growable-list [pair [list word] import-kind]]]
    [memories [growable-list wat-memory]]
    [globals [growable-list wat-global]]
    [funcs [growable-list output-func]]
    [exports [growable-list [pair word [pair export-kind word]]]]
    [datas [growable-list wat-data]]]]

[defn translate-top-forms-sync [evaluator forms]
  [let
    [f2l [make-forms-to-btops evaluator]
     btops-ctx-pair [f2l forms]
     bind-ctx [pair/snd btops-ctx-pair]
     gctx [llcheck-context-empty bind-ctx]
     datas [growable-list]
     tctx [translate-context-empty gctx datas]
     imports [growable-list]
     memories [growable-list]
     globals [growable-list]
     funcs [growable-list]
     exports [growable-list]
     specs-atom [translate-context/func-specs-to-generate tctx]
     func-to-body [translate-context/function-name-to-body tctx]
     exp-const-to-wat-inst [translator/exp [make-translator tctx [transient-kv-map]]]]
    [for-each btop [pair/fst btops-ctx-pair]
      [infer-lltop gctx btop]
      [match btop
        [lltop/memory name kind init-size opt-max]
        [push memories
          [wat-memory
            kind
            [syntax-word/word name]
            [word-to-int [syntax-word/word init-size]]
            [if-let [max opt-max]
              [option/some [word-to-int [syntax-word/word max]]]
              [option/none]]]]

        [lltop/def name value]
        [push globals
          [wat-global
            [syntax-word/word name]
            [translate-type bind-ctx [get-ctype gctx value]]
            [exp-const-to-wat-inst value]]]

        [lltop/defn func]
        [set-kv-map [translate-context/function-name-to-body tctx]
          [syntax-word/word [func-sig/name [lldefn/signature func]]] func]

        [lltop/export snames]
        [for-each sname snames
          [push
            exports
            [let [name [syntax-word/word sname]]
              [pair
                name
                [if-let [dd [try-get [llctx/lldef-ctx bind-ctx] name]]
                  [match dd
                    [lldef-desc/memory kind]
                    [pair [export-kind/memory] name]

                    [lldef-desc/func fsig]
                    [let
                      [cctx [translate-context/check-context tctx]
                       type-args [get [llcheck-context/type-instantiations cctx] sname]
                       spec-name [add-func-specialization-to-work-set tctx sname type-args]]
                      [if-let [tparams [func-sig/type-params fsig]]
                        [logq-abort export genfn not implemented]
                        [do]]
                      [pair [export-kind/func] spec-name]]

                    [lldef-desc/any]
                    [pair [export-kind/global] name]]
                  [logq-abort export not found]]]]]]

        [lltop/data-active mem-name offset-form ds]
        [push
          datas
          [wat-data/active
            [syntax-word/word mem-name]
            [exp-const-to-wat-inst offset-form]
            [datas-to-byte-array ds]]]

        [lltop/type decls]
        [do]

        [logq-abort not implemented translate-top-form [identity btop]]]]
    [loop [func-specializations [clone-growable-to-frozen-list [atom-get specs-atom]]]
      [when-not [is-empty func-specializations]
        [atom-set specs-atom [growable-list]]
        [for-each func-specialization func-specializations
          [let [fname [pair/fst func-specialization]
                type-args [list-map t [pair/snd func-specialization] [normalize-type t]]
                spec-name [specialized-name-from bind-ctx fname type-args]]
            [when-not [set-has [translate-context/specialized-names-generated tctx] spec-name]
              [push
                funcs
                [translate-func tctx [get func-to-body fname] type-args]]]]]
        [continue func-specializations [clone-growable-to-frozen-list [atom-get specs-atom]]]]]
    [wat-output
      imports
      memories
      globals
      funcs
      exports
      datas]]]

[def ascii-line-feed [i32 10]]
[def ascii-space [i32 32]]
[def ascii-double-quote [i32 34]]
[def ascii-dollar [i32 36]]
[def ascii-left-paren [i32 40]]
[def ascii-right-paren [i32 41]]
[def ascii-equal [i32 61]]
[def ascii-backslash [i32 92]]

[type printer []
  [record
    [bytes [byte-array]]
    [index [atom i32]]]]

[defn empty-printer []
  [printer [byte-array-resizable [i32 256] [i32 0x10000000]] [atom 0]]]

[defn printer-to-byte-array [p]
  [let
    [ci [atom-get [printer/index p]]
     cb [printer/bytes p]
     trimmed [byte-array ci]]
    [for i 0 ci
      [byte-array-set trimmed i [byte-array-get cb i]]]
    trimmed]]

[defn print-byte [printer byte]
  [let [ia [printer/index printer]
        i [atom-get ia]
        a [printer/bytes printer]
        cur-size [byte-array-size a]]
    [when [le-s cur-size i]
      [byte-array-resize a [mul [i32 2] cur-size]]]
    [byte-array-set a i byte]
    [atom-set [printer/index printer] [inc i]]]]

[defn print-word [printer word]
  [for i 0 [word-byte-size word]
    [print-byte printer [char-code-at word i]]]]

[defn int-to-hex-ascii [i]
  [if [lt-s i [i32 10]]
    [add i [i32 48]]
    [add [sub i [i32 10]] [i32 97]]]]

[defn i32-to-hex-bits [n-bits value]
  [let [gl [growable-list]]
    [loop [n-start [sub n-bits 4]
           index [intrinsic i32.shl [i32 15] n-start]
           i n-start]
      [when index
        [push gl [int-to-hex-ascii [intrinsic i32.shr-u [intrinsic i32.and value index] i]]]
        [continue
          index [intrinsic i32.shr-u index [i32 4]]
          i [sub i 4]]]]
    [code-points-to-word [clone-growable-to-frozen-list gl]]]]

[defn i32-to-hex-8 [value]
  [i32-to-hex-bits [i32 8] value]]

[defn print-string-chars [printer word]
  [for i 0 [byte-array-size word]
    [let [cc [byte-array-get word i]]
      [if [or [lt-s cc [i32 32]] [lt-s [i32 126] cc]]
        [do
          [print-byte printer ascii-backslash]
          [print-word printer [i32-to-hex-8 cc]]]
        [print-byte printer cc]]]]]

[type wat []
  [union
    [word word]
    [byte-array byte-array]
    [dollar word]
    [dqstring word]
    [dqstring-bytes byte-array]
    [seq [list wat]]
    [seq-lf [list wat]]
    [list [list wat]]
    [eq-pair word word]]]

[defn print-wat [printer wat]
  [match wat
    [wat/word w] [print-word printer w]
    [wat/byte-array ba]
      [for i 0 [byte-array-size ba]
        [print-byte printer [byte-array-get ba i]]]
    [wat/dollar w] [do [print-byte printer ascii-dollar] [print-word printer w]]
    [wat/dqstring w] [do [print-byte printer ascii-double-quote] [print-word printer w] [print-byte printer ascii-double-quote]]
    [wat/dqstring-bytes ba] [do [print-byte printer ascii-double-quote] [print-string-chars printer ba] [print-byte printer ascii-double-quote]]
    [wat/seq l]
      [do
        [when-not [is-empty l]
          [print-wat printer [first l]]
          [for i 1 [size l]
            [print-byte printer ascii-space]
            [print-wat printer [at l i]]]]]
    [wat/seq-lf l]
      [do
        [when-not [is-empty l]
          [print-wat printer [first l]]
          [for i 1 [size l]
            [print-byte printer ascii-line-feed]
            [print-wat printer [at l i]]]]]
    [wat/list l]
      [do
        [print-byte printer ascii-left-paren]
        [when-not [is-empty l]
          [print-wat printer [first l]]
          [for i 1 [size l]
            [print-byte printer ascii-space]
            [print-wat printer [at l i]]]]
        [print-byte printer ascii-right-paren]]
    [wat/eq-pair w1 w2]
      [do
        [print-word printer w1]
        [print-byte printer ascii-equal]
        [print-word printer w2]]]]

[defn wat-to-wat-bytes [wat]
  [let [p [empty-printer]]
    [print-wat p wat]
    [printer-to-byte-array p]]]

[defn wat-list [.. l] [wat/list l]]

[defn wat-concat [.. l] [wat/list [concat-lists l]]]

[defn wat-inst-memargs-to-out [ma]
  [list
    [wat-list [wat/word [word memory]] [wat/dollar [wat-inst-memargs/memory ma]]]
    [wat/eq-pair [word offset] [wat-inst-memargs/offset ma]]
    [wat/eq-pair [word align] [wat-inst-memargs/alignment ma]]]]

[defn wat-inst-to-out [i]
  [match i
    [wat-inst/i32.const w]
    [wat-list [wat/word [word i32.const]] [wat/word w]]

    [wat-inst/i64.const w]
    [wat-list [wat/word [word i64.const]] [wat/word w]]

    [wat-inst/f32.const w]
    [wat-list [wat/word [word f32.const]] [wat/word w]]

    [wat-inst/f64.const w]
    [wat-list [wat/word [word f64.const]] [wat/word w]]

    [wat-inst/inst-word w args]
    [wat-concat
      [list [wat/word w]] [list-map a args [wat-inst-to-out a]]]

    [wat-inst/inst ba args]
    [wat-concat
      [list [wat/byte-array ba]] [list-map a args [wat-inst-to-out a]]]

    [wat-inst/local.get w]
    [wat-list [wat/word [word local.get]] [wat/dollar w]]

    [wat-inst/local.set w e]
    [wat-list [wat/word [word local.set]] [wat/dollar w] [wat-inst-to-out e]]

    [wat-inst/global.get w]
    [wat-list [wat/word [word global.get]] [wat/dollar w]]

    [wat-inst/load name ma addr]
    [wat-concat
      [list [wat/byte-array name]]
      [wat-inst-memargs-to-out ma]
      [list [wat-inst-to-out addr]]]

    [wat-inst/store name ma addr value]
    [wat-concat
      [list [wat/byte-array name]]
      [wat-inst-memargs-to-out ma]
      [list [wat-inst-to-out addr] [wat-inst-to-out value]]]

    [wat-inst/instructions insts]
    [wat/seq [list-map inst insts [wat-inst-to-out inst]]]

    [wat-inst/if result-types cond true false]
    [wat-list [wat/word [word if]]
      [wat/list
        [concat [list [wat/word [word result]]]
          [list-map rt result-types [wat/word rt]]]]
      [wat-inst-to-out cond]
      [wat-list [wat/word [word then]] [wat-inst-to-out true]]
      [wat-list [wat/word [word else]] [wat-inst-to-out false]]]

    [wat-inst/call w args]
    [wat-concat
      [list [wat/word [word call]] [wat/dollar w]]
      [list-map a args [wat-inst-to-out a]]]

    [wat-inst/loop loop-label result-types body]
    [wat-list
      [wat/word [word loop]]
      [wat/dollar loop-label]
      [wat/list
        [concat [list [wat/word [word result]]]
          [list-map rt result-types [wat/word rt]]]]
      [wat-inst-to-out body]]

    [wat-inst/br w]
    [wat-list [wat/word [word br]] [wat/dollar w]]

    [logq-abort wat-inst-to-out unknown instruction]]]

[defn import-to-wat [import]
  [match [pair/snd import]
    [import-kind/memory name init-size]
    [wat-list
      [wat/word [word memory]]
      [wat/dollar name]
      [wat/word [int-to-word init-size]]]]]

[defn memory-to-wat [mem]
  [wat-list
    [wat/word [word memory]]
    [wat/dollar [wat-memory/name mem]]
    [wat/word [match [wat-memory/kind mem]
      [memory-kind/i32] [word i32]
      [memory-kind/i64] [word i64]]]
    [wat/word [int-to-word [wat-memory/initial mem]]]]]

[defn global-to-wat [global]
  [wat-list
    [wat/word [word global]]
    [wat/dollar [wat-global/name global]]
    [wat/word [wat-global/type global]]
    [wat-inst-to-out [wat-global/value global]]]]

[defn data-to-wat [d]
  [match d
    [wat-data/active mem-name offset data]
    [wat-list
      [wat/word [word data]]
      [wat-list [wat/word [word memory]] [wat/dollar mem-name]]
      [wat-inst-to-out offset]
      [wat/dqstring-bytes data]]]]

[defn output-func-to-wat [of]
  [wat-concat
    [list
      [wat/word [word func]]
      [wat/dollar [output-func/name of]]]
    [list-map p [output-func/parameters of]
      [wat-list [wat/word [word param]] [wat/dollar [pair/fst p]] [wat/word [pair/snd p]]]]
    [list
      [wat-concat
        [list [wat/word [word result]]]
        [list-map rt [output-func/result of] [wat/word rt]]]]
    [list-map l [output-func/locals of]
      [wat-list [wat/word [word local]] [wat/dollar [pair/fst l]] [wat/word [pair/snd l]]]]
    [list
      [wat-inst-to-out [output-func/body of]]]]]

[defn export-to-wat [p]
  [wat-concat
    [list
      [wat/word [word export]]
      [wat/dqstring [pair/fst p]]
      [let [kind-pair [pair/snd p]]
        [wat-list
          [wat/word
            [match [pair/fst kind-pair]
              [export-kind/func] [word func]
              [export-kind/memory] [word memory]
              [export-kind/global] [word global]
              [logq-abort export-to-wat unknown export kind]]]
          [wat/dollar [pair/snd kind-pair]]]]]]]

[defn output-to-wat [output]
  [wat/seq-lf
    [concat-lists
      [list
        [list-map imp [clone-growable-to-frozen-list [wat-output/imports output]] [import-to-wat imp]]
        [list-map mem [clone-growable-to-frozen-list [wat-output/memories output]] [memory-to-wat mem]]
        [list-map g [clone-growable-to-frozen-list [wat-output/globals output]] [global-to-wat g]]
        [list-map d [clone-growable-to-frozen-list [wat-output/datas output]] [data-to-wat d]]
        [list-map of [clone-growable-to-frozen-list [wat-output/funcs output]] [output-func-to-wat of]]
        [list-map e [clone-growable-to-frozen-list [wat-output/exports output]] [export-to-wat e]]]]]]

[defmacro def-wasm-extern [name type]
  [flist [quote import] [quote ./runtime-lib/wasm.js] name type]]

[type wasm-module [] [union]]

[import ./runtime-lib/wabt.js wat-to-wasm-byte-array [func [byte-array] byte-array]]

[defn translate-top-forms-to-tctx [forms]
  [promise-then
    [make-init-evaluator-async]
    [func t [evaluator] [translate-top-forms-sync evaluator forms]]]]

[defn translate-top-forms-to-wasm-bytes [forms]
  [promise-then
    [translate-top-forms-to-tctx forms]
    [func t [output]
      [wat-to-wasm-byte-array [wat-to-wat-bytes [output-to-wat output]]]]]]

[def-wasm-extern byte-array-to-wasm-module [func [byte-array] wasm-module]]

[defn translate-top-forms-to-module [forms]
  [promise-then
    [translate-top-forms-to-wasm-bytes forms]
    byte-array-to-wasm-module]]

[comment
  we could do type predicates like
[defn form-word-is [[type f [pointer [memory mem] [form]]]]
  [cast
    [type-predicate f [form-word]]
    [eq [deref [field f tag]] [i32 0]]]]

[defn form-list-is [[type f [pointer [memory mem] [form]]]]
  [cast
    [type-predicate f [form-list]]
    [eq [deref [field f tag]] [i32 1]]]]

]

[comment

[type
  form-list []
  [record
    [tag [literal [i32 1]]]
    [forms [pvector [pointer [memory mem] [form]]]]]

  form []
  [union
    [form-word]
    [form-list]]]

[defn make-stack []
  [call growable-vector-make [[form-word]] [[i32 16]]]]

[defn parse [[type bytes [pointer [memory mem] [pvector [u8]]]]]
  [loop
    [n-of-bytes [size bytes]
     i [i32 0]
     start [i32 -1]]
    [if [lt-s i n-of-bytes]
      [let [c [get-byte bytes i]]
        [ifs
          [is-whitespace c]
          [if [lt-s start [i32 0]]
            [continue i [inc i]]
            [form-word-make [dvector-slice bytes start i]]]

          [is-word-char c]
          [if [lt-s start [i32 0]]
            [continue
              start i
              i [inc i]]
            [continue
              i [inc i]]]

          [eq c [i32 91]]
          [intrinsic unreachable]

          [eq c [i32 93]]
          [intrinsic unreachable]

          [intrinsic unreachable]]]
      [if [lt-s start [i32 0]]
        [cast [pointer [memory mem] [form-word]] [i32 0]]
        [form-word-make [dvector-slice bytes start i]]]]]]

[export parse]

 ]