[load std.wuns]

[type syntax-word []
  [record
    [word word]
    [opt-form [option form]]]]

[type llliteral []
  [union
    [i32 syntax-word]
    [i64 syntax-word]
    [f32 syntax-word]
    [f64 syntax-word]]]

[type
  type-literal []
  [union
    [memory syntax-word]
    [exp llexp]]

  lltype []
  [union
    [var syntax-word]
    [literal type-literal]
    [apply syntax-word [list lltype]]]

  llexp []
  [union
    [var syntax-word]
    [literal llliteral]
    [intrinsic syntax-word [list syntax-word] [list llexp]]
    [if llexp llexp llexp]
    [let [list [pair syntax-word llexp]] [list llexp]]
    [loop [list [pair syntax-word llexp]] [list llexp]]
    [continue [list [pair syntax-word llexp]]]
    [do [list llexp]]
    [call syntax-word [option [list lltype]] [list llexp]]

    [cast lltype llexp]
    [deref llexp]
    [assign llexp llexp]
    [field llexp syntax-word]
    [index llexp llexp]
    [size-of lltype]
    ]]

[type memory-kind []
  [union
    [i32]
    [i64]]]

[type lldef-desc []
  [union
    [memory memory-kind]
    [any]
    [func
      [option [list syntax-word]]
      [list [pair syntax-word [option lltype]]]]
    ]]

[type lllocal-var-kind []
  [union
    [param]
    [param-with-type lltype]
    [let]
    [loop]
    [func-internal-self i32]]]

[type user-type-desc []
  [union
    [record
      [transient-kv-map word lltype]
      [list [pair word lltype]]]
    [union
      [transient-kv-map word [list lltype]]
      [list lltype]]
    [alias lltype]]]

[defn syntax-word-get-form [sw]
  [if-let [f [syntax-word/opt-form sw]]
    f
    [logq-abort syntax-word-get-form expected a form]]]

[defn push-error [form msg]
  [log form]
  [log msg]
  [log-location form]
  [logq-abort push-error error [identity msg]]]

[defn get-list [form]
  [match form
    [form/list l] l
    [do
      [push-error form [quote [expected list]]]
      [list]]]]

[defn sword [form]
  [if-let [w [try-get-word form]]
    [syntax-word
      w
      [option/some form]]
    [logq-abort sword expected word]]]

[type local-context-kind []
  [union
    [let]
    [loop]
    [func]]]

[type local-context [v]
  [record
    [vars [transient-kv-map word v]]
    [kind local-context-kind]]]

[type local-stack [v]
  [union
    [empty]
    [frame [local-stack v] [local-context v]]]]

[defn try-get-local [lstack w]
  [match lstack
    [local-stack/empty] [option/none]

    [local-stack/frame outer lctx]
    [match [try-get [local-context/vars lctx] w]
      [option/none] [try-get-local outer w]
      [option/some kind] [option/some kind]]]]

[defn try-get-enclosing-loop-context [lstack]
  [match lstack
    [local-stack/empty] [option/none]

    [local-stack/frame outer lctx]
    [match [local-context/kind lctx]
      [local-context-kind/loop] [option/some lctx]
      [local-context-kind/func] [option/none]

      [try-get-enclosing-loop-context outer]]]]

[defn is-syntactic-llvalue [bform]
  [match bform
    [llexp/literal l] 1
    [llexp/var f] 1
    0]]

[type llctx []
  [record
    [lldef-ctx [transient-kv-map word lldef-desc]]
    [form-to-ldesc [transient-kv-map form lllocal-var-kind]]
    [user-type-params [transient-kv-map word [list syntax-word]]]
    [user-types [transient-kv-map word user-type-desc]]
    [bound-form-to-form [transient-kv-map js-value form]]]]

[defn llctx-empty [] [llctx [transient-kv-map] [transient-kv-map] [transient-kv-map] [transient-kv-map] [transient-kv-map]]]

[type data []
  [union
    [bytes [list syntax-word]]
    [i32 [list syntax-word]]
    [f64 [list syntax-word]]
    ]]

[type lldefn []
  [record
    [name syntax-word]
    [type-params [option [list syntax-word]]]
    [params [list [pair syntax-word [option lltype]]]]
    [bodies [list llexp]]]]

[type lltop []
  [union
    [memory syntax-word memory-kind syntax-word [option syntax-word]]
    [type]
    [data-active syntax-word llexp [list data]]
    [def syntax-word llexp]
    [defn lldefn]
    [export [list syntax-word]]]]

[defn wat-type-is [type-name]
  [switch type-name
    [[word i32] [word i64] [word f32] [word f64] [word v128]] true
    false]]

[defn wuns-builtin-data-type-is [type-name]
  [switch type-name
    [[word u8] [word s8]
     [word u16] [word s16]] true
    false]]

[defn llbuiltin-type-arity-ok [type-name n-of-args]
  [switch type-name
    [[word tuple]] [option/some true]

    [[word pointer] [word array]] [option/some [eq 2 n-of-args]]

    [if [or [wat-type-is type-name] [wuns-builtin-data-type-is type-name]]
      [option/some [eq n-of-args 0]]
      [option/none]]]]

[load interpreter-externs.wuns]

[defn starts-with-dash [w]
  [eq [char-code-at w 0] [word-to-char-code -]]]

[defn make-forms-to-btops [evaluator]
  [let
    [lldef-ctx [transient-kv-map]
     form-to-ldesc [transient-kv-map]
     user-type-params [transient-kv-map]
     user-types [transient-kv-map]
     bound-form-to-form [transient-kv-map]]
    [letfn [
[func set-local [lvars f kind]
  [let [w [form-to-word f]]
    [when [has lvars w] [push-error f [quote [redeclaring local]]]]
    [set-kv-map lvars w kind]
    [set-kv-map form-to-ldesc f kind]]]

[func set-ll-def [form def-desc]
  [set-kv-map lldef-ctx [form-to-word form] def-desc]]

[func form-to-lltype [lstack type-params form]
  [match form
    [form/word w]
    [do
      [when [and [not [starts-with-dash w]] [not [set-has type-params w]]]
        [comment probably should add it to a context...]
        [log-location form]
        [logq-abort type var unbound [identity w]]]
      [lltype/var [sword form]]]

    [form/list l]
    [let [sw [sword [first l]] fw [syntax-word/word sw] n-of-args [dec [size l]]]
      [switch fw
        [[word memory]]
        [let [w [form-to-word [second l]]]
          [if-let [ldesc [try-get-local lstack w]]
            [logq-abort not a memory]
            [if-let [ddesc [try-get lldef-ctx w]]
              [match ddesc
                [lldef-desc/memory k] [do]
                [logq-abort not a memory]]
              [push-error form [quote [undefined exp word]]]]]
          [lltype/literal [type-literal/memory [sword [second l]]]]]

        [[word literal]]
        [lltype/literal [type-literal/exp [form-to-llexp type-params lstack [second l]]]]

        [do
          [if-let [user-type-params [try-get user-type-params fw]]
            [when-not [eq [size user-type-params] n-of-args] [push-error form [quote [type arity mismatch]]]]
            [if-let [arity-ok [llbuiltin-type-arity-ok fw n-of-args]]
              [when-not arity-ok [push-error form [quote [type arity mismatch]]]]
              [push-error form [quote [undefined type]]]]]
          [lltype/apply sw [list-map arg [rest l] [form-to-lltype lstack type-params arg]]]]]]]]

[func form-to-llexp [type-var-set lstack form]
  [let [bst [form-to-llexp0 type-var-set lstack form]]
    [set-kv-map bound-form-to-form [to-js-value bst] form]
    bst]]

[func form-to-llexp0 [type-var-set lstack form]
  [match form
    [form/word w]
    [do
      [if-let [ldesc [try-get-local lstack w]]
        [set-kv-map form-to-ldesc form ldesc]
        [if-let [ddesc [try-get lldef-ctx w]]
          [match ddesc
            [lldef-desc/any] [do]
            [lldef-desc/memory k] [logq-abort only def values allowed]
            [logq-abort only def values allowed [identity form]]]
          [push-error form [quote [undefined exp word]]]]]
      [llexp/var [sword form]]]

    [form/list l]
    [let [n-of-args [dec [size l]]
          assert-n-args [func ana [n] [when-not [eq n-of-args n] [push-error form [quote [expected n-of-args arguments]]]]]
          get-arg [func get-arg [i] [if [lt-s i n-of-args] [at l [inc i]] [quote no-such-arg]]]
          - [assert-not [is-empty l] list was empty]
          first-form [first l]]
      [match first-form
        [form/word first-word]
        [switch first-word
          [[word i32]]
          [llexp/literal [llliteral/i32 [sword [get-arg 0]]]]

          [[word i64]]
          [llexp/literal [llliteral/i64 [sword [get-arg 0]]]]

          [[word f32]]
          [llexp/literal [llliteral/f32 [sword [get-arg 0]]]]

          [[word f64]]
          [llexp/literal [llliteral/f64 [sword [get-arg 0]]]]

          [[word v128] [word word]]
          [logq-abort form-to-llexp not implemented [identity first-form]]

          [[word intrinsic]]
          [let [inst-sname [sword [get-arg 0]]
                inst-name [syntax-word/word inst-sname]]
            [if [or [is-i32-bin-inst inst-name] [is-f64-bin-inst inst-name] [is-f64-comp-inst inst-name]]
              [do
                [assert-n-args 3]
                [llexp/intrinsic inst-sname [list] [list-map arg [slice l 2 [size l]] [form-to-llexp type-var-set lstack arg]]]]
              [switch inst-name
                [[word unreachable]]
                [do
                  [assert-n-args 1]
                  [llexp/intrinsic inst-sname [list] [list-map arg [slice l 2 [size l]] [form-to-llexp type-var-set lstack arg]]]]

                [[word i32.load] [word i32.load8-u]]
                [do
                  [assert-n-args 5]
                  [let [mem-name [sword [get-arg 1]]]
                    [match [get lldef-ctx [syntax-word/word mem-name]]
                      [lldef-desc/memory kind] [do]
                      [push-error [get-arg 1] [quote [not a memory]]]]
                    [llexp/intrinsic inst-sname
                      [list
                        mem-name
                        [sword [get-arg 2]]
                        [sword [get-arg 3]]]
                      [list [form-to-llexp type-var-set lstack [get-arg 4]]]]]]

                [[word i32.store] [word i32.store8]]
                [do
                  [assert-n-args 6]
                  [let [mem-name [sword [get-arg 1]]]
                    [match [get lldef-ctx [syntax-word/word mem-name]]
                      [lldef-desc/memory kind] [do]
                      [push-error [get-arg 1] [quote [not a memory]]]]
                    [llexp/intrinsic inst-sname
                      [list
                        [sword [get-arg 1]]
                        [sword [get-arg 2]]
                        [sword [get-arg 3]]]
                      [list
                        [form-to-llexp type-var-set lstack [get-arg 4]]
                        [form-to-llexp type-var-set lstack [get-arg 5]]]]]]

                [do
                  [log form]
                  [logq-abort form-to-llexp not implemented]]]]]

          [[word if]]
          [do
            [assert-n-args 3]
            [llexp/if [form-to-llexp type-var-set lstack [get-arg 0]] [form-to-llexp type-var-set lstack [get-arg 1]] [form-to-llexp type-var-set lstack [get-arg 2]]]]

          [[word do]]
          [llexp/do [list-map arg [rest l] [form-to-llexp type-var-set lstack arg]]]

          [[word loop]]
          [let
            [bindings [get-list [get-arg 0]]
             lvars [transient-kv-map]
             lctx [local-context lvars [local-context-kind/loop]]
             new-lstack [local-stack/frame lstack lctx]]
            [when [lt-s n-of-args 2] [push-error form [quote [expected at least 2 arguments]]]]
            [llexp/loop
              [list-map p [pairwise bindings]
                [let [name [first p]
                      sname [sword name]
                      name-word [syntax-word/word sname]
                      be [form-to-llexp type-var-set new-lstack [second p]]
                      ldesc [lllocal-var-kind/loop]]
                  [when-let [ldesc [try-get-local lstack name-word]]
                    [push-error name [quote [loop var shadows local]]]]
                  [set-local lvars name ldesc]
                  [pair sname be]]]
              [list-map f [slice l 2 [size l]] [form-to-llexp type-var-set new-lstack f]]]]

          [[word continue]]
          [let [loop-vars
                  [if-let [loop-context [try-get-enclosing-loop-context lstack]]
                    [local-context/vars loop-context]
                    [do
                      [push-error form [quote [not in a loop context]]]
                      [transient-kv-map]]]]
            [llexp/continue
              [list-map p [pairwise-pairs [rest l]]
                [let [name [pair/fst p]
                      sname [sword name]
                      name-word [syntax-word/word sname]
                      be [form-to-llexp type-var-set lstack [pair/snd p]]]
                  [if-let [ldesc [try-get loop-vars name-word]]
                    [set-kv-map form-to-ldesc name ldesc]
                    [push-error name [quote [not a loop var of the current loop]]]]
                  [pair sname be]]]]]

          [[word let]]
          [let
            [bindings [get-list [get-arg 0]]
             lvars [transient-kv-map]
             ctx-let [local-context lvars [local-context-kind/let]]
             new-lstack [local-stack/frame lstack ctx-let]
             ldesc [lllocal-var-kind/let]]
            [when [lt-s n-of-args 2] [push-error form [quote [expected at least 2 arguments]]]]
            [llexp/let
              [list-map p [pairwise bindings]
                [let [name [first p]
                      sname [sword name]
                      name-word [syntax-word/word sname]
                      be [form-to-llexp type-var-set new-lstack [second p]]]
                  [when-let [ldesc2 [try-get-local lstack name-word]]
                    [push-error name [quote [let var shadows local]]]]
                  [set-local lvars name ldesc]
                  [pair sname be]]]
              [list-map f [slice l 2 [size l]] [form-to-llexp type-var-set new-lstack f]]]]

          [[word cast]]
          [do
            [assert-n-args 2]
            [llexp/cast
              [form-to-lltype lstack type-var-set [get-arg 0]]
              [form-to-llexp type-var-set lstack [get-arg 1]]]]

          [[word deref]]
          [do
            [assert-n-args 1]
            [llexp/deref
              [form-to-llexp type-var-set lstack [get-arg 0]]]]

          [[word assign]]
          [do
            [assert-n-args 2]
            [llexp/assign
              [form-to-llexp type-var-set lstack [get-arg 0]]
              [form-to-llexp type-var-set lstack [get-arg 1]]]]

          [[word field]]
          [do
            [assert-n-args 2]
            [llexp/field
              [form-to-llexp type-var-set lstack [get-arg 0]]
              [sword [get-arg 1]]]]

          [[word index]]
          [do
            [assert-n-args 2]
            [llexp/index
              [form-to-llexp type-var-set lstack [get-arg 0]]
              [form-to-llexp type-var-set lstack [get-arg 1]]]]

          [[word size-of]]
          [do
            [assert-n-args 1]
            [llexp/size-of
              [form-to-lltype lstack type-var-set [get-arg 0]]]]

          [[word call]]
          [do
            [assert-n-args 3]
            [let [fform [get-arg 0]
                  fsword [sword fform]
                  fword [syntax-word/word fsword]
                  type-args [get-list [get-arg 1]]
                  exp-args [get-list [get-arg 2]]]
              [if-let [ldesc [try-get-local lstack fword]]
                [logq-abort form-to-llexp explicit rec calls not implemented]
                [if-let [llddesc [try-get lldef-ctx fword]]
                  [match llddesc
                    [lldef-desc/func opt-tparams params]
                    [do
                      [if-let [tparams opt-tparams]
                        [when-not [eq [size tparams] [size type-args]] [push-error form [quote [type arity mismatch]]]]
                        [push-error form [quote [expected a genfn]]]]
                      [when-not [eq [size params] [size exp-args]] [push-error form [quote [exp arity mismatch]]]]
                      [llexp/call fsword
                        [option/some [list-map targ type-args [form-to-lltype lstack type-var-set targ]]]
                        [list-map arg exp-args [form-to-llexp type-var-set lstack arg]]]]

                    [logq-abort form-to-llexp not a func]]
                  [if-let [macro-func [try-get-macro evaluator fword]]
                    [logq-abort form-to-llexp explicit macro call not implemented]
                    [logq-abort form-to-llexp def not found [identity fword]]]]]]]

          [if-let [ldesc [try-get-local lstack first-word]]
            [match ldesc
              [lllocal-var-kind/func-internal-self arity]
              [do
                [assert-n-args arity]
                [llexp/call [sword first-form] [option/none] [list-map arg [rest l] [form-to-llexp type-var-set lstack arg]]]]

              [logq-abort form-to-llexp only rec calls allowed]]
            [if-let [llddesc [try-get lldef-ctx first-word]]
              [match llddesc
                [lldef-desc/func opt-tparams params]
                [do
                  [when-let [tparams opt-tparams]
                    [push-error form [quote [expected type args for genfn]]]]
                  [assert-n-args [size params]]
                  [llexp/call [sword first-form] [option/none] [list-map arg [rest l] [form-to-llexp type-var-set lstack arg]]]]

                [logq-abort form-to-llexp not a func]]
              [if-let [macro-func [try-get-macro evaluator first-word]]
                [form-to-llexp type-var-set lstack [apply macro-func [rest l]]]
                [logq-abort form-to-llexp def not found [identity first-form]]]]]]

        [form/list fl]
        [push-error form [quote [form-to-llexp direct calls not implemented]]]]]]]

[func form-to-param [lvars type-env p]
  [match p
    [form/word w]
    [do
      [set-local lvars p [lllocal-var-kind/param]]
      [pair [sword p] [option/none]]]

    [form/list l]
    [do
      [assert [eq [size l] 3] form-to-lltop expected type form]
      [assert [eq-word [form-to-word [first l]] [word type]]]
      [let [param-name-form [second l]
            t [form-to-lltype [local-stack/empty] type-env [third l]]]
        [set-local lvars param-name-form [lllocal-var-kind/param-with-type t]]
        [pair [sword param-name-form] [option/some t]]]]]]

[func form-to-lltop [form]
  [let
    [report-error [func r [msg] [push-error form msg]]
     l [form-to-list form]
     n-of-args [dec [size l]]
     assert-n-args [func ana [n] [when-not [eq n-of-args n] [report-error [quote [expected n-of-args arguments]]]]]
     get-arg [func get-arg [i] [if [lt-s i n-of-args] [at l [inc i]] [quote 0]]]
     first-form [first l]]
    [match first-form
      [form/word first-word]
      [switch first-word
        [[word data]]
        [lltop/data-active
          [sword [get-arg 1]]
          [form-to-llexp [set] [local-stack/empty] [get-arg 2]]
          [list-map a [slice l 4 [size l]]
            [let [dl [get-list a]]
              [let [data-first [form-to-word [first dl]]]
                [switch data-first
                  [[word bytes]]
                  [data/bytes [list-map b [rest dl] [sword b]]]
                  [[word i32]]
                  [data/i32 [list-map b [rest dl] [sword b]]]
                  [[word f64]]
                  [data/f64 [list-map b [rest dl] [sword b]]]
                  [logq-abort form-to-lltop data kind not recognized]]]]]]

        [[word memory]]
        [let [mem-name [sword [get-arg 1]]
              kind
              [switch [form-to-word [get-arg 0]]
                [[word i32]] [memory-kind/i32]
                [[word i64]] [memory-kind/i64]
                [logq-abort form-to-lltop memory kind not recognized]]]
          [set-ll-def [get-arg 1] [lldef-desc/memory kind]]
          [lltop/memory
            mem-name
            kind
            [sword [get-arg 2]]
            [if [lt-s n-of-args 3] [option/none] [option/some [sword [get-arg 3]]]]]]

        [[word type]]
        [let
          [triples [triplewise [rest l]]]
          [for-each triple triples
            [set-kv-map
              user-type-params
              [form-to-word [first triple]]
              [list-map tp [get-list [second triple]] [sword tp]]]]
          [for-each triple triples
            [let
              [type-name-form [first triple]
               type-params [get-list [second triple]]
               type-decl-list [get-list [third triple]]
               type-env [set]]
              [assert-not [is-empty type-decl-list] empty type decl list]
              [for-each type-param type-params
                [let [tp [form-to-word type-param]]
                  [assert-not [set-has type-env tp] duplicate type param]
                  [set-add type-env tp]]]
              [set-kv-map user-types [form-to-word type-name-form]
                [switch [form-to-word [first type-decl-list]]
                  [[word record]]
                  [let [field-map [transient-kv-map]
                        field-list [growable-list]]
                    [for-each p [rest type-decl-list]
                      [let [ll [get-list p]]
                        [let [field-name [form-to-word [first ll]]
                              fd [form-to-lltype [local-stack/empty] type-env [second ll]]]
                          [push field-list [pair field-name fd]]
                          [set-kv-map field-map field-name fd]]]]
                      [user-type-desc/record field-map [clone-growable-to-frozen-list field-list]]]

                  [[word union]]
                  [let [ctor-map [transient-kv-map]
                        ctor-glist [growable-list]]
                    [for-each ctor-form [rest type-decl-list]
                      [let [ctor-list [form-to-list ctor-form]]
                        [push ctor-glist [form-to-lltype [local-stack/empty] type-env ctor-form]]
                        [set-kv-map
                          ctor-map
                          [form-to-word [first ctor-list]]
                          [list-map t [rest ctor-list]
                            [form-to-lltype [local-stack/empty] type-env t]]]]]
                    [user-type-desc/union ctor-map [clone-growable-to-frozen-list ctor-glist]]]

                  [[word alias]]
                  [user-type-desc/alias [form-to-lltype [local-stack/empty] type-env [second type-decl-list]]]

                  [logq-abort form-to-lltop type kind not implemented [first type-decl-list]]]]]]
              [lltop/type]]

        [[word def]]
        [let [name-form [get-arg 0]]
          [assert-n-args 2]
          [set-ll-def name-form [lldef-desc/any]]
          [lltop/def [sword name-form] [form-to-llexp [set] [local-stack/empty] [get-arg 1]]]]

        [[word defn]]
        [let
          [name-form [get-arg 0]
           params-list [get-list [get-arg 1]]
           bodies [slice l 3 [size l]]
           type-env [set]
           lvars [transient-kv-map]
           lstack [local-stack/frame [local-stack/empty] [local-context lvars [local-context-kind/func]]]
           params [list-map p params-list [form-to-param lvars type-env p]]]
          [set-ll-def name-form [lldef-desc/func [option/none] params]]
          [lltop/defn
            [lldefn
              [sword name-form]
              [option/none]
              params
              [list-map b bodies [form-to-llexp [set] lstack b]]]]]

        [[word genfn]]
        [let
          [name-form [get-arg 0]
           type-params-list [get-list [get-arg 1]]
           params-list [get-list [get-arg 2]]
           bodies [slice l 4 [size l]]
           type-env [set]
           lvars [transient-kv-map]
           lstack [local-stack/frame [local-stack/empty] [local-context lvars [local-context-kind/func]]]
           tparams [list-map tp type-params-list [sword tp]]]
          [for-each type-param type-params-list
            [set-add type-env [form-to-word type-param]]]
          [let
            [params [list-map p params-list [form-to-param lvars type-env p]]]
            [set-ll-def name-form [lldef-desc/func [option/some tparams] params]]
            [lltop/defn
              [lldefn
                [sword name-form]
                [option/some tparams]
                params
                [list-map b bodies [form-to-llexp type-env lstack b]]]]]]

        [[word export]]
        [lltop/export
          [list-map f [rest l]
            [let [sw [sword f]]
              [when-not [has lldef-ctx [syntax-word/word sw]]
                [push-error f [quote [not a defined name]]]]
              sw]]]

        [do
          [log form]
          [logq-abort form-to-lltop not implemented]]]

      [form/list fl]
      [logq-abort direct call at top not supported]]]]]
    [func forms-to-btops [forms]
      [pair
        [list-map form forms [form-to-lltop form]]
        [llctx
          lldef-ctx
          form-to-ldesc
          user-type-params
          user-types
          bound-form-to-form]]]]]]

[type type-constraint []
  [union
    [size-of]
    [literal]]]

[def type-constraint-size-of [type-constraint/size-of]]

[type type-var-id []
  [union
    [word word]
    [number i32]]]

[type
  type-var-kind []
  [union
    [linked ctype]
    [unlinked [type-var-id]]]

  type-var []
  [record
    [kind [atom type-var-kind]]
    [level [atom i32]]
    [constraints [set type-constraint]]]

  ctype []
  [union
    [var type-var]
    [literal type-literal]
    [apply word [list ctype]]]]

[defn get-type-var-kind [type-var]
  [atom-get [type-var/kind type-var]]]

[defn copy-type-constraints [tv-dst tv-src]
  [for-each tc [set-to-list [type-var/constraints tv-src]]
    [set-add [type-var/constraints tv-dst] tc]]]

[defn set-type-var-kind-to-type [type-var type]
  [atom-set [type-var/kind type-var] [type-var-kind/linked type]]
  [match type
    [ctype/var tv2]
    [do
      [copy-type-constraints tv2 type-var]]

    [do]]]

[defn normalize-type [t0]
  [match t0
    [ctype/var tv]
    [match [get-type-var-kind tv]
      [type-var-kind/unlinked id] t0
      [type-var-kind/linked linked-t]
      [let [t2 [normalize-type linked-t]]
        [set-type-var-kind-to-type tv t2]
        t2]]
    t0]]

[defn form-to-print-form [e]
  [match e
    [llexp/literal l]
    [match l
      [llliteral/i32 sw] [form/list [list [quote i32] [form/word [syntax-word/word sw]]]]
      [llliteral/f64 sw] [form/list [list [quote f64] [form/word [syntax-word/word sw]]]]

      [logq-abort form-to-print-form unexpected literal type]]

    [llexp/var v] [form/word [syntax-word/word v]]

    [logq-abort form-to-print-form unexpected form type]]]

[defn int-to-type-var-name [i]
  [if [lt-s i [i32 26]]
    [char-code-to-word [add [i32 97] i]]
    [concat-words
      [int-to-type-var-name [i32.div-s i [i32 26]]]
      [char-code-to-word [add [i32 97] [i32.rem-s i [i32 26]]]]]]]

[defn ctype-to-print-form [ct]
  [match [normalize-type ct]
    [ctype/var tv]
    [match [get-type-var-kind tv]
      [type-var-kind/unlinked id]
      [match id
        [type-var-id/word w] [form/word w]
        [type-var-id/number i] [form/word [int-to-type-var-name i]]]

      [type-var-kind/linked -]
      [logq-abort ctype-to-print-form unexpected linked type variable type should have been normalized]]

    [ctype/literal tl]
    [match tl
      [type-literal/memory sw] [form/list [list [quote memory] [form/word [syntax-word/word sw]]]]
      [type-literal/exp e]
      [form/list [list [quote literal] [form-to-print-form e]]]]

    [ctype/apply type-name type-args]
    [form-concat
      [list [form/word type-name]]
      [list-map targ type-args [ctype-to-print-form targ]]]]]

[defn try-get-apply-type [t]
  [match [normalize-type t]
    [ctype/apply type-name type-args]
    [option/some [pair type-name type-args]]

    [option/none]]]

[defn get-tuple-types [t]
  [if-let [at [try-get-apply-type t]]
    [if [eq-word [word tuple] [pair/fst at]]
      [pair/snd at]
      [list t]]
    [logq-abort get-tuple-types]]]

[defn get-func-type [t]
  [if-let [at [try-get-apply-type t]]
    [if [eq-word [word func] [pair/fst at]]
      [let [type-args [pair/snd at]]
        [pair [get-tuple-types [first type-args]] [second type-args]]]
      [logq-abort get-func-type expected a func type [identity t]]]
    [logq-abort get-func-type expected a func type [identity t]]]]

[defn get-apply-type [t msg]
  [if-let [at [try-get-apply-type t]]
    at
    [logq-abort get-apply-type expected an apply type [identity t] [identity msg]]]]

[defn make-type-list [type-name type-args] [ctype/apply type-name type-args]]

[defn make-type [type-name .. type-args] [make-type-list type-name type-args]]

[def type-i32 [make-type [word i32]]]
[def type-f64 [make-type [word f64]]]
[def type-f32 [make-type [word f32]]]
[def type-i64 [make-type [word i64]]]

[defn type-pointer [mem target] [make-type [word pointer] mem target]]
[defn type-array [elem-type size] [make-type [word array] elem-type size]]
[defn type-tuple-list [types] [make-type-list [word tuple] types]]

[def type-empty-tuple [type-tuple-list [list]]]

[defn type-func [params result]
  [make-type [word func]
    [if [eq [size params] 1]
      [first params]
      [type-tuple-list params]] result]]

[type check-type-scheme []
  [record
    [named-type-params [list word]]
    [type-vars [list type-var]]
    [type ctype]]]

[type llcheck-context []
  [record
    [def-var-types [transient-kv-map word check-type-scheme]]
    [type-var-counter [atom i32]]
    [type-annotations [transient-kv-map js-value ctype]]
    [type-instantiations [transient-kv-map syntax-word [list ctype]]]
    [bind-ctx llctx]]]

[defn llcheck-context-empty [bind-ctx]
  [llcheck-context
    [transient-kv-map]
    [atom 0]
    [transient-kv-map]
    [transient-kv-map]
    bind-ctx]]

[defn lltry-get-var-type [gctx local-ctx var-name]
  [if-let [ltype [try-get-local local-ctx var-name]]
    [option/some ltype]
    [try-get [llcheck-context/def-var-types gctx] var-name]]]

[defn make-type-var [kind level]
  [type-var [atom kind] [atom level] [set]]]

[defn generate-fresh-type-var-atom-var [counter-atom level]
  [make-type-var [type-var-kind/unlinked [type-var-id/number [inc-atom counter-atom]]] level]]

[defn generate-fresh-type-var-atom [counter-atom level]
  [ctype/var [generate-fresh-type-var-atom-var counter-atom level]]]

[defn mk-empty-type-scheme [type] [check-type-scheme [list] [list] type]]

[defn type-var-id-to-word [id]
  [match id
    [type-var-id/word tpw]
    tpw

    [type-var-id/number n]
    [concat-words [word ---num-] [int-to-type-var-name n]]]]

[defn copy-type-proper [proper-subst-map outer-t]
  [[func go [t] [match t
    [ctype/var tv]
    [match [get-type-var-kind tv]
      [type-var-kind/linked linked-t] [go linked-t]
      [type-var-kind/unlinked id]
      [if-let [subst-t [try-get proper-subst-map [type-var-id-to-word id]]]
        subst-t
        [do
          [logq copy-type-proper type var not found [identity id]]
          t]]]

    [ctype/literal l] t

    [ctype/apply type-name type-args]
    [ctype/apply type-name [list-map arg type-args [go arg]]]]]
    outer-t]]

[defn member-type-var-list [set t]
  [todo can we just use set-has here]
  [[func member-type-var-list-go [i]
    [if [lt-s i [size set]]
      [if [is-identical [at set i] t]
        1
        [member-type-var-list-go [inc i]]]
      0]] 0]]

[defn free-type-vars [outer-t]
  [let
    [ftvs [set]
     go
     [func go [t]
      [let [nt [normalize-type t]]
        [match nt
          [ctype/var tv]
          [when-not [set-has ftvs tv]
            [set-add ftvs tv]]

          [ctype/literal l]
          [do]

          [ctype/apply type-name type-args]
          [for-each arg type-args [go arg]]]]]]
    [go outer-t]
    [set-to-list ftvs]]]

[defn prune-level [max-level tvs]
  [for-each tv tvs
    [let [tvla [type-var/level tv]]
      [atom-set tvla [min [atom-get tvla] max-level]]]]]

[defn get-type-var-level [tv]
  [atom-get [type-var/level tv]]]

[defn link-var-to-type [type-var type]
  [let
    [level [get-type-var-level type-var]
     fvs [free-type-vars type]]
    [todo report instead of assert]
    [assert [not [member-type-var-list fvs type-var]] type-var occurs in type]
    [prune-level level fvs]
    [set-type-var-kind-to-type type-var type]]]

[defn type-literal-desc-equals [l1 l2]
  [match l1
    [type-literal/memory mem1]
    [match l2
      [type-literal/memory mem2]
      [eq-word [syntax-word/word mem1] [syntax-word/word mem2]]

      false]

    false]]

[defn mem-name-from-mem-type [tmem]
  [match [normalize-type tmem]
    [ctype/literal l]
    [match l
      [type-literal/memory mem-name]
      [syntax-word/word mem-name]

      [logq-abort mem-name-from-mem-type not a memory type [identity tmem]]]
    [logq-abort mem-name-from-mem-type not a memory type [identity tmem]]]]

[defn get-memory-kind [llctx mem-name]
  [if-let [dd [try-get [llctx/lldef-ctx llctx] mem-name]]
    [match dd
      [lldef-desc/memory kind]
      kind
      [logq-abort get-memory-kind not a memory desc]]
    [logq-abort get-memory-kind not found [identity mem-name]]]]

[defn get-type-var-id [tv1]
  [match [get-type-var-kind tv1]
    [type-var-kind/unlinked id1]
    id1

    [logq-abort get-type-var-id unexpected linked type var]]]

[defn unify [gctx outer-t1 outer-t2]
  [let
    [errors [growable-list]
     push-unify-error
     [func push-unify-error [msg] [push errors msg]]
     go
     [func go [t1 t2]
      [let [nt1 [normalize-type t1]
            nt2 [normalize-type t2]]
        [match nt1
          [ctype/var tv1]
          [match nt2
            [ctype/var tv2]
            [when-not [is-identical tv1 tv2]
              [todo handle named type vars here]
              [let [l1 [get-type-var-level tv1]
                    l2 [get-type-var-level tv2]]
                [ifs
                  [lt-s l1 l2]
                  [link-var-to-type tv1 nt2]

                  [eq l1 l2]
                  [do
                    [logq unify link-var-to-type [identity tv1] [identity tv2]]
                    [match [get-type-var-id tv1]
                      [type-var-id/word w1]
                      [link-var-to-type tv2 nt1]

                      [match [get-type-var-id tv2]
                        [type-var-id/word w2]
                        [link-var-to-type tv1 nt2]

                        [link-var-to-type tv2 nt1]]]]

                  [do
                    [logq unify link-var-to-type [identity tv1] [identity tv2]]
                    [link-var-to-type tv2 nt1]]]]]

            [ctype/literal l2]
            [link-var-to-type tv1 nt2]

            [ctype/apply tn2 tas2]
            [link-var-to-type tv1 nt2]]

          [ctype/literal l1]
          [match nt2
            [ctype/var tv2]
            [link-var-to-type tv2 nt1]

            [ctype/literal l2]
            [when-not [type-literal-desc-equals l1 l2]
              [log l1 l2]
              [push-unify-error [quote [not unifiable - different literals]]]]

            [ctype/apply tn2 tas2]
            [push-unify-error [quote [not unifiable - literal vs inst]]]]

          [ctype/apply type-name1 type-args1]
          [match nt2
            [ctype/var tv2]
            [link-var-to-type tv2 nt1]

            [ctype/literal l2]
            [push-unify-error [quote [not unifiable - inst vs literal]]]

            [ctype/apply type-name2 type-args2]
            [if [eq-word type-name1 type-name2]
              [if [eq [size type-args1] [size type-args2]]
                [for i 0 [size type-args1]
                  [go [at type-args1 i] [at type-args2 i]]]
                [push-unify-error [quote [not unifiable - different number of type arguments]]]]
                [do
                  [if-let [user-desc [try-get [llctx/user-types [llcheck-context/bind-ctx gctx]] type-name1]]
                    [match user-desc
                      [user-type-desc/alias aliased-type]
                      [logq-abort unify error aliased type not expanded]

                      [user-type-desc/union union-ctor-map ctor-list]
                      [if-let [ctor-args [try-get union-ctor-map type-name2]]
                        [assert [is-empty ctor-args] not implemented]
                        [push-unify-error [quote [not unifiable - different constructors]]]]

                      [push-unify-error [quote [not unifiable - different types]]]]
                    [do
                      [if [eq-word type-name1 [word pointer]]
                        [let [mem-type [normalize-type [first type-args1]]]
                          [match mem-type
                            [ctype/literal l]
                            [match l
                              [type-literal/memory mem-name]
                              [match [get-memory-kind [llcheck-context/bind-ctx gctx] [syntax-word/word mem-name]]
                                [memory-kind/i32] [go type-i32 nt2]
                                [memory-kind/i64] [go type-i64 nt2]
                                [push-unify-error [quote [not unifiable - different memory types]]]]

                              [push-unify-error [quote [unify not a memory type1]]]]

                            [do
                              [logq mem-type [identity mem-type]]
                              [push-unify-error [quote [unify not a memory type2]]]]]]
                        [push-unify-error [quote [not unifiable - different types]]]
                        ]]]
                      [push-unify-error [quote [not unifiable - different types]]]]]]]]]]
    [go outer-t1 outer-t2]
    [clone-growable-to-frozen-list errors]]]

[defn llunify-report [gctx t1 t2 bst]
  [for-each error [unify gctx t1 t2]
    [logq bst [identity bst]]
    [log-location [get [llctx/bound-form-to-form [llcheck-context/bind-ctx gctx]] [to-js-value bst]]]
    [logq-abort llunify-report error [identity error] [ctype-to-print-form t1] -vs- [ctype-to-print-form t2] ---form--- [identity bst]]]]

[defn llannotate [gctx bst type]
  [set-kv-map [llcheck-context/type-annotations gctx] [to-js-value bst] type]
  type]

[defn instantiate-syntax-type-no-env [gctx level syntax-type]
  [[func go [st]
    [match st
      [lltype/var tv]
      [ctype/var
        [make-type-var
          [type-var-kind/unlinked
            [let [w [syntax-word/word tv]]
              [if [starts-with-dash w]
                [type-var-id/number [inc-atom [llcheck-context/type-var-counter gctx]]]
                [type-var-id/word w]]]]
          level]]

      [lltype/literal l]
      [ctype/literal l]

      [lltype/apply type-name targs]
      [let [tnw [syntax-word/word type-name]]
        [if-let [user-desc [try-get [llctx/user-types [llcheck-context/bind-ctx gctx]] tnw]]
          [match user-desc
            [user-type-desc/alias aliased-type]
            [let
              [user-type-params [get [llctx/user-type-params [llcheck-context/bind-ctx gctx]] tnw]
               type-env [transient-kv-map]]
              [for i 0 [size user-type-params]
                [set-kv-map type-env [syntax-word/word [at user-type-params i]] [at targs i]]]
              [instantiate-syntax-type-no-env gctx level
                [[func subst [t]
                  [match t
                    [lltype/var tv]
                    [let [tvw [syntax-word/word tv]]
                      [if [starts-with-dash tvw]
                        t
                        [get type-env tvw]]]

                    [lltype/literal l] t

                    [lltype/apply alias-name alias-args]
                    [lltype/apply alias-name [list-map arg alias-args [subst arg]]]]]
                  aliased-type]]]

            [make-type-list tnw [list-map ta targs [go ta]]]]
          [make-type-list tnw [list-map ta targs [go ta]]]]]]]
    syntax-type]]

[type infer-local-context []
  [record
    [stack [local-stack check-type-scheme]]
    [type-env [transient-kv-map word ctype]]]]

[defn make-local-context [var-values lstack kind]
  [local-stack/frame lstack [local-context var-values kind]]]

[defn generalize [current-level type]
  [let [tvs [growable-list]
        ftvs [free-type-vars type]]
    [for-each tv ftvs
      [if [lt-s current-level [get-type-var-level tv]]
        [push tvs tv]
        [comment [logq tv not generalized [identity tv]]]
        ]]
    [let [fftvs [clone-growable-to-frozen-list tvs]]
      [check-type-scheme [list] fftvs type]]]]

[defn lift-data-type [t]
  [match [normalize-type t]
    [ctype/apply type-name type-args]
    [if [wuns-builtin-data-type-is type-name]
      type-i32
      t]
    t]]

[defn make-type-env [llctx type-name type-args]
  [let [type-params [get [llctx/user-type-params llctx] type-name]
        new-tv-env [transient-kv-map]]
    [assert [eq [size type-params] [size type-args]] make-type-env expected equal number of type params and type args]
    [for i 0 [size type-args]
      [set-kv-map new-tv-env [syntax-word/word [at type-params i]] [at type-args i]]]
    new-tv-env]]

[defn llliteral-to-type [l]
  [match l
    [llliteral/i32 -] type-i32
    [llliteral/i64 -] type-i64
    [llliteral/f32 -] type-f32
    [llliteral/f64 -] type-f64
    [logq-abort llliteral-to-type not implemented]]]

[defn get-specialized-var [gctx level lctx sw]
  [if-let [scheme [lltry-get-var-type gctx lctx [syntax-word/word sw]]]
    [let [type-params [check-type-scheme/type-vars scheme]
          type-env [transient-kv-map]
          type-args [growable-list]]
      [for i 0 [size type-params]
        [match [get-type-var-kind [at type-params i]]
          [type-var-kind/unlinked id]
          [let [ta [generate-fresh-type-var-atom [llcheck-context/type-var-counter gctx] level]]
            [push type-args ta]
            [set-kv-map type-env [type-var-id-to-word id] ta]]

          [logq-abort get-specialized-var was a linked param]]]

      [set-kv-map [llcheck-context/type-instantiations gctx] sw [clone-growable-to-frozen-list type-args]]
      [copy-type-proper type-env [check-type-scheme/type scheme]]]
    [logq-abort llvariable not found [identity sw]]]]

[defn get-specialized-var-type-args [gctx level lctx sw type-args]
  [if-let [scheme [lltry-get-var-type gctx lctx [syntax-word/word sw]]]
    [let [type-params [check-type-scheme/named-type-params scheme]
          type-env [transient-kv-map]]
      [assert [eq [size type-params] [size type-args]] arity mismatch]
      [logq get-specialized-var-type-args scheme [check-type-scheme/type-vars scheme]]
      [logq get-specialized-var-type-args scheme [check-type-scheme/type scheme]]
      [logq get-specialized-var-type-args type-params [identity type-params]]
      [for i 0 [size type-args]
        [set-kv-map type-env [at type-params i] [at type-args i]]]
      [set-kv-map [llcheck-context/type-instantiations gctx] sw type-args]
      [copy-type-proper type-env [check-type-scheme/type scheme]]]
    [logq-abort llvariable not found [identity sw]]]]

[defn infer-llexp [gctx level lctx bform]
  [match bform
    [llexp/var sw]
    [let [t [get-specialized-var gctx level [infer-local-context/stack lctx] sw]]
      [llannotate gctx bform t]]

    [llexp/literal l]
    [llliteral-to-type l]

    [llexp/do bodies]
    [if [is-empty bodies]
      type-empty-tuple
      [do
        [for i 0 [dec [size bodies]]
          [infer-llexp gctx level lctx [at bodies i]]]
        [infer-llexp gctx level lctx [last bodies]]]]

    [llexp/intrinsic inst-name imm-args iargs]
    [let [w [syntax-word/word inst-name]]
      [ifs
        [is-i32-bin-inst w]
        [let [a [at iargs 0] b [at iargs 1]]
          [llunify-report gctx type-i32 [infer-llexp gctx level lctx a] a]
          [llunify-report gctx type-i32 [infer-llexp gctx level lctx b] b]
          type-i32]

        [is-f64-bin-inst w]
        [let [a [at iargs 0] b [at iargs 1]]
          [llunify-report gctx type-f64 [infer-llexp gctx level lctx a] a]
          [llunify-report gctx type-f64 [infer-llexp gctx level lctx b] b]
          type-f64]

        [is-f64-comp-inst w]
        [let [a [at iargs 0] b [at iargs 1]]
          [llunify-report gctx type-f64 [infer-llexp gctx level lctx a] a]
          [llunify-report gctx type-f64 [infer-llexp gctx level lctx b] b]
          type-i32]

        [switch w
          [[word unreachable]]
          [generate-fresh-type-var-atom [llcheck-context/type-var-counter gctx] level]

          [[word i32.load] [word i32.load8-u]]
          [let
            [addr [first iargs]]
            [llunify-report gctx type-i32 [infer-llexp gctx level lctx addr] addr]
            type-i32]

          [[word i32.store] [word i32.store8]]
          [let
            [addr [first iargs]
             value [second iargs]]
            [llunify-report gctx type-i32 [infer-llexp gctx level lctx addr] addr]
            [llunify-report gctx type-i32 [infer-llexp gctx level lctx value] value]
            type-empty-tuple]

          [logq-abort bin intrinsic not implemented]]]]

    [llexp/if cond then else]
    [let
      [cond-type [infer-llexp gctx level lctx cond]
       then-type [infer-llexp gctx level lctx then]
       else-type [infer-llexp gctx level lctx else]]
      [llunify-report gctx type-i32 cond-type cond]
      [llunify-report gctx then-type else-type then]
      [llannotate gctx bform then-type]]

    [llexp/let bindings bodies]
    [let
      [var-types [transient-kv-map]
       let-ctx [infer-local-context
                  [make-local-context var-types [infer-local-context/stack lctx] [local-context-kind/let]]
                  [infer-local-context/type-env lctx]]
       level-1 [inc level]]
      [for-each binding bindings
        [let
          [var [pair/fst binding]
           value [pair/snd binding]
           val-type [lift-data-type [infer-llexp gctx level-1 let-ctx value]]
           general-val-type
            [if [is-syntactic-llvalue value]
              [generalize level val-type]
              [mk-empty-type-scheme val-type]]]
          [llannotate gctx value val-type]
          [set-kv-map var-types [syntax-word/word var] general-val-type]]]
      [if [is-empty bodies]
        type-empty-tuple
        [do
          [for i 0 [dec [size bodies]]
            [infer-llexp gctx level let-ctx [at bodies i]]]
          [infer-llexp gctx level let-ctx [last bodies]]]]]

    [llexp/loop bindings bodies]
    [let
      [var-types [transient-kv-map]
       loop-ctx
        [infer-local-context
          [make-local-context var-types [infer-local-context/stack lctx] [local-context-kind/loop]]
          [infer-local-context/type-env lctx]]
       level-1 [inc level]]
      [for-each binding bindings
        [let
          [var [pair/fst binding]
            value [pair/snd binding]
            val-type [lift-data-type [infer-llexp gctx level-1 loop-ctx value]]
            general-val-type [mk-empty-type-scheme val-type]]
          [llannotate gctx value val-type]
          [set-kv-map var-types [syntax-word/word var] general-val-type]]]
      [llannotate gctx bform
        [if [is-empty bodies]
          type-empty-tuple
          [do
            [for i 0 [dec [size bodies]]
              [infer-llexp gctx level loop-ctx [at bodies i]]]
            [infer-llexp gctx level loop-ctx [last bodies]]]]]]

    [llexp/continue assignments]
    [do
      [when-let [loop-context [try-get-enclosing-loop-context [infer-local-context/stack lctx]]]
        [for-each assignment assignments
          [let
            [loop-vars [local-context/vars loop-context]
             loop-var-type-scheme [get loop-vars [syntax-word/word [pair/fst assignment]]]
             value [pair/snd assignment]
             val-type [infer-llexp gctx level lctx value]]
            [llunify-report gctx [check-type-scheme/type loop-var-type-scheme] val-type value]]]]
      [generate-fresh-type-var-atom [llcheck-context/type-var-counter gctx] level]]

    [llexp/call fname-sword opt-type-args args]
    [let
      [spec-func-type
        [if-let [type-args opt-type-args]
          [let [ctype-args [list-map type-arg type-args [instantiate-syntax-type-no-env gctx level type-arg]]]
            [do
              [logq call [syntax-word/word fname-sword] [identity ctype-args]]
              [get-specialized-var-type-args
                gctx level [infer-local-context/stack lctx] fname-sword ctype-args]]]
          [get-specialized-var gctx level [infer-local-context/stack lctx] fname-sword]]
       arg-types [list-map-fn [func f [arg] [infer-llexp gctx level lctx arg]] args]
       t-res [generate-fresh-type-var-atom [llcheck-context/type-var-counter gctx] level]
       t-func [type-func arg-types t-res]]
      [logq infer call spec [syntax-word/word fname-sword] [ctype-to-print-form spec-func-type]]
      [logq infer call tfun [syntax-word/word fname-sword] [ctype-to-print-form t-func]]
      [llunify-report gctx spec-func-type t-func bform]
      [llannotate gctx bform t-res]]

    [llexp/cast cast-type value]
    [let
      [inst-type [instantiate-syntax-type-no-env gctx level cast-type]
       tv [infer-llexp gctx level lctx value]
       inst-app-t [get-apply-type inst-type [word cast]]
       tv-type-name [pair/fst [get-apply-type tv [word cast1]]]]
      [todo we allow casting i32 or i64 to pointer if the memory matches]
      [if [and [eq-word [pair/fst inst-app-t] [word pointer]] [not [eq-word tv-type-name [word pointer]]]]
        [match [get-memory-kind [llcheck-context/bind-ctx gctx] [mem-name-from-mem-type [first [pair/snd inst-app-t]]]]
          [memory-kind/i32]
          [when-not [eq-word tv-type-name [word i32]]
            [logq-abort can only cast i32 to pointer [identity bform]]]

          [memory-kind/i64]
          [when-not [eq-word tv-type-name [word i64]]
            [logq-abort can only cast i64 to pointer [identity bform]]]]
        [llunify-report gctx inst-type tv value]]
      [llannotate gctx bform inst-type]]

    [llexp/size-of t]
    [let
      [tenv [infer-local-context/type-env lctx]
       it [instantiate-syntax-type-no-env gctx level t]]
      [todo if there is a free type var inside a [pointer m tv] we should not add a constraint on it]
      [for-each tv [free-type-vars it]
        [set-add [type-var/constraints tv] type-constraint-size-of]]
      [llannotate gctx t it]
      type-i32]

    [llexp/deref value]
    [let [t-mem [generate-fresh-type-var-atom [llcheck-context/type-var-counter gctx] level]
          t-res [generate-fresh-type-var-atom [llcheck-context/type-var-counter gctx] level]
          t-val [infer-llexp gctx level lctx value]]
      [llunify-report gctx [type-pointer t-mem t-res] t-val value]
      [llannotate gctx bform [lift-data-type t-res]]]

    [llexp/assign target value]
    [let [t-mem [generate-fresh-type-var-atom [llcheck-context/type-var-counter gctx] level]
          t-val [generate-fresh-type-var-atom [llcheck-context/type-var-counter gctx] level]
          pt [type-pointer t-mem t-val]]
      [llunify-report gctx pt [infer-llexp gctx level lctx target] target]
      [match [normalize-type t-val]
        [ctype/literal tl]
        [match value
          [llexp/literal el]
          [match el
            [llliteral/i32 ei]
            [match tl
              [type-literal/exp tlei32]
              [match tlei32
                [llexp/literal e] [do]

                [do]]
              [do]]]

          [logq-abort infer-llexp cannot assign literal to non-literal [identity bform]]]

        [llunify-report gctx [lift-data-type t-val] [infer-llexp gctx level lctx value] value]]
      [llannotate gctx target pt]
      type-empty-tuple]

    [llexp/field target field-name]
    [let
      [ttarget [infer-llexp gctx level lctx target]
       t-mem [generate-fresh-type-var-atom [llcheck-context/type-var-counter gctx] level]
       t-rec [generate-fresh-type-var-atom [llcheck-context/type-var-counter gctx] level]
       pt [type-pointer t-mem t-rec]]
[comment        [llannotate gctx target pt] ]
      [llunify-report gctx ttarget pt target]
[comment        [llannotate gctx bform
        [type-pointer t-mem inst-field-type]] ]
      [if-let [apt [try-get-apply-type t-rec]]
        [do]
        [do
          [log-location [get [llctx/bound-form-to-form [llcheck-context/bind-ctx gctx]] [to-js-value bform]]]
          [logq-abort infer-llexp not implemented]]]
      [let
        [app-type [get-apply-type t-rec [pair [word infer-field] field-name]]
         type-name [pair/fst app-type]]
        [if-let [type-desc [try-get [llctx/user-types [llcheck-context/bind-ctx gctx]] type-name]]
          [match type-desc
            [user-type-desc/record field-map field-list]
            [if-let [fd [try-get field-map [syntax-word/word field-name]]]
              [llannotate gctx bform
                [type-pointer t-mem [instantiate-syntax-type-no-env gctx level fd]]]
              [logq-abort infer-llexp field not found [identity field-name]]]

            [user-type-desc/union ctor-map ctor-types]
            [let [inst-field-type [generate-fresh-type-var-atom [llcheck-context/type-var-counter gctx] level]]
              [for-each ctor-type ctor-types
                [instantiate-syntax-type-no-env gctx level ctor-type]
                [logq-abort not imple]
                ]
              inst-field-type]

            [logq-abort infer-llexp not a union or record type]]

          [logq-abort infer-llexp field type not found [identity field-name] [identity type-name]]]]]

    [llexp/index target index]
    [let
      [ttarget [infer-llexp gctx level lctx target]
       t-mem [generate-fresh-type-var-atom [llcheck-context/type-var-counter gctx] level]
       t-elem [generate-fresh-type-var-atom [llcheck-context/type-var-counter gctx] level]
       t-size [generate-fresh-type-var-atom [llcheck-context/type-var-counter gctx] level]
       t-arr [type-array t-elem t-size]
       pt [type-pointer t-mem t-arr]]
[comment        [llannotate gctx target pt] ]
      [llunify-report gctx ttarget pt target]
      [llunify-report gctx type-i32 [infer-llexp gctx level lctx index] index]
      [llannotate gctx bform [type-pointer t-mem t-elem]]]

    [do
      [log bform]
      [logq-abort infer-llexp not implemented]]]]

[defn infer-forms [gctx level lctx bodies]
  [if [is-empty bodies]
    type-empty-tuple
    [do
      [for i 0 [dec [size bodies]]
        [infer-llexp gctx level lctx [at bodies i]]]
      [infer-llexp gctx level lctx [last bodies]]]]]

[defn infer-lltop [gctx lltop]
  [match lltop
    [lltop/memory mem-name mem-kind mem-size mem-export]
    [do]

    [lltop/type]
    [do]

    [lltop/data-active mem-name mem-expr datas]
    [do]

    [lltop/def var value]
    [let
      [value-type [infer-llexp gctx 1 [infer-local-context [local-stack/empty] [transient-kv-map]] value]
       general-val-type
        [if [is-syntactic-llvalue value]
          [generalize 0 value-type]
          [mk-empty-type-scheme value-type]]]
        [set-kv-map [llcheck-context/def-var-types gctx] [syntax-word/word var] general-val-type]]

    [lltop/defn func]
    [let
      [level-1 1
       counter-atom [llcheck-context/type-var-counter gctx]
       gfunc-type [generate-fresh-type-var-atom counter-atom level-1]
       param-ctx [transient-kv-map]
       type-env [transient-kv-map]
       reg-params [growable-list]
       fname-word [syntax-word/word [lldefn/name func]]
       infer-type-params [growable-list]]
      [when-let [type-params [lldefn/type-params func]]
        [for-each type-param type-params
          [let [tpw [syntax-word/word type-param]
                itp [make-type-var [type-var-kind/unlinked [type-var-id/word tpw]] level-1]]
            [push infer-type-params tpw]
            [set-kv-map type-env tpw [ctype/var itp]]]]]
      [set-kv-map param-ctx fname-word [mk-empty-type-scheme gfunc-type]]
      [logq /defn [identity fname-word]]
      [for-each param [lldefn/params func]
        [let
          [t
            [if-let [param-t [pair/snd param]]
              [instantiate-syntax-type-no-env gctx level-1 param-t]
              [generate-fresh-type-var-atom counter-atom level-1]]
           pn [syntax-word/word [pair/fst param]]]
          [logq /defn-param [identity pn] [identity t]]
          [set-kv-map param-ctx pn [mk-empty-type-scheme t]]
          [push reg-params t]
          [llannotate gctx [pair/fst param] t]]]
      [let [func-ctx
            [infer-local-context
              [make-local-context param-ctx [local-stack/empty] [local-context-kind/func]]
              type-env]
            return-type [infer-forms gctx level-1 func-ctx [lldefn/bodies func]]
            ct
            [type-func
              [clone-growable-to-frozen-list reg-params]
              return-type]]
        [llunify-report gctx
          gfunc-type
          ct
          lltop]
        [llannotate gctx lltop ct]
        [let
          [ts
            [if-let [type-params [lldefn/type-params func]]
              [let [tps [clone-growable-to-frozen-list infer-type-params]
                    ets [check-type-scheme tps [list] ct]]
                ets]
              [generalize 0 ct]]]
          [logq /defn [identity fname-word] [check-type-scheme/type-vars ts] [ctype-to-print-form
            [check-type-scheme/type ts]]]
          [logq /defn-params [clone-growable-to-frozen-list reg-params]]
          [log]
          [set-kv-map
            [llcheck-context/def-var-types gctx]
            fname-word
            ts]]]]

    [lltop/export es]
    [let [bind-ctx [llcheck-context/bind-ctx gctx]
          lldef-ctx [llctx/lldef-ctx bind-ctx]]
      [for-each e es
        [match [get lldef-ctx [syntax-word/word e]]
          [lldef-desc/memory kind] [do]
          [do
            [llannotate gctx e [get-specialized-var gctx 0 [local-stack/empty] e]]
            [do]]]]]]]

[defn get-annotation [cctx bst]
  [if-let [anno [try-get [llcheck-context/type-annotations cctx] [to-js-value bst]]]
    anno
    [logq-abort get-annotation expected an annotation [identity bst]]]]

[defn get-ctype [gctx bform]
  [match bform
    [llexp/literal l]
    [match l
      [llliteral/i32 i] type-i32
      [llliteral/f64 f] type-f64
      [logq-abort get-ctype literal not implemented]]

    [llexp/intrinsic inst-name imm ica]
    [ifs
      [is-i32-bin-inst [syntax-word/word inst-name]]
      type-i32

      [is-f64-bin-inst [syntax-word/word inst-name]]
      type-f64

      [is-f64-comp-inst [syntax-word/word inst-name]]
      type-i32

      [logq-abort intrinsic not implemented]]

    [llexp/do forms]
    [if [is-empty forms]
      type-empty-tuple
      [get-ctype gctx [last forms]]]

    [llexp/let bindings forms]
    [if [is-empty forms]
      type-empty-tuple
      [get-ctype gctx [last forms]]]

    [llexp/loop bindings forms]
    [if [is-empty forms]
      type-empty-tuple
      [get-ctype gctx [last forms]]]

    [llexp/assign target value]
    type-empty-tuple

    [llexp/size-of t]
    type-i32

    [get-annotation gctx bform]]]

[type wat-inst-memargs []
  [record
    [memory word]
    [offset word]
    [alignment word]]]

[type wat-inst []
  [union
    [i32.const word]
    [i64.const word]
    [f32.const word]
    [f64.const word]
    [local.get word]
    [local.set word wat-inst]
    [global.get word]
    [inst byte-array [list wat-inst]]
    [load byte-array wat-inst-memargs wat-inst]
    [store byte-array wat-inst-memargs wat-inst wat-inst]
    [if [list word] wat-inst wat-inst wat-inst]
    [call word [list wat-inst]]
    [instructions [list wat-inst]]
    [loop word [list word] wat-inst]
    [br word]]]

[def ascii-underscore [i32 95]]

[comment wuns does not have underscores so we convert dashes to underscores]

[defn wasm-name-to-wat-byte-array [w]
  [let [sw [word-byte-size w]
        res [byte-array sw]]
    [for i 0 sw
      [byte-array-set res i
        [let [c [char-code-at w i]] [if [eq c [word-to-char-code -]] ascii-underscore c]]]]
    res]]

[def drop-name-byte-array [wasm-name-to-wat-byte-array [word drop]]]

[defn wat-inst-drop [i]
  [wat-inst/inst drop-name-byte-array [list i]]]

[defn wat-inst-i32.add [a b]
  [wat-inst/inst
    [wasm-name-to-wat-byte-array [word i32.add]]
    [list a b]]]

[defn wat-inst-i32.mul [a b]
  [wat-inst/inst
    [wasm-name-to-wat-byte-array [word i32.mul]]
    [list a b]]]

[defn datas-to-byte-array [datas]
  [let
    [n-datas [size datas]
     total-size
      [loop [i 0 sum 0]
        [if [le-s n-datas i]
          sum
          [continue
            sum [add sum [match [at datas i]
                          [data/bytes bs] [size bs]
                          [data/i32 is] [mul [size is] 4]
                          [data/f64 fs] [mul [size fs] 8]]]
            i [inc i]
            ]]]
     ba [byte-array total-size]]
    [loop [i 0 offset 0]
      [if [le-s n-datas i]
        ba
        [match [at datas i]
          [data/bytes bs]
          [do
            [for j 0 [size bs]
              [byte-array-set ba [add offset j] [word-to-int [syntax-word/word [at bs j]]]]]
            [continue
              i [inc i]
              offset [add offset [size bs]]]]

          [data/i32 is]
          [do
            [loop [j 0 sis [size is]]
              [when [lt-s j sis]
                [byte-array-set-byte-array ba [add offset [mul j 4]]
                  [i32-to-byte-array [word-to-int [syntax-word/word [at is j]]]]]
                [continue j [inc j]]]]
            [continue
              i [inc i]
              offset [add offset [mul [size is] 4]]]]

          [data/f64 fs]
          [do
            [loop [j 0 sfs [size fs]]
              [when [lt-s j sfs]
                [byte-array-set-byte-array ba [add offset [mul j 8]]
                  [f64-to-byte-array [word-to-f64 [syntax-word/word [at fs j]]]]]
                [continue j [inc j]]]]
            [continue
              i [inc i]
              offset [add offset [mul [size fs] 8]]]]]]]
      ba]]

[type output-func []
  [record
    [name word]
    [parameters [list [pair word word]]]
    [locals [list [pair word word]]]
    [result [list word]]
    [body wat-inst]]]

[type import-kind []
  [union
    [memory word i32]]]

[type export-kind []
  [union [func] [global] [memory]]]

[type wat-global []
  [record
    [name word]
    [type word]
    [value wat-inst]]]

[type wat-data []
  [union
    [active word wat-inst byte-array]]]

[type wat-memory []
  [record
    [kind memory-kind]
    [name word]
    [initial i32]
    [maximum [option i32]]]]

[type wat-output []
  [record
    [imports [growable-list [pair [list word] import-kind]]]
    [memories [growable-list wat-memory]]
    [globals [growable-list wat-global]]
    [funcs [growable-list output-func]]
    [exports [growable-list [pair word [pair export-kind word]]]]
    [datas [growable-list wat-data]]]]

[defn make-wat-output []
  [wat-output
    [growable-list]
    [growable-list]
    [growable-list]
    [growable-list]
    [growable-list]
    [growable-list]]]

[type translate-context []
  [record
    [output wat-output]
    [check-context llcheck-context]
    [function-name-to-typearg-specializations [transient-kv-map word [set word]]]
    [function-name-to-body [transient-kv-map word lldefn]]
    [specialized-names-generated [set word]]
    [func-specs-to-generate [atom [growable-list [pair word [list ctype]]]]]
    ]]

[defn translate-context-empty [llcheck-context]
  [translate-context
    [make-wat-output]
    llcheck-context
    [transient-kv-map]
    [transient-kv-map]
    [set]
    [atom [growable-list]]]]

[defn llctx-from-translate [tctx]
  [llcheck-context/bind-ctx
     [translate-context/check-context tctx]]]

[defn translate-type [tctx it]
  [match [normalize-type it]
    [ctype/literal l] [word i32]

    [ctype/apply type-name type-args]
    [switch type-name
      [[word pointer]]
      [match [get-memory-kind [llctx-from-translate tctx] [mem-name-from-mem-type [first type-args]]]
        [memory-kind/i32] [word i32]
        [memory-kind/i64] [word i64]]

      [if [or [wat-type-is type-name] [wuns-builtin-data-type-is type-name]]
        type-name
        [do [log it] [logq-abort not implemented translate-type [identity it]]]]]
    [do [log it] [logq-abort not implemented translate-type [identity it]]]]]

[defn translate-types [tctx it]
  [let [nt [normalize-type it]]
    [match [normalize-type it]
      [ctype/apply type-name type-args]
      [switch type-name
        [[word tuple]]
        [do
          [when-not [is-empty type-args]
            [logq translate-types tuple [identity type-args]]]
          [list-map ta type-args [translate-type tctx ta]]]

        [list [translate-type tctx nt]]]
        [do [log it] [logq-abort not implemented translate-types]]]]]

[defn specialized-name-from [tctx fname type-args]
  [loop
    [w fname
     i 0
     s [size type-args]
     t2n
      [func t2n [t]
        [match [normalize-type t]
          [ctype/var tv]
          [match [get-type-var-kind tv]
            [type-var-kind/unlinked id]
            [match id
              [type-var-id/number i] [int-to-type-var-name i]
              [type-var-id/word w] w]
            [type-var-kind/linked lt] [logq-abort ctype-to-name unreachable type should be normalized]]

          [ctype/literal l]
          [word literal]

          [ctype/apply type-name type-args]
          [switch type-name
            [[word pointer]]
            [match [get-memory-kind [llctx-from-translate tctx] [mem-name-from-mem-type [first type-args]]]
              [memory-kind/i32] [word i32]
              [memory-kind/i64] [word i64]]
            [if [or [wat-type-is type-name] [wuns-builtin-data-type-is type-name]]
              type-name
              [word-join
                [word -]
                [list-map ta type-args [t2n ta]]]]]

            [do [logq-abort not implemented ctype-to-name]]]]]
    [if [lt-s i s]
      [let
        [tn [t2n [at type-args i]]]
        [continue
          w [concat-words [concat-words w [word -]] tn]
          i [inc i]]]
      w]]]

[defn add-func-specialization [tctx sname]
  [let [type-args [get [llcheck-context/type-instantiations [translate-context/check-context tctx]] sname]
        fname-word [syntax-word/word sname]
        gl [atom-get [translate-context/func-specs-to-generate tctx]]
        spec-name [specialized-name-from tctx fname-word type-args]]
    [when-not [set-has [translate-context/specialized-names-generated tctx] spec-name]
      [push gl [pair fname-word type-args]]]
    spec-name]]

[defn literal-to-wat-inst [l]
  [match l
    [llliteral/i32 i] [wat-inst/i32.const [syntax-word/word i]]
    [llliteral/i64 i] [wat-inst/i64.const [syntax-word/word i]]
    [llliteral/f32 f] [wat-inst/f32.const [syntax-word/word f]]
    [llliteral/f64 f] [wat-inst/f64.const [syntax-word/word f]]]]

[defn exp-const-to-wat-inst [value]
  [match value
    [llexp/cast t e]
    [exp-const-to-wat-inst e]

    [llexp/literal l]
    [literal-to-wat-inst l]

    [logq-abort exp-const-to-wat-inst]]]

[def i32.const-0 [wat-inst/i32.const [word 0]]]
[def i32.const-1 [wat-inst/i32.const [word 1]]]
[def i32.const-2 [wat-inst/i32.const [word 2]]]
[def i32.const-4 [wat-inst/i32.const [word 4]]]
[def i32.const-8 [wat-inst/i32.const [word 8]]]
[def i32.const-16 [wat-inst/i32.const [word 16]]]

[defn translate-func [tctx func type-args]
  [let
    [cctx [translate-context/check-context tctx]
     bind-ctx [llcheck-context/bind-ctx cctx]
     form-to-ldesc [llctx/form-to-ldesc bind-ctx]
     lvar-to-name
       [func lvar-to-name [lvar-sname]
         [if-let [ldesc [try-get form-to-ldesc [syntax-word-get-form lvar-sname]]]
           [syntax-word/word lvar-sname]
           [logq-abort lvar-to-name expected local var [identity lvar-sname]]]]
     get-form-types [func get-form-types [form] [translate-types tctx [get-ctype cctx form]]]
     glocals [growable-list]
     add-binding
     [func ab [b]
       [push glocals
         [pair
           [syntax-word/word [pair/fst b]]
           [translate-type tctx [get-ctype cctx [pair/snd b]]]]]]
     fname-word [syntax-word/word [lldefn/name func]]
     ts [get [llcheck-context/def-var-types [translate-context/check-context tctx]] fname-word]
     special-func-name [specialized-name-from tctx fname-word type-args]
     type-env [transient-kv-map]]
  [if-let [fn-tps [lldefn/type-params func]]
    [let [type-params [check-type-scheme/named-type-params ts]]
      [for i 0 [size type-params]
        [set-kv-map type-env [at type-params i] [at type-args i]]]]
    [let [type-params [check-type-scheme/type-vars ts]]
      [for i 0 [size type-params]
        [match [get-type-var-kind [at type-params i]]
          [type-var-kind/unlinked id]
          [set-kv-map type-env [type-var-id-to-word id] [at type-args i]]]]]]

  [letfn [
  [func type-to-size-of-exp [type-env it]
    [match [normalize-type it]
      [ctype/var tv]
      [match [get-type-var-kind tv]
        [type-var-kind/unlinked tv-id]
        [match tv-id
          [type-var-id/word tvw]
          [if-let [subst-type [try-get type-env tvw]]
            [type-to-size-of-exp type-env subst-type]
            [logq-abort size-of type var not found [identity tvw] [identity type-env]]]

          [logq-abort tts]]
        [logq-abort tts]]

      [ctype/literal l]
      i32.const-4

      [ctype/apply type-name type-args]
      [switch type-name
        [[word u8] [word s8]] i32.const-1
        [[word u16] [word s16]] i32.const-2
        [[word i32] [word f32]] i32.const-4
        [[word i64] [word f64]] i32.const-8
        [[word v128]] i32.const-16
        [[word tuple]] [logq-abort size-of tuple not implemented]

        [[word pointer]]
        [match [get-memory-kind [llctx-from-translate tctx] [mem-name-from-mem-type [first type-args]]]
          [memory-kind/i32]
          i32.const-4
          [memory-kind/i64]
          i32.const-8]

        [[word array]]
        [let [size-exp
          [match [at type-args 1]
            [ctype/literal l]
            [match l
              [type-literal/exp e]
              [go e]

              [type-literal/memory m]
              [logq-abort size-of not implemented memory literal]]

            [ctype/var tv]
            [match [get-type-var-kind tv]
              [type-var-kind/unlinked tv-id]
              [match tv-id
                [type-var-id/word tvw]
                [if-let [subst-type [try-get type-env tvw]]
                  [match subst-type
                    [ctype/literal l]
                    [match l
                      [type-literal/exp e]
                      [go e]

                      [type-literal/memory m]
                      [logq-abort size-of not implemented memory literal]]

                    [logq-abort size-of not a tv [identity subst-type]]]
                  [logq-abort size-of type var not found [identity tvw] [identity type-env]]]

                [logq-abort tts]]
              [logq-abort tts]]

            [logq-abort size-of array not implemented [at type-args 1]]]]
          [wat-inst-i32.mul
            [type-to-size-of-exp type-env [at type-args 0]]
            size-exp]]

        [let
          [new-tv-env [make-type-env bind-ctx type-name type-args]]
          [match [get [llctx/user-types bind-ctx] type-name]
            [user-type-desc/alias at]
            [logq-abort size-of alias not implemented]

            [user-type-desc/record field-map field-list]
            [loop [cur-size i32.const-0 i 0 n [size field-list]]
              [if [lt-s i n]
                [let [fd [at field-list i]]
                  [continue
                    cur-size
                      [wat-inst-i32.add cur-size
                        [type-to-size-of-exp new-tv-env [instantiate-syntax-type-no-env cctx 0 [pair/snd fd]]]]
                    i [inc i]]]
                cur-size]]
            [logq-abort size-of not a record type]]]]]]
  [func type-to-size-exp1 [t]
    [let [nt [normalize-type t]]
      [logq type-to-size-exp1 [identity nt]]
      [type-to-size-of-exp type-env nt]]]
  [func go-forms [forms]
    [if [is-empty forms]
      [list]
      [concat
        [list-map form [slice forms 0 [dec [size forms]]]
          [loop [res [go form] i [size [get-form-types form]]]
              [if i
                [continue
                  res [wat-inst-drop res]
                  i [dec i]]
                res]]]
        [list [go [last forms]]]]]]
  [func go [form]
    [match form
      [llexp/var sw]
      [let [w [syntax-word/word sw]]
        [if-let [ldesc [try-get form-to-ldesc [syntax-word-get-form sw]]]
          [wat-inst/local.get w]
          [wat-inst/global.get w]]]

      [llexp/literal l]
      [literal-to-wat-inst l]

      [llexp/do forms]
      [wat-inst/instructions [go-forms forms]]

      [llexp/if cond true false]
      [wat-inst/if
        [get-form-types form]
        [go cond]
        [go true]
        [go false]]

      [llexp/intrinsic inst-name imm-args args]
      [wat-inst/inst
        [wasm-name-to-wat-byte-array [syntax-word/word inst-name]]
        [list-map arg args [go arg]]]

      [llexp/call w opt-type-args args]
      [wat-inst/call [add-func-specialization tctx w] [list-map a args [go a]]]

      [llexp/let bindings body]
      [wat-inst/instructions
        [concat
          [list-map b bindings
            [do
              [add-binding b]
              [wat-inst/local.set [lvar-to-name [pair/fst b]] [go [pair/snd b]]]]]
          [go-forms body]]]

      [llexp/loop bindings body]
      [wat-inst/instructions
        [concat
          [list-map b bindings
            [do
              [add-binding b]
              [wat-inst/local.set [lvar-to-name [pair/fst b]] [go [pair/snd b]]]]]
          [list
            [wat-inst/loop
              [word loop-label]
              [get-form-types form]
              [wat-inst/instructions
                [go-forms body]]]]]]

      [llexp/continue assignments]
      [wat-inst/instructions
        [concat
          [list-map a assignments
            [wat-inst/local.set [lvar-to-name [pair/fst a]] [go [pair/snd a]]]]
          [list [wat-inst/br [word loop-label]]]]]

      [llexp/cast cast-type value]
      [go value]

      [llexp/deref target]
      [let
        [pt [get-apply-type [get-ctype cctx target] [word deref]]
         it [copy-type-proper type-env [second [pair/snd pt]]]]
        [assert [eq-word [pair/fst pt] [word pointer]]]
        [wat-inst/load
          [wasm-name-to-wat-byte-array
            [switch [translate-type tctx it]
            [[word i32]] [word i32.load]
            [[word i64]] [word i64.load]
            [[word f32]] [word f32.load]
            [[word f64]] [word f64.load]
            [[word v128]] [word v128.load]
            [[word u8]] [word i32.load8-u]
            [[word s8]] [word i32.load8-s]
            [[word u16]] [word i32.load16-u]
            [[word s16]] [word i32.load16-s]
            [logq-abort not implemented deref inst-type/apply]]]
          [wat-inst-memargs
            [mem-name-from-mem-type [first [pair/snd pt]]]
            [word 0]
            [word 1]]
          [go target]]]

      [llexp/assign target value]
      [let
        [pt [get-apply-type [get-ctype cctx target] [word assign]]
         it [copy-type-proper type-env [second [pair/snd pt]]]]
        [assert [eq-word [pair/fst pt] [word pointer]]]
        [wat-inst/store
          [wasm-name-to-wat-byte-array
            [switch [translate-type tctx it]
            [[word i32]] [word i32.store]
            [[word i64]] [word i64.store]
            [[word f32]] [word f32.store]
            [[word f64]] [word f64.store]
            [[word v128]] [word v128.store]
            [[word u8] [word s8]] [word i32.store8]
            [[word u16] [word s16]] [word i32.store16]
            [logq-abort not implemented assign inst-type/apply]]]
          [wat-inst-memargs
            [mem-name-from-mem-type [first [pair/snd pt]]]
            [word 0]
            [word 1]]
          [go target]
          [go value]]]

      [llexp/field target field-name]
      [let
        [pt [get-apply-type [get-ctype cctx target] [word field]]
         field-name-word [syntax-word/word field-name]]
        [assert [eq-word [pair/fst pt] [word pointer]]]
        [let [ptargs [pair/snd pt]
              tmem [first ptargs]
              ttarget [get-apply-type [second ptargs] [word field1]]
              ttarget-name [pair/fst ttarget]
              ttarget-args [pair/snd ttarget]
              bctx [llctx-from-translate tctx]
              offset
              [if-let [dd [try-get [llctx/user-types bctx] ttarget-name]]
                [match dd
                  [user-type-desc/record field-map field-list]
                  [let
                    [target-type-params [get [llctx/user-type-params bctx] ttarget-name]
                     new-tv-env [transient-kv-map]]
                    [for i 0 [size ttarget-args]
                      [set-kv-map new-tv-env [syntax-word/word [at target-type-params i]] [at ttarget-args i]]]
                    [loop [i 0 offset i32.const-0]
                      [if [lt-s i [size field-list]]
                        [let [fp [at field-list i]]
                          [if [eq-word field-name-word [pair/fst fp]]
                            offset
                            [continue
                              i [inc i]
                              offset [wat-inst-i32.add
                                      offset
                                      [type-to-size-of-exp new-tv-env [instantiate-syntax-type-no-env cctx 0 [pair/snd fp]]]]]]]
                        [logq-abort field not found]]]]
                  [logq-abort not a record type]]
                [logq-abort not implemented translate-top-form field inst-type/apply]]]
        [wat-inst-i32.add offset [go target]]]]

      [llexp/index target index]
      [let
        [pt [get-apply-type [get-ctype cctx target] [word index]]]
        [assert [eq-word [pair/fst pt] [word pointer]]]
        [let [ptargs [pair/snd pt]
              array-type [second ptargs]
              element-type [first [pair/snd [get-apply-type array-type [word index1]]]]
              offset [wat-inst-i32.mul [type-to-size-exp1 element-type] [go index]]]
        [wat-inst-i32.add offset [go target]]]]

      [llexp/size-of t]
      [type-to-size-exp1 [get-annotation cctx t]]

      [do
        [log form]
        [logq-abort not implemented translate-form]]]]]
    [comment go-forms has the side effect of adding locals so we need to run it first]
    [logq type-env [identity type-env]]
    [let
      [t [copy-type-proper type-env [check-type-scheme/type ts]]
       ft [get-func-type t]
       param-types [pair/fst ft]
       gparams [growable-list]
       params [lldefn/params func]]
      [assert [eq [size params] [size param-types]] expected matching number of parameters and types]
      [set-add [translate-context/specialized-names-generated tctx] special-func-name]
      [let [tbodies [go-forms [lldefn/bodies func]]]
        [for i 0 [size params]
          [push gparams
            [pair [syntax-word/word [pair/fst [at params i]]] [translate-type tctx [lift-data-type [at param-types i]]]]]]
        [push
          [wat-output/funcs [translate-context/output tctx]]
          [output-func
            special-func-name
            [clone-growable-to-frozen-list gparams]
            [clone-growable-to-frozen-list glocals]
            [translate-types tctx [lift-data-type [pair/snd ft]]]
            [wat-inst/instructions tbodies]]]]]]]]

[defn translate-top-form [tctx bform]
  [let
    [output [translate-context/output tctx]
     cctx [translate-context/check-context tctx]]
    [match bform
      [lltop/memory name kind init-size opt-max]
      [push [wat-output/memories output]
        [wat-memory
          kind
          [syntax-word/word name]
          [word-to-int [syntax-word/word init-size]]
          [if-let [max opt-max]
            [option/some [word-to-int [syntax-word/word max]]]
            [option/none]]]]

      [lltop/def name value]
      [push [wat-output/globals output]
        [wat-global
          [syntax-word/word name]
          [translate-type tctx [get-ctype cctx value]]
          [exp-const-to-wat-inst value]]]

      [lltop/defn func]
      [set-kv-map [translate-context/function-name-to-body tctx]
        [syntax-word/word [lldefn/name func]] func]

      [lltop/export snames]
      [for-each sname snames
        [push
          [wat-output/exports output]
          [let [name [syntax-word/word sname]]
            [pair
              name
              [if-let [dd [try-get [llctx/lldef-ctx [llctx-from-translate tctx]] name]]
                [match dd
                  [lldef-desc/memory kind]
                  [pair [export-kind/memory] name]

                  [lldef-desc/func opt-tparams params]
                  [do
                    [if-let [tparams opt-tparams]
                      [logq-abort export genfn not implemented]
                      [do]]
                    [pair [export-kind/func] [add-func-specialization tctx sname]]]

                  [lldef-desc/any]
                  [pair [export-kind/global] name]]
                [logq-abort export not found]]]]]]

      [lltop/data-active mem-name offset-form datas]
      [do
        [push
          [wat-output/datas output]
          [wat-data/active
            [syntax-word/word mem-name]
            [exp-const-to-wat-inst offset-form]
            [datas-to-byte-array datas]]]]

      [lltop/type]
      [do]

      [logq-abort not implemented translate-top-form [identity bform]]]]]

[defn translate-top-forms-sync [evaluator forms]
  [let
    [f2l [make-forms-to-btops evaluator]
     btops-ctx-pair [f2l forms]
     ctx [pair/snd btops-ctx-pair]
     gctx [llcheck-context-empty ctx]
     tctx [translate-context-empty gctx]
     specs-atom [translate-context/func-specs-to-generate tctx]
     func-to-body [translate-context/function-name-to-body tctx]]
    [for-each btop [pair/fst btops-ctx-pair]
      [infer-lltop gctx btop]
      [translate-top-form tctx btop]]
    [loop [func-specializations [clone-growable-to-frozen-list [atom-get specs-atom]]]
      [when-not [is-empty func-specializations]
        [atom-set specs-atom [growable-list]]
        [for-each func-specialization func-specializations
          [let [fname [pair/fst func-specialization]
                type-args [list-map t [pair/snd func-specialization] [normalize-type t]]
                spec-name [specialized-name-from tctx fname type-args]]
            [when-not [set-has [translate-context/specialized-names-generated tctx] spec-name]
              [translate-func tctx [get func-to-body fname] type-args]]]]
        [continue func-specializations [clone-growable-to-frozen-list [atom-get specs-atom]]]]]
    tctx]]

[def ascii-line-feed [i32 10]]
[def ascii-space [i32 32]]
[def ascii-double-quote [i32 34]]
[def ascii-dollar [i32 36]]
[def ascii-left-paren [i32 40]]
[def ascii-right-paren [i32 41]]
[def ascii-equal [i32 61]]
[def ascii-backslash [i32 92]]

[type printer []
  [record
    [bytes [byte-array]]
    [index [atom i32]]]]

[defn empty-printer []
  [printer [byte-array-resizable [i32 256] [i32 0x10000000]] [atom 0]]]

[defn printer-to-byte-array [p]
  [let
    [ci [atom-get [printer/index p]]
     cb [printer/bytes p]
     trimmed [byte-array ci]]
    [for i 0 ci
      [byte-array-set trimmed i [byte-array-get cb i]]]
    trimmed]]

[defn print-byte [printer byte]
  [let [ia [printer/index printer]
        i [atom-get ia]
        a [printer/bytes printer]
        cur-size [byte-array-size a]]
    [when [le-s cur-size i]
      [byte-array-resize a [mul [i32 2] cur-size]]]
    [byte-array-set a i byte]
    [atom-set [printer/index printer] [inc i]]]]

[defn print-word [printer word]
  [for i 0 [word-byte-size word]
    [print-byte printer [char-code-at word i]]]]

[defn int-to-hex-ascii [i]
  [if [lt-s i [i32 10]]
    [add i [i32 48]]
    [add [sub i [i32 10]] [i32 97]]]]

[defn i32-to-hex-bits [n-bits value]
  [let [gl [growable-list]]
    [loop [n-start [sub n-bits 4]
           index [intrinsic i32.shl [i32 15] n-start]
           i n-start]
      [when index
        [push gl [int-to-hex-ascii [intrinsic i32.shr-u [intrinsic i32.and value index] i]]]
        [continue
          index [intrinsic i32.shr-u index [i32 4]]
          i [sub i 4]]]]
    [code-points-to-word [clone-growable-to-frozen-list gl]]]]

[defn i32-to-hex-8 [value]
  [i32-to-hex-bits [i32 8] value]]

[defn print-string-chars [printer word]
  [for i 0 [byte-array-size word]
    [let [cc [byte-array-get word i]]
      [if [or [lt-s cc [i32 32]] [lt-s [i32 126] cc]]
        [do
          [print-byte printer ascii-backslash]
          [print-word printer [i32-to-hex-8 cc]]]
        [print-byte printer cc]]]]]

[type wat []
  [union
    [word word]
    [byte-array byte-array]
    [dollar word]
    [dqstring word]
    [dqstring-bytes byte-array]
    [seq [list wat]]
    [seq-lf [list wat]]
    [list [list wat]]
    [eq-pair word word]]]

[defn print-wat [printer wat]
  [match wat
    [wat/word w] [print-word printer w]
    [wat/byte-array ba]
      [for i 0 [byte-array-size ba]
        [print-byte printer [byte-array-get ba i]]]
    [wat/dollar w] [do [print-byte printer ascii-dollar] [print-word printer w]]
    [wat/dqstring w] [do [print-byte printer ascii-double-quote] [print-word printer w] [print-byte printer ascii-double-quote]]
    [wat/dqstring-bytes ba] [do [print-byte printer ascii-double-quote] [print-string-chars printer ba] [print-byte printer ascii-double-quote]]
    [wat/seq l]
      [do
        [when-not [is-empty l]
          [print-wat printer [first l]]
          [for i 1 [size l]
            [print-byte printer ascii-space]
            [print-wat printer [at l i]]]]]
    [wat/seq-lf l]
      [do
        [when-not [is-empty l]
          [print-wat printer [first l]]
          [for i 1 [size l]
            [print-byte printer ascii-line-feed]
            [print-wat printer [at l i]]]]]
    [wat/list l]
      [do
        [print-byte printer ascii-left-paren]
        [when-not [is-empty l]
          [print-wat printer [first l]]
          [for i 1 [size l]
            [print-byte printer ascii-space]
            [print-wat printer [at l i]]]]
        [print-byte printer ascii-right-paren]]
    [wat/eq-pair w1 w2]
      [do
        [print-word printer w1]
        [print-byte printer ascii-equal]
        [print-word printer w2]]]]

[defn wat-to-wat-bytes [wat]
  [let [p [empty-printer]]
    [print-wat p wat]
    [printer-to-byte-array p]]]

[defn wat-list [.. l] [wat/list l]]

[defn wat-concat [.. l] [wat/list [concat-lists l]]]

[defn wat-inst-memargs-to-out [ma]
  [list
    [wat-list [wat/word [word memory]] [wat/dollar [wat-inst-memargs/memory ma]]]
    [wat/eq-pair [word offset] [wat-inst-memargs/offset ma]]
    [wat/eq-pair [word align] [wat-inst-memargs/alignment ma]]]]

[defn wat-inst-to-out [i]
  [match i
    [wat-inst/i32.const w]
    [wat-list [wat/word [word i32.const]] [wat/word w]]

    [wat-inst/i64.const w]
    [wat-list [wat/word [word i64.const]] [wat/word w]]

    [wat-inst/f32.const w]
    [wat-list [wat/word [word f32.const]] [wat/word w]]

    [wat-inst/f64.const w]
    [wat-list [wat/word [word f64.const]] [wat/word w]]

    [wat-inst/inst w args]
    [wat-concat
      [list [wat/byte-array w]] [list-map a args [wat-inst-to-out a]]]

    [wat-inst/local.get w]
    [wat-list [wat/word [word local.get]] [wat/dollar w]]

    [wat-inst/local.set w e]
    [wat-list [wat/word [word local.set]] [wat/dollar w] [wat-inst-to-out e]]

    [wat-inst/global.get w]
    [wat-list [wat/word [word global.get]] [wat/dollar w]]

    [wat-inst/load name ma addr]
    [wat-concat
      [list [wat/byte-array name]]
      [wat-inst-memargs-to-out ma]
      [list [wat-inst-to-out addr]]]

    [wat-inst/store name ma addr value]
    [wat-concat
      [list [wat/byte-array name]]
      [wat-inst-memargs-to-out ma]
      [list [wat-inst-to-out addr] [wat-inst-to-out value]]]

    [wat-inst/instructions insts]
    [wat/seq [list-map inst insts [wat-inst-to-out inst]]]

    [wat-inst/if result-types cond true false]
    [wat-list [wat/word [word if]]
      [wat/list
        [concat [list [wat/word [word result]]]
          [list-map rt result-types [wat/word rt]]]]
      [wat-inst-to-out cond]
      [wat-list [wat/word [word then]] [wat-inst-to-out true]]
      [wat-list [wat/word [word else]] [wat-inst-to-out false]]]

    [wat-inst/call w args]
    [wat-concat
      [list [wat/word [word call]] [wat/dollar w]]
      [list-map a args [wat-inst-to-out a]]]

    [wat-inst/loop loop-label result-types body]
    [wat-list
      [wat/word [word loop]]
      [wat/dollar loop-label]
      [wat/list
        [concat [list [wat/word [word result]]]
          [list-map rt result-types [wat/word rt]]]]
      [wat-inst-to-out body]]

    [wat-inst/br w]
    [wat-list [wat/word [word br]] [wat/dollar w]]

    [logq-abort wat-inst-to-out unknown instruction]]]

[defn import-to-wat [import]
  [match [pair/snd import]
    [import-kind/memory name init-size]
    [wat-list
      [wat/word [word memory]]
      [wat/dollar name]
      [wat/word [int-to-word init-size]]]]]

[defn memory-to-wat [mem]
  [wat-list
    [wat/word [word memory]]
    [wat/dollar [wat-memory/name mem]]
    [wat/word [match [wat-memory/kind mem]
      [memory-kind/i32] [word i32]
      [memory-kind/i64] [word i64]]]
    [wat/word [int-to-word [wat-memory/initial mem]]]]]

[defn global-to-wat [global]
  [wat-list
    [wat/word [word global]]
    [wat/dollar [wat-global/name global]]
    [wat/word [wat-global/type global]]
    [wat-inst-to-out [wat-global/value global]]]]

[defn output-func-to-wat [of]
  [wat-concat
    [list
      [wat/word [word func]]
      [wat/dollar [output-func/name of]]]
    [list-map p [output-func/parameters of]
      [wat-list [wat/word [word param]] [wat/dollar [pair/fst p]] [wat/word [pair/snd p]]]]
    [list
      [wat-concat
        [list [wat/word [word result]]]
        [list-map rt [output-func/result of] [wat/word rt]]]]
    [list-map l [output-func/locals of]
      [wat-list [wat/word [word local]] [wat/dollar [pair/fst l]] [wat/word [pair/snd l]]]]
    [list
      [wat-inst-to-out [output-func/body of]]]]]

[defn export-to-wat [p]
  [wat-concat
    [list
      [wat/word [word export]]
      [wat/dqstring [pair/fst p]]
      [let [kind-pair [pair/snd p]]
        [wat-list
          [wat/word
            [match [pair/fst kind-pair]
              [export-kind/func] [word func]
              [export-kind/memory] [word memory]
              [export-kind/global] [word global]
              [logq-abort export-to-wat unknown export kind]]]
          [wat/dollar [pair/snd kind-pair]]]]]]]

[defn data-to-wat [d]
  [match d
    [wat-data/active mem-name offset data]
    [wat-list
      [wat/word [word data]]
      [wat-list [wat/word [word memory]] [wat/dollar mem-name]]
      [wat-inst-to-out offset]
      [wat/dqstring-bytes data]]]]

[defn output-to-wat [output]
  [wat/seq-lf
    [concat-lists
      [list
        [list-map imp [clone-growable-to-frozen-list [wat-output/imports output]] [import-to-wat imp]]
        [list-map mem [clone-growable-to-frozen-list [wat-output/memories output]] [memory-to-wat mem]]
        [list-map g [clone-growable-to-frozen-list [wat-output/globals output]] [global-to-wat g]]
        [list-map d [clone-growable-to-frozen-list [wat-output/datas output]] [data-to-wat d]]
        [list-map of [clone-growable-to-frozen-list [wat-output/funcs output]] [output-func-to-wat of]]
        [list-map e [clone-growable-to-frozen-list [wat-output/exports output]] [export-to-wat e]]]]]]

[defmacro def-wasm-extern [name type]
  [flist [quote import] [quote ./runtime-lib/wasm.js] name type]]

[type wasm-module [] [union]]

[import ./runtime-lib/wabt.js wat-to-wasm-byte-array [func [byte-array] byte-array]]

[defn make-init-evaluator-async []
  [let [evaluator [make-evaluator]]
    [promise-then
      [evaluate-top-async evaluator [quote [load std.wuns]]]
      [func t [-] evaluator]]]]

[defn translate-top-forms-to-tctx [forms]
  [promise-then
    [make-init-evaluator-async]
    [func t [evaluator] [translate-top-forms-sync evaluator forms]]]]

[defn translate-top-forms-to-wasm-bytes [forms]
  [promise-then
    [translate-top-forms-to-tctx forms]
    [func t [tctx]
      [wat-to-wasm-byte-array [wat-to-wat-bytes [output-to-wat [translate-context/output tctx]]]]]]]

[def-wasm-extern byte-array-to-wasm-module [func [byte-array] wasm-module]]

[defn translate-top-forms-to-module [forms]
  [promise-then
    [translate-top-forms-to-wasm-bytes forms]
    byte-array-to-wasm-module]]

[comment
  we could do type predicates like
[defn form-word-is [[type f [pointer [memory mem] [form]]]]
  [cast
    [type-predicate f [form-word]]
    [eq [deref [field f tag]] [i32 0]]]]

[defn form-list-is [[type f [pointer [memory mem] [form]]]]
  [cast
    [type-predicate f [form-list]]
    [eq [deref [field f tag]] [i32 1]]]]

]

[comment


[type growable-vector [a]
  [record
    [size [i32]]
    [capacity [i32]]
    [parray [pointer [memory mem] [array a s]]]]]

[genfn growable-vector-make [a] [[type init-capacity [i32]]]
  [let
    [p [cast [pointer [memory mem] [growable-vector a]] [alloc-n [size-of [growable-vector a]]]]
     parray [cast [pointer [memory mem] [array a s]] [alloc-n [size-of [array a [literal init-capacity]]]]]]
    [assign [field p size] [i32 0]]
    [assign [field p capacity] init-capacity]
    [assign [field p parray] parray]
    p]]

[defn growable-vector-push [[type pgvec [pointer [memory mem] [growable-vector a]]] [type elem a]]
  [let
    [cur-size [deref [field pgvec size]]
     cur-capacity [deref [field pgvec capacity]]
     parray [deref [field pgvec parray]]]
    [when [eq cur-size cur-capacity]
      [intrinsic unreachable]]
    [assign [index parray cur-size] elem]
    [assign [field pgvec size] [inc cur-size]]]]

[defn growable-vector-to-vector [[type pgvec [pointer [memory mem] [growable-vector a]]]]
  [let
    [size [deref [field pgvec size]]
     arr [deref [field pgvec parray]]
     pvector [call vector-make-no-init [a] [size]]]
    [for i [i32 0] size
      [call set [a] [pvector i [deref [index arr i]]]]]
    pvector]]

[defn growable-vector-make-int [init-capacity]
  [cast [pointer [memory mem] [growable-vector [i32]]] [call growable-vector-make [[i32]] [init-capacity]]]]

[defn growable-vector-push-int [[type pgvec [pointer [memory mem] [growable-vector [i32]]]] elem]
  [growable-vector-push pgvec elem]]

[defn growable-vector-to-vector-int [[type pgvec [pointer [memory mem] [growable-vector [i32]]]]]
  [growable-vector-to-vector pgvec]]

[export growable-vector-make-int growable-vector-push-int growable-vector-to-vector-int]

[defn is-between-inclusive [lower c upper]
  [and [le-s lower c] [le-s c upper]]]

[defn is-whitespace [c]
  [or [eq c [i32 32]] [eq c [i32 10]]]]

[defn is-word-char [c]
  [or
    [is-between-inclusive [i32 97] c [i32 122]]
    [is-between-inclusive [i32 45] c [i32 57]]]]


[type form-word []
  [record
    [tag [literal [i32 0]]]
    [word [pvector [u8]]]]]

[type
  form-list []
  [record
    [tag [literal [i32 1]]]
    [forms [pvector [pointer [memory mem] [form]]]]]

  form []
  [union
    [form-word]
    [form-list]]]

[defn form-word-make [byte-vector]
  [let [p [cast [pointer [memory mem] [form-word]] [alloc-n [size-of [form-word]]]]]
    [assign [field p tag] [i32 0]]
    [assign [field p word] byte-vector]
    p]]

[defn make-stack []
  [call growable-vector-make [[form-word]] [[i32 16]]]]

[genfn vector-slice [s] [[type pvec [pvector [u8]]] start end]
  [let
    [sz [sub end start]
     p [call vector-make-no-init [[u8]] [sz]]]
    [for i [i32 0] sz
      [set-byte p i [get-byte pvec [add start i]]]]
    p]]

[defn dvector-slice [pvec start end]
  [call vector-slice [[u8]] [pvec start end]]]

[defn parse [[type bytes [pointer [memory mem] [pvector [u8]]]]]
  [loop
    [n-of-bytes [size bytes]
     i [i32 0]
     start [i32 -1]]
    [if [lt-s i n-of-bytes]
      [let [c [get-byte bytes i]]
        [ifs
          [is-whitespace c]
          [if [lt-s start [i32 0]]
            [continue i [inc i]]
            [form-word-make [dvector-slice bytes start i]]]

          [is-word-char c]
          [if [lt-s start [i32 0]]
            [continue
              start i
              i [inc i]]
            [continue
              i [inc i]]]

          [eq c [i32 91]]
          [intrinsic unreachable]

          [eq c [i32 93]]
          [intrinsic unreachable]

          [intrinsic unreachable]]]
      [if [lt-s start [i32 0]]
        [cast [pointer [memory mem] [form-word]] [i32 0]]
        [form-word-make [dvector-slice bytes start i]]]]]]

[memory i32 mem 1]
[genfn g [t] [] [size-of [pointer [memory mem] t]]]
[defn f [] [call g [[i32]] []]]

 ]