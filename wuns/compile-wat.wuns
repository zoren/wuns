[load check2.wuns]

[type wat-type-basic []
  [union
    [i32]
    [i64]
    [f32]
    [f64]]]

[type wat-inst-memargs []
  [record
    [memory word]
    [offset word]
    [alignment word]]]

[type wat-inst []
  [union
    [i32.const word]
    [f64.const word]
    [local.get word]
    [local.set word wat-inst]
    [global.get word]
    [inst byte-array [list wat-inst]]
    [load byte-array wat-inst-memargs wat-inst]
    [store byte-array wat-inst-memargs wat-inst wat-inst]
    [if [list wat-type-basic] wat-inst wat-inst wat-inst]
    [call word [list wat-inst]]
    [instructions [list wat-inst]]
    [loop word [list wat-type-basic] wat-inst]
    [br word]]]

[type output-func []
  [record
    [name word]
    [parameters [list [pair word wat-type-basic]]]
    [locals [list [pair word wat-type-basic]]]
    [result [list wat-type-basic]]
    [body wat-inst]]]

[type import-kind []
  [union
    [memory word i32]]]

[type export-kind []
  [union [func] [global] [memory]]]

[type wat-global []
  [record
    [name word]
    [type wat-type-basic]
    [value wat-inst]]]

[type wat-output []
  [record
    [imports [growable-list [pair [list word] import-kind]]]
    [globals [growable-list wat-global]]
    [funcs [growable-list output-func]]
    [exports [growable-list [pair word [pair export-kind word]]]]]]

[defn make-wat-output []
  [wat-output
    [growable-list]
    [growable-list]
    [growable-list]
    [growable-list]]]

[type translate-context []
  [record
    [output wat-output]
    [check-context check-context]]]

[defn translate-type [it]
  [match [normalize-type it]
    [ctype/inst inst-type]
    [match inst-type
      [inst-type/apply type-name type-args]
      [switch type-name
        [[word i32]] [wat-type-basic/i32]
        [[word f64]] [wat-type-basic/f64]
        [do [log it] [logq-abort not implemented translate-type inst-type/apply]]]

      [do [log it] [logq-abort not implemented translate-type inst-type/apply]]]
    [do [log it] [logq-abort not implemented translate-type inst-type/apply]]]]

[defn translate-types [it]
  [match [normalize-type it]
    [ctype/inst inst-type]
    [match inst-type
      [inst-type/apply type-name type-args]
      [switch type-name
        [[word i32]] [list [wat-type-basic/i32]]
        [[word f64]] [list [wat-type-basic/f64]]
        [[word tuple]] [list-map ta type-args [translate-type ta]]

        [do [log it] [logq-abort not implemented translate-types inst-type/apply]]]
      [do [log it] [logq-abort not implemented translate-types inst-type/apply]]]
    [do [log it] [logq-abort not implemented translate-types inst-type/apply]]]]

[defn get-annotation [tctx bst]
  [if-let [anno [try-get [check-context/type-annotations [translate-context/check-context tctx]] [to-js-value bst]]]
    anno
    [do
      [log bst]
      [logq-abort get-annotation expected an annotation]]]]

[def ascii-underscore [i32 95]]

[comment wuns does not have underscores so we convert dashes to underscores]
[defn wasm-name-to-wat-bytes [w]
  [let [sw [word-byte-size w]
        res [growable-list]]
    [for i 0 sw
      [push res
        [let [c [char-code-at w i]] [if [eq c [word-to-char-code -]] ascii-underscore c]]]]
    [clone-growable-to-frozen-list res]]]

[defn wasm-name-to-wat-byte-array [w]
  [let [sw [word-byte-size w]
        res [byte-array sw]]
    [for i 0 sw
      [byte-array-set res i
        [let [c [char-code-at w i]] [if [eq c [word-to-char-code -]] ascii-underscore c]]]]
    res]]

[def drop-name-byte-array [wasm-name-to-wat-byte-array [word drop]]]

[defn wat-inst-drop [i]
  [wat-inst/inst drop-name-byte-array [list i]]]

[defn get-func-type [t]
  [match [normalize-type t]
    [ctype/inst inst-type]
    [match inst-type
      [inst-type/func func-type]
      func-type

      [logq-abort get-func-type expected a func type]]

    [logq-abort get-func-type expected a func type]]]

[defn syntax-word-get-form [sw]
  [if-let [f [syntax-word/opt-form sw]]
    f
    [logq-abort syntax-word-get-form expected a form]]]

[defn translate-top-form [tctx bform]
  [let [output [translate-context/output tctx]
        cctx [translate-context/check-context tctx]
        type-annos [check-context/type-annotations cctx]
        get-ctype [make-get-ctype-from-form-or-annotation type-annos]
        sinfo [check-context/syntax-info cctx]
        get-form-types [func get-form-types [form] [translate-types [get-ctype form]]]
        try-get-ldesc [syntax-info/try-get-ldesc sinfo]
        ldesc-to-index [transient-kv-map]
        lvar-to-name
          [func lvar-to-name [lvar-sname]
            [if-let [ldesc [try-get-ldesc [syntax-word-get-form lvar-sname]]]
              [let [w [syntax-word/word lvar-sname]]
                [if-let [index [try-get ldesc-to-index ldesc]]
                  [concat-words w [int-to-word index]]
                  w]]
              [logq-abort lvar-to-name expected local var]]]]
  [letfn
    [
  [func go-forms [forms]
    [if [is-empty forms]
      [list]
      [concat
        [list-map form [slice forms 0 [dec [size forms]]]
          [loop [res [go form] i [size [get-form-types form]]]
              [if i
                [continue
                  res [wat-inst-drop res]
                  i [dec i]]
                res]]]
        [list [go [last forms]]]]]]
  [func go [form]
    [match form
      [bexp/var sw]
      [let [w [syntax-word/word sw]]
        [if-let [ldesc [try-get-ldesc [syntax-word-get-form sw]]]
          [do
            [if-let [index [try-get ldesc-to-index ldesc]]
              [wat-inst/local.get [concat-words w [int-to-word index]]]
              [wat-inst/local.get w]]]
          [wat-inst/global.get w]]]

      [bexp/literal l]
      [match l
        [literal/i32 i] [wat-inst/i32.const [syntax-word/word i]]
        [literal/f64 f] [wat-inst/f64.const [syntax-word/word f]]
        [literal/word w] [logq-abort not implemented translate-form literal/word]]

      [bexp/do forms]
      [wat-inst/instructions [go-forms forms]]

      [bexp/if cond true false]
      [wat-inst/if
        [get-form-types form]
        [go cond]
        [go true]
        [go false]]

      [bexp/intrinsic inst-name ic]
      [match ic
        [intrinsic-args/bin a b]
        [wat-inst/inst [wasm-name-to-wat-byte-array [syntax-word/word inst-name]] [list [go a] [go b]]]

        [intrinsic-args/load memargs addr]
        [wat-inst/load [wasm-name-to-wat-byte-array [syntax-word/word inst-name]]
          [wat-inst-memargs
            [syntax-word/word [intrinsic-memargs/memory memargs]]
            [syntax-word/word [intrinsic-memargs/offset memargs]]
            [syntax-word/word [intrinsic-memargs/align memargs]]]
          [go addr]]

        [intrinsic-args/store memargs addr value]
        [wat-inst/store [wasm-name-to-wat-byte-array [syntax-word/word inst-name]]
          [wat-inst-memargs
            [syntax-word/word [intrinsic-memargs/memory memargs]]
            [syntax-word/word [intrinsic-memargs/offset memargs]]
            [syntax-word/word [intrinsic-memargs/align memargs]]]
          [go addr]
          [go value]]

        [intrinsic-args/none]
        [wat-inst/inst [wasm-name-to-wat-byte-array [syntax-word/word inst-name]] [list]]

        [logq-abort translate-form intrinsic not implemented]]

      [bexp/call f args]
      [match f
        [bexp/var w]
        [wat-inst/call [syntax-word/word w] [list-map a args [go a]]]

        [logq-abort translate-form call not implemented]]

      [bexp/let bindings body]
      [wat-inst/instructions
        [concat
          [list-map b bindings
            [wat-inst/local.set [lvar-to-name [pair/fst b]] [go [pair/snd b]]]]
          [go-forms body]]]

      [bexp/loop bindings body]
      [wat-inst/instructions
        [concat
          [list-map b bindings
            [wat-inst/local.set [lvar-to-name [pair/fst b]] [go [pair/snd b]]]]
          [list
            [wat-inst/loop
              [word loop-label]
              [get-form-types form]
              [wat-inst/instructions
                [go-forms body]]]]]]

      [bexp/continue assignments]
      [wat-inst/instructions
        [concat
          [list-map a assignments
            [wat-inst/local.set [lvar-to-name [pair/fst a]] [go [pair/snd a]]]]
          [list [wat-inst/br [word loop-label]]]]]

      [do
        [log form]
        [logq-abort not implemented translate-form]]]]]
  [match bform
    [btop/memory name init-size opt-max]
    [push [wat-output/imports output]
      [pair [list [syntax-word/word name]]
        [import-kind/memory [syntax-word/word name] [word-to-int [syntax-word/word init-size]]]]]

    [btop/def name value]
    [match value
      [bexp/literal l]
      [let
        [t
         [match l
          [literal/i32 i] [wat-type-basic/i32]
          [literal/f64 f] [wat-type-basic/f64]
          [logq-abort translate-top-form not implemented def literal]]]
        [push [wat-output/globals output]
          [wat-global
            [syntax-word/word name]
            t
            [go value]]]]

      [do
        [log bform]
        [logq-abort translate-top-form def kind not implemented]]]

    [btop/defunc kind f]
    [let [t [get [check-context/type-annotations [translate-context/check-context tctx]] [to-js-value f]]
          ft [get-func-type t]
          param-types [func-type/params ft]
          params [bfunc/parameters f]
          bodies [bfunc/body f]
          gparams [growable-list]
          glocals [growable-list]
          local-names [transient-kv-map]]
      [when-let [rest [bfunc/rest-param f]]
        [logq-abort translate-top-form rest param not implemented]]
      [assert [eq [size params] [size param-types]] expected matching number of parameters and types]
      [for i 0 [size params]
        [push gparams
          [pair [syntax-word/word [at params i]] [translate-type [at param-types i]]]]]
      [let
        [add-binding
          [func ab [b]
            [let [sname [pair/fst b]
                  name [syntax-word/word sname]
                  name-index
                  [if-let [ldesc [try-get-ldesc [syntax-word-get-form sname]]]
                    [let [index [kv-map-size ldesc-to-index]]
                      [set-kv-map ldesc-to-index ldesc index]
                      [concat-words name [int-to-word index]]]
                    [do
                      [log name]
                      [when-let [form [syntax-word/opt-form sname]]
                        [log-location form]
                        ]
                      [logq-abort translate-top-form expected a local description]]]]
              [push glocals [pair name-index [translate-type [get-ctype [pair/snd b]]]]]]]
         proc
          [bexp-recur
            [func f [bform]
              [match bform
                [bexp/let bs body]
                [for-each b bs [add-binding b]]

                [bexp/loop bs body]
                [for-each b bs [add-binding b]]

                [do]]
              true]]]
        [for-each b bodies [proc b]]]
      [push
        [wat-output/funcs output]
        [output-func
          [syntax-word/word [bfunc/name f]]
          [clone-growable-to-frozen-list gparams]
          [clone-growable-to-frozen-list glocals]
          [translate-types [func-type/result ft]]
          [wat-inst/instructions [go-forms bodies]]]]]

    [btop/export snames]
    [for-each sname snames
      [let [export-kind
            [if-let [dd [[syntax-info/try-get-def-desc sinfo] sname]]
              [match dd
                [def-desc/memory index]
                [export-kind/memory]

                [match [normalize-type [get-annotation tctx sname]]
                  [ctype/inst inst-type]
                  [match inst-type
                    [inst-type/func func-type]
                    [export-kind/func]

                    [export-kind/global]]]]
              [match [normalize-type [get-annotation tctx sname]]
                [ctype/inst inst-type]
                [match inst-type
                  [inst-type/func func-type]
                  [export-kind/func]

                  [export-kind/global]]]]]
        [push
          [wat-output/exports output]
          [pair [syntax-word/word sname] [pair export-kind [syntax-word/word sname]]]]]]

    [do
      [log bform]
      [logq-abort not implemented translate-top-form bform]]]]]]

[def ascii-line-feed [i32 10]]
[def ascii-space [i32 32]]
[def ascii-double-quote [i32 34]]
[def ascii-dollar [i32 36]]
[def ascii-left-paren [i32 40]]
[def ascii-right-paren [i32 41]]
[def ascii-equal [i32 61]]
[def ascii-backslash [i32 92]]

[type printer []
  [record
    [bytes [atom byte-array]]
    [index [atom i32]]]]

[defn empty-printer [init-capacity]
  [printer [atom [byte-array init-capacity]] [atom 0]]]

[defn printer-to-byte-array [p]
  [let
    [ci [atom-get [printer/index p]]
     cb [atom-get [printer/bytes p]]
     trimmed [byte-array ci]]
    [for i 0 ci
      [byte-array-set trimmed i [byte-array-get cb i]]]
    trimmed]]

[defn print-byte [printer byte]
  [let [ia [printer/index printer]
        i [atom-get ia]
        ba [printer/bytes printer]
        a [atom-get ba]]
    [assert [lt-s i [byte-array-size a]] printer buffer overflow]
    [byte-array-set a i byte]
    [atom-set [printer/index printer] [inc i]]]]

[defn print-word [printer word]
  [for i 0 [word-byte-size word]
    [print-byte printer [char-code-at word i]]]]

[type wat []
  [union
    [word word]
    [byte-array byte-array]
    [dollar word]
    [dqstring word]
    [seq [list wat]]
    [list [list wat]]
    [eq-pair word word]]]

[defn print-wat [printer wat]
  [match wat
    [wat/word w] [print-word printer w]
    [wat/byte-array ba]
      [for i 0 [byte-array-size ba]
        [print-byte printer [byte-array-get ba i]]]
    [wat/dollar w] [do [print-byte printer ascii-dollar] [print-word printer w]]
    [wat/dqstring w] [do [print-byte printer ascii-double-quote] [print-word printer w] [print-byte printer ascii-double-quote]]
    [wat/seq l]
      [do
        [when-not [is-empty l]
          [print-wat printer [first l]]
          [for i 1 [size l]
            [print-byte printer ascii-space]
            [print-wat printer [at l i]]]]]
    [wat/list l]
      [do
        [print-byte printer ascii-left-paren]
        [when-not [is-empty l]
          [print-wat printer [first l]]
          [for i 1 [size l]
            [print-byte printer ascii-space]
            [print-wat printer [at l i]]]]
        [print-byte printer ascii-right-paren]]
    [wat/eq-pair w1 w2]
      [do
        [print-word printer w1]
        [print-byte printer ascii-equal]
        [print-word printer w2]]]]

[defn wat-list [.. l] [wat/list l]]

[defn wat-type-basic-to-word [t]
  [match t
    [wat-type-basic/i32] [word i32]
    [wat-type-basic/f64] [word f64]]]

[defn wat-concat [.. l] [wat/list [concat-lists l]]]

[defn wat-inst-memargs-to-out [ma]
  [list
    [wat-list [wat/word [word memory]] [wat/dollar [wat-inst-memargs/memory ma]]]
    [wat/eq-pair [word offset] [wat-inst-memargs/offset ma]]
    [wat/eq-pair [word align] [wat-inst-memargs/alignment ma]]]]

[defn wat-inst-to-out [i]
  [match i
    [wat-inst/i32.const w]
    [wat-list [wat/word [word i32.const]] [wat/word w]]

    [wat-inst/f64.const w]
    [wat-list [wat/word [word f64.const]] [wat/word w]]

    [wat-inst/inst w args]
    [wat-concat
      [list [wat/byte-array w]] [list-map a args [wat-inst-to-out a]]]

    [wat-inst/local.get w]
    [wat-list [wat/word [word local.get]] [wat/dollar w]]

    [wat-inst/local.set w e]
    [wat-list [wat/word [word local.set]] [wat/dollar w] [wat-inst-to-out e]]

    [wat-inst/global.get w]
    [wat-list [wat/word [word global.get]] [wat/dollar w]]

    [wat-inst/load name ma addr]
    [wat-concat
      [list [wat/byte-array name]]
      [wat-inst-memargs-to-out ma]
      [list [wat-inst-to-out addr]]]

    [wat-inst/store name ma addr value]
    [wat-concat
      [list [wat/byte-array name]]
      [wat-inst-memargs-to-out ma]
      [list [wat-inst-to-out addr] [wat-inst-to-out value]]]

    [wat-inst/instructions insts]
    [wat/seq [list-map inst insts [wat-inst-to-out inst]]]

    [wat-inst/if result-types cond true false]
    [wat-list [wat/word [word if]]
      [wat/list
        [concat [list [wat/word [word result]]]
          [list-map rt result-types [wat/word [wat-type-basic-to-word rt]]]]]
      [wat-inst-to-out cond]
      [wat-list [wat/word [word then]] [wat-inst-to-out true]]
      [wat-list [wat/word [word else]] [wat-inst-to-out false]]]

    [wat-inst/call w args]
    [wat-concat
      [list [wat/word [word call]] [wat/dollar w]]
      [list-map a args [wat-inst-to-out a]]]

    [wat-inst/loop loop-label result-types body]
    [wat-list
      [wat/word [word loop]]
      [wat/dollar loop-label]
      [wat/list
        [concat [list [wat/word [word result]]]
          [list-map rt result-types [wat/word [wat-type-basic-to-word rt]]]]]
      [wat-inst-to-out body]]

    [wat-inst/br w]
    [wat-list [wat/word [word br]] [wat/dollar w]]

    [logq-abort wat-inst-to-out unknown instruction]]]

[defn import-to-wat [import]
  [match [pair/snd import]
    [import-kind/memory name init-size]
    [wat-list
      [wat/word [word memory]]
      [wat/dollar name]
      [wat/word [int-to-word init-size]]]]]

[defn global-to-wat [global]
  [wat-list
    [wat/word [word global]]
    [wat/dollar [wat-global/name global]]
    [wat/word [wat-type-basic-to-word [wat-global/type global]]]
    [wat-inst-to-out [wat-global/value global]]]]

[defn output-func-to-wat [of]
  [wat-concat
    [list
      [wat/word [word func]]
      [wat/dollar [output-func/name of]]]
    [list-map p [output-func/parameters of]
      [wat-list [wat/word [word param]] [wat/dollar [pair/fst p]] [wat/word [wat-type-basic-to-word [pair/snd p]]]]]
    [list
      [wat-concat
        [list [wat/word [word result]]]
        [list-map rt [output-func/result of] [wat/word [wat-type-basic-to-word rt]]]]]
    [list-map l [output-func/locals of]
      [wat-list [wat/word [word local]] [wat/dollar [pair/fst l]] [wat/word [wat-type-basic-to-word [pair/snd l]]]]]
    [list
      [wat-inst-to-out [output-func/body of]]]]]

[defn export-to-wat [p]
  [wat-concat
    [list
      [wat/word [word export]]
      [wat/dqstring [pair/fst p]]
      [let [kind-pair [pair/snd p]]
        [wat-list
          [wat/word
            [match [pair/fst kind-pair]
              [export-kind/func] [word func]
              [export-kind/memory] [word memory]
              [logq-abort export-to-wat unknown export kind]]]
          [wat/dollar [pair/snd kind-pair]]]]]]]

[defn output-to-wat [output]
  [wat/seq
    [concat-lists
      [list
        [list-map imp [clone-growable-to-frozen-list [wat-output/imports output]] [import-to-wat imp]]
        [list-map g [clone-growable-to-frozen-list [wat-output/globals output]] [global-to-wat g]]
        [list-map of [clone-growable-to-frozen-list [wat-output/funcs output]] [output-func-to-wat of]]
        [list-map e [clone-growable-to-frozen-list [wat-output/exports output]] [export-to-wat e]]]]]]

[defn int-to-hex-ascii [i]
  [if [lt-s i [i32 10]]
    [add i [i32 48]]
    [add [sub i [i32 10]] [i32 97]]]]

[defn i32-to-hex [value]
  [let [gl [growable-list]]
    [loop [index [intrinsic i32.shl [i32 15] [i32 28]]
           i [i32 28]]
      [when index
        [push gl [int-to-hex-ascii [intrinsic i32.shr-u [intrinsic i32.and value index] i]]]
        [continue
          index [intrinsic i32.shr-u index [i32 4]]
          i [sub i 4]]]]
    [code-points-to-word [clone-growable-to-frozen-list gl]]]]

[defn translate-top-forms-async [forms]
  [let
    [converter [mk-form-to-ast]
     sinfo [form-to-ast-converter/syntax-info converter]
     f2t [form-to-ast-converter/form-to-top-async converter]]
    [promise-then
      [promises-seq forms f2t]
      [func then [btops]
        [let
          [bind-errors [clone-growable-to-frozen-list [form-to-ast-converter/errors converter]]
           gctx [make-global-context-from-syntax-info sinfo]
           ctop [checker/check-top [make-checker gctx]]
           output [make-wat-output]
           tctx [translate-context output gctx]]
          [for-each btop btops
            [ctop btop]
            [let [check-errors [clone-growable-to-frozen-list [check-context/messages gctx]]]
              [when-not [is-empty check-errors]
                [for-each error check-errors [log-check-message error]]
                [logq-abort translate-top-forms-async binding errors]]]]
          [for-each btop [shake-tops sinfo btops]
            [translate-top-form tctx btop]]
          output]]]]]
