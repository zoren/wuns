[import env
  [mem [memory [i32] 1]]
  [log
    [func
      [par [pointer [exp mem] [array [u8]]]
       n-bytes [i32]]
      [tuple]]]
  [log-i32
    [func
      [n [i32]]
      [tuple]]]
  [log-i64
    [func
      [n [i64]]
      [tuple]]]
      ]

[comptimefn log-ar [sz [exp [i32]]] [byte-array [array [u8] sz]] [tuple]
  [log [data mem byte-array] [reify sz]]]

[comptimefn log-abort [sz [exp [i32]]] [byte-array [array [u8] sz]] [union]
  [log [data mem byte-array] [reify sz]]
  [intrinsic unreachable]]

[def 0 [i32 0]]
[def 1 [i32 1]]
[def 2 [i32 2]]
[def 3 [i32 3]]
[def 4 [i32 4]]
[def 8 [i32 8]]
[def 16 [i32 16]]

[datatype boolean [] [i32]]

[def false [i32 0]]
[def true [i32 1]]

[defn not [x [i32]] [i32] [if x 0 1]]

[defn eq [x [i32] y [i32]] [i32] [intrinsic i32.eq x y]]
[defn ne [x [i32] y [i32]] [i32] [intrinsic i32.ne x y]]
[defn lt-s [x [i32] y [i32]] [i32] [intrinsic i32.lt-s x y]]
[defn lt-u [x [i32] y [i32]] [i32] [intrinsic i32.lt-u x y]]
[defn le-s [x [i32] y [i32]] [i32] [intrinsic i32.le-s x y]]
[defn le-u [x [i32] y [i32]] [i32] [intrinsic i32.le-u x y]]
[defn is-negative [x [i32]] [i32] [lt-s x 0]]

[defn min [x [i32] y [i32]] [i32] [if [lt-s x y] x y]]
[defn max [x [i32] y [i32]] [i32] [if [lt-s x y] y x]]

[defn add [x [i32] y [i32]] [i32] [intrinsic i32.add x y]]
[defn sub [x [i32] y [i32]] [i32] [intrinsic i32.sub x y]]
[defn mul [x [i32] y [i32]] [i32] [intrinsic i32.mul x y]]

[defn inc [x [i32]] [i32] [add x 1]]
[defn dec [x [i32]] [i32] [sub x 1]]

[defn bitwise-and [x [i32] y [i32]] [i32] [intrinsic i32.and x y]]
[defn bitwise-ior [x [i32] y [i32]] [i32] [intrinsic i32.or x y]]
[defn bitwise-xor [x [i32] y [i32]] [i32] [intrinsic i32.xor x y]]

[defn is-odd [x [i32]] [i32] [bitwise-and x 1]]

[datatype pmem [a datatype]
  [pointer [exp mem] a]]

[def static-mem-top [memory-static-top mem]]

[defn static-is [p [pmem -a]] [i32]
  [lt-s [pointer-value p] static-mem-top]]

[mutable mem-top [memory-static-top mem]]

[defn get-top [] [i32]
  mem-top]

[defn set-top [new-top [i32]] [tuple]
  [assign mem-top new-top]]

[defn align [p [i32] x [i32]] [i32]
  [bitwise-and
    [add x [dec p]]
    [bitwise-xor [i32 -1] [dec p]]]]

[defn mem-align [p [i32]] [i32]
  [align [i32 16] p]]

[defn mem-align-is [p [i32]] [i32]
  [eq p [mem-align p]]]

[defn memory-fill [p [pmem -a] value [i32] n-bytes [i32]] [tuple]
  [intrinsic memory.fill mem [pointer-value p] value n-bytes]]

[defn memory-zero [p [pmem -a] n-bytes [i32]] [tuple]
  [memory-fill p 0 n-bytes]]

[defn memory-copy [pdst [pmem -a] psrc [pmem -a] n-bytes [i32]] [tuple]
  [intrinsic memory.copy mem [pointer-value pdst] [pointer-value psrc] n-bytes]]

[defn memory-compare [p1 [pmem [array [u8]]] p2 [pmem [array [u8]]] n-bytes [i32]] [i64]
  [loop [i 0]
    [if [lt-s i n-bytes]
      [let [diff [intrinsic i64.sub [deref [pindex p1 i]] [deref [pindex p2 i]]]]
        [if [intrinsic i64.eq diff [i64 0]]
          [continue i [inc i]]
          diff]]
      [i64 0]]]]

[defn memory-size-bytes [] [i32]
  [intrinsic i32.shl [intrinsic memory.size mem] [i32 16]]]

[def null [pointer [exp mem] -a [i32 0]]]

[defn is-null [p [pmem -a]] [i32]
  [eq [pointer-value p] 0]]

[defn resize-mem-to-fit [new-top [i32]] [tuple]
  [let
    [mem-size [memory-size-bytes]]
    [if [lt-s mem-size new-top]
      [let
        [missing-bytes [sub new-top mem-size]
         missing-pages [intrinsic i32.shr-s [align [i32 65536] missing-bytes] [i32 16]]
         res [intrinsic memory.grow mem missing-pages]]
        [when [is-negative res]
          [log-i32 missing-bytes]
          [log-i32 missing-pages]
          [log-abort [text 'resize-mem-to-fit memory.grow failed']]]
        [log-ar [text 'resize-mem-to-fit grew mem pages']]
        [log-i32 missing-bytes]
        [log-i32 missing-pages]]]]]

[defn resize-mem [frame-size [i32]] [tuple]
  [let
    [new-top [add [get-top] frame-size]]
    [resize-mem-to-fit new-top]
    [set-top new-top]]]

[datatype alloc-stack-frame [byte-aligned-size [exp [i32]]]
  [record
    [frame-size [i32]]
    [byte-size [i32]]
    [byte-aligned-size [i32]]
    [realloc-size [i32]] ; a size less than equal to the original for when the block is reallocated to a smaller size in place
    [abandoned [i32]] ; when the block could not be reallocated in place
    [data [array [u8] byte-aligned-size]]
    [canary [i64]]
    [frame-size-end [i32]]
    ]]

; cacacadeadbeef in little endian
[def canary-value [i64 0xefbeaddecacaca]]

[mutable num-of-frames [i32 0]]

[defn get-number-of-frames [] [i32] num-of-frames]

[export get-number-of-frames]

[defn alloc-frame-log [pframe [pmem [alloc-stack-frame -a]]] [tuple]
  [let
    [frame-size [deref [pfield pframe frame-size]]
     byte-size [deref [pfield pframe byte-size]]
     realloc-size [deref [pfield pframe realloc-size]]
     byte-aligned-size [deref [pfield pframe byte-aligned-size]]
     abandoned [deref [pfield pframe abandoned]]
     pframe-sized [pointer [exp mem] [alloc-stack-frame [exp byte-aligned-size]] pframe]
     canary [deref [pfield pframe-sized canary]]
     frame-size-end [deref [pfield pframe-sized frame-size-end]]]
  [log-ar [text 'alloc-frame-log']]
  [log-i32 frame-size]
  [log-i32 byte-size]
  [log-i32 realloc-size]
  [log-i32 byte-aligned-size]
  [log-i32 abandoned]
  [log-ar [text 'alloc-frame-log data start']]
  [log [pfield pframe data] byte-size]
  [log-ar [text 'alloc-frame-log data end']]
  ]]

[defn alloc-frame-validate [pframe [pmem [alloc-stack-frame -a]]] [tuple]
  ; todo check if top is within memory bounds
  [if [static-is pframe]
    [log-abort [text 'alloc-frame-validate pframe points to static mem']]]
  [if [lt-s [memory-size-bytes] [add [pointer-value pframe] [size-of-type [alloc-stack-frame [exp [mem-align 1]]]]]]
    [log-abort [text 'alloc-frame-validate memory-size-bytes < frame-size']]]
  [let
    [frame-size [deref [pfield pframe frame-size]]
     byte-size [deref [pfield pframe byte-size]]
     realloc-size [deref [pfield pframe realloc-size]]
     byte-aligned-size [deref [pfield pframe byte-aligned-size]]
     abandoned [deref [pfield pframe abandoned]]
     pframe-sized [pointer [exp mem] [alloc-stack-frame [exp byte-aligned-size]] pframe]
     canary [deref [pfield pframe-sized canary]]
     frame-size-end [deref [pfield pframe-sized frame-size-end]]]
    [if [lt-s frame-size [size-of-type [alloc-stack-frame [exp 0]]]]
      [log-abort [text 'validate-alloc frame-size < size-of-type alloc-stack-frame 0']]]
    [if [ne [mem-align byte-size] byte-aligned-size]
      [log-abort [text 'validate-alloc byte-size != byte-aligned-size']]]
    [if [lt-s byte-size realloc-size]
      [log-abort [text 'validate-alloc byte-size < realloc-size']]]
    [if [lt-s abandoned 0] [log-abort [text 'validate-alloc abandoned < 0']]]
    [if [lt-s 1 abandoned] [log-abort [text 'validate-alloc abandoned > 1']]]
    ; todo check bytes after realloc-size and before byte-size are overwritten
    ; todo check bytes after byte-size and before byte-aligned-size are properly zeroed
    [if [intrinsic i64.ne canary canary-value] [log-abort [text 'validate-alloc canary value mismatch']]]
    [if [ne frame-size frame-size-end] [log-abort [text 'validate-alloc frame-size != frame-size-end']]]]]

[defn alloc-frames-validate-all [] [i32]
  [loop
    [cur-top [get-top]
     i static-mem-top
     n-frames 0]
    [if [lt-s i cur-top]
      [let
        [pframe [pointer [exp mem] [alloc-stack-frame -a] i]
         frame-size [deref [pfield pframe frame-size]]]
        [alloc-frame-validate pframe]
        [continue i [add i frame-size] n-frames [inc n-frames]]]
      [do
        [if [ne n-frames num-of-frames]
          [log-abort [text 'alloc-frames-validate-all n-frames != num-of-frames']]]
        n-frames]]]]

[export alloc-frames-validate-all]

[defn alloc-stack-frame-push [byte-size [i32]] [pmem -a]
  [let
    [byte-aligned-size [mem-align byte-size]
     frame-size [size-of-type [alloc-stack-frame [exp byte-aligned-size]]]
     cur-top [get-top]
     pframe [pointer [exp mem] [alloc-stack-frame [exp byte-aligned-size]] cur-top]
     frame-data [pfield pframe data]]
    [resize-mem frame-size]
    [passign pframe
      [record
        frame-size frame-size
        byte-size byte-size
        byte-aligned-size byte-aligned-size
        realloc-size byte-size
        abandoned 0]]
    [memory-zero frame-data byte-aligned-size]
    [passign [pfield pframe canary] canary-value]
    [passign [pfield pframe frame-size-end] frame-size]
    [alloc-frame-validate pframe]
    [assign num-of-frames [inc num-of-frames]]

    frame-data]]

[defn alloc-stack-frame-update [pframe [pmem [alloc-stack-frame -a]] new-byte-size [i32]] [pmem -a]
  [if [eq new-byte-size 0] [log-abort [text 'alloc-stack-frame-update new-byte-size == 0']]]
  [let
    [old-frame-size [deref [pfield pframe frame-size]]
     byte-aligned-size [mem-align new-byte-size]
     pframe-sized [pointer [exp mem] [alloc-stack-frame [exp byte-aligned-size]] pframe]
     frame-size [size-of-type [alloc-stack-frame [exp byte-aligned-size]]]
     frame-data [pfield pframe data]]
    [resize-mem [sub frame-size old-frame-size]]
    [passign pframe
      [record
        frame-size frame-size
        byte-size new-byte-size
        byte-aligned-size byte-aligned-size
        realloc-size new-byte-size
        abandoned 0]]
    [passign [pfield pframe-sized canary] canary-value]
    [passign [pfield pframe-sized frame-size-end] frame-size]

    frame-data]]

[mutable memory-overwrite-value [i32 0xa0]]

[defn memory-overwrite [pdata [pmem -a] n-bytes [i32]] [tuple]
  [if [lt-s n-bytes 0] [log-abort [text 'overwrite n-bytes < 0']]]
  ; write between 0xa0 and 0xfe to the memory
  [let [overwrite-val memory-overwrite-value]
    [memory-fill pdata overwrite-val n-bytes]
    [assign memory-overwrite-value
      [if [eq overwrite-val [i32 0xfe]]
        [i32 0xa0]
        [inc overwrite-val]]]]]

[defn alloc-stack-frame-abandon [pframe [pmem [alloc-stack-frame -a]]] [tuple]
  ; overwrite data area to avoid dangling pointers using it
  [memory-overwrite [pfield pframe data] [deref [pfield pframe byte-aligned-size]]]
  [passign [pfield pframe abandoned] 1]]

[defn get-top-frame [] [pmem [alloc-stack-frame -a]]
  [let [cur-top [get-top]]
    [if [eq cur-top static-mem-top]
      [pointer [exp mem] [alloc-stack-frame -a] null]
      [let
        [pframe-size [pointer [exp mem] [i32] [sub cur-top [size-of-type [i32]]]]
         frame-size [deref pframe-size]
         pframe [pointer [exp mem] [alloc-stack-frame -a] [sub cur-top frame-size]]]
        [alloc-frame-validate pframe]
        pframe]]]]

[defn alloc-frame-top-log [] [tuple]
  [let [top-frame [get-top-frame]]
    [if [is-null top-frame]
      [log-ar [text 'alloc-frame-top-log stack is empty']]
      [alloc-frame-log top-frame]]]]

[export alloc-frame-top-log]

[defn alloc-stack-pop [] [tuple]
  [let [pframe [get-top-frame]]
    [if [is-null pframe]
      [log-abort [text 'alloc-stack-pop stack empty']]]
    [set-top [pointer-value pframe]]
    [assign num-of-frames [dec num-of-frames]]
    [memory-zero pframe [deref [pfield pframe frame-size]]]]]

; inspired by the lua lua_Alloc function signature
; https://ligurio.github.io/lua-c-manual-pages/lua_Alloc.3.html
; from https://nullprogram.com/blog/2023/12/17/

[defn realloc-debug [old-p [pmem -a] old-n-bytes [i32] new-n-bytes [i32]] [pmem -a]
  [ifs
    [is-null old-p]
    [do
      [if [ne old-n-bytes 0] [log-abort [text 'realloc old-p == 0 && old-n-bytes != 0']]]
      [alloc-stack-frame-push new-n-bytes]]

    [eq old-n-bytes 0]
    [do
      [if [ne [pointer-value old-p] 0] [log-abort [text 'realloc old-n-bytes == 0 && old-p != 0']]]
      [alloc-stack-frame-push new-n-bytes]]

    [let
      ; todo check if old-p is a valid pointer first, non static and within memory bounds
      ; find the frame from the data pointer
      [pframe-i [sub [pointer-value old-p] [offset-of [alloc-stack-frame -a] data]]
       pframe [pointer [exp mem] [alloc-stack-frame -a] pframe-i]
       frame-end [add pframe-i [deref [pfield pframe frame-size]]]]
      [alloc-frame-validate pframe]
      [if [eq [deref [pfield pframe abandoned]] 1]
        [log-abort [text 'realloc frame is abandoned, should not happen']]]

      ; check if old-n matches the frame realloc-size
      [if [ne old-n-bytes [deref [pfield pframe realloc-size]]]
        [log-abort [text 'realloc old-n-bytes != realloc-size']]]
      ; if the frame is the top frame
      [if [eq [get-top] frame-end]
        ; if we are freeing the frame
        [if [eq new-n-bytes 0]
          [do
            ; pop top frame
            [alloc-stack-pop]
            ; pop abandoned frames till we find a non-abandoned frame or the bottom of the stack
            [loop []
              [let [ptframe [get-top-frame]]
                [if [not [is-null ptframe]]
                  [if [eq [deref [pfield ptframe abandoned]] 1]
                    [do
                      [alloc-stack-pop]
                      [continue]]]]]]
            null]
          [do
            [if [eq [deref [pfield pframe abandoned]] 1]
              [log-abort [text 'realloc top frame is abandoned, should not happen']]]
            ; if we are updating the size of the frame
            [if [ne old-n-bytes new-n-bytes]
              [alloc-stack-frame-update pframe new-n-bytes]
              old-p]]]
        ; else, frame is not the last frame
        [ifs
          [eq new-n-bytes 0]
          [do
            [alloc-stack-frame-abandon pframe]
            null]

          [eq old-n-bytes new-n-bytes]
          old-p

          ; if we are within the frame size
          [le-s new-n-bytes [deref [pfield pframe byte-size]]]
          [do
            [if [eq [deref [pfield pframe abandoned]] 1]
              [log-abort [text 'realloc cannot update abandoned frame']]]
            [passign [pfield pframe realloc-size] new-n-bytes]
            [if [lt-s old-n-bytes new-n-bytes]
              ; zero new memory area
              [memory-zero
                [pointer [exp mem] -a [add [pfield pframe data] old-n-bytes]]
                [sub new-n-bytes old-n-bytes]]
              ; overwrite now unused parts of the data area to avoid dangling pointers using it
              [memory-overwrite
                [pointer [exp mem] -a [add [pfield pframe data] new-n-bytes]]
                [sub old-n-bytes new-n-bytes]]]
            old-p]
          ; else, allocate a new frame copying over old data, then abandon the old frame
          [let
            [new-data [alloc-stack-frame-push new-n-bytes]]
            [memory-copy new-data old-p old-n-bytes]
            [alloc-stack-frame-abandon pframe]
            new-data]]]]]]

[export realloc-debug]

[defn pointer-dynamic-is [p [pmem -a]] [i32]
  [if [is-null p]
    1
    [let [pi [pointer-value p]]
      [if [lt-u pi static-mem-top]
      0
      [lt-u pi [memory-size-bytes]]]]]]

[defn realloc-production [old-p [pmem -a] old-n-bytes [i32] new-n-bytes [i32]] [pmem -a]
  [if [not [mem-align-is [pointer-value old-p]]] [log-abort [text 'realloc-production old-p not aligned']]]
  [if [not [pointer-dynamic-is old-p]] [log-abort [text 'realloc-production old-p not dynamic']]]
  [let
    [old-n-aligned [mem-align old-n-bytes]
     new-n-aligned [mem-align new-n-bytes]
     old-pi [pointer-value old-p]
     old-end [add old-pi old-n-aligned]
     cur-top [get-top]]
    [if [eq old-end cur-top]
      ; reallocating the top frame
      [do
        ; ensure the memory fits the new size
        [if [lt-u old-n-aligned new-n-aligned]
          [do
            [resize-mem [sub new-n-aligned old-n-aligned]]
            [memory-zero [pointer [exp mem] -a [add old-pi old-n-bytes]] [sub new-n-bytes old-n-bytes]]
            [memory-overwrite [pointer [exp mem] -a [add old-pi new-n-bytes]] [sub new-n-aligned new-n-bytes]]]]
        old-p]
      [if [le-u new-n-bytes old-n-bytes]
        ; not the top frame but smaller than before
        [do
          ; overwrite now unused parts of the data area to avoid dangling pointers using it
          [memory-overwrite [pointer [exp mem] -a [add old-pi new-n-bytes]] [sub old-n-bytes new-n-bytes]]
          old-p]
        ; else allocating a new frame
        [let [new-p [pointer [exp mem] -a cur-top]]
          [resize-mem new-n-aligned]
          ; copy old data to new location
          [memory-copy new-p old-p old-n-bytes]
          ; abandon old frame
          [memory-overwrite old-p old-n-aligned]
          new-p]]]]]

[def is-debug [i32 1]]

[defn realloc [old-p [pmem -a] old-n-bytes [i32] new-n-bytes [i32]] [pmem -a]
  [if is-debug
    [realloc-debug old-p old-n-bytes new-n-bytes]
    [realloc-production old-p old-n-bytes new-n-bytes]]]

[defn alloc-bytes [n-bytes [i32]] [pmem -a]
  [realloc null 0 n-bytes]]

[defn free [old-p [pmem -a] old-n-bytes [i32]] [tuple]
  [realloc old-p old-n-bytes 0]
  [do]]

[genfn alloc-fn [t datatype] [] [pmem t]
  [pointer [exp mem] t [alloc-bytes [size-of-type t]]]]

[genfn alloc-init [t datatype] [v t] [pmem t]
  [let [p [[instantiate alloc-fn t]]]
    [pinit p v]
    p]]

[defn is-between-inclusive [lower [i64] c [i64] upper [i64]] [i32]
  [bitwise-and [intrinsic i64.le-s lower c] [intrinsic i64.le-s c upper]]]

[defn is-whitespace [c [i64]] [i32]
  [or
    [intrinsic i64.eq c [i64 32]]
    [intrinsic i64.eq c [i64 10]]]]

[defn is-word-char [c [i64]] [i32]
  [or
    [is-between-inclusive [i64 97] c [i64 122]] ; a - z
    [is-between-inclusive [i64 45] c [i64 57]]  ; - . / 0 - 9
    [is-between-inclusive [i64 65] c [i64 90]]  ; A - Z
    [intrinsic i64.eq c [i64 95]]               ; _
    ]]

[datatype list-data [a datatype size [exp [i32]]]
  [record
    [size [i32]]
    [array [array a size]]]]

[datatype plist [vp datatype]
  [pmem [list-data vp -size]]]

[comptimefn static-list [t datatype sz [exp [i32]]] [array [array t sz]] [plist t]
  [data mem
    [record
      size [reify sz]
      array array]]]

[def list-empty [static-list [array [union]]]]

[defn list-size [pvec [pmem [record [size [i32]]]]] [i32]
  [deref [pfield pvec size]]]

[export list-size]

[defn list-empty-is [pvec [pmem [record [size [i32]]]]] [i32]
  [eq [i32 0] [list-size pvec]]]

[genfn list-alloc [elem-type datatype] [lafn-sz [i32]] [plist elem-type]
  ; return empty list if size is 0
  [if [eq lafn-sz 0]
    [pointer [exp mem] [list-data elem-type -a] list-empty]
    [let [p [[instantiate alloc-fn [list-data elem-type [exp lafn-sz]]]]]
      [passign [pfield p size] lafn-sz]
      p]]]

[genfn list-free [elem-type datatype] [pvec [pmem [list-data elem-type -sz]]] [tuple]
  [if [not [static-is pvec]]
    [free pvec [size-of-type [list-data elem-type [exp [deref [pfield pvec size]]]]]]]]

[defn list-alloc-byte [sz [i32]] [plist [u8]] [[instantiate list-alloc [u8]] sz]]
[export list-alloc-byte]

[genfn list-get-p [elem-type datatype] [pvec [pmem [list-data elem-type -sz]] i [i32]] [pmem elem-type]
  [if [lt-s i 0] [log-abort [text 'list-get-p index negative']]]
  [if [le-s [list-size pvec] i] [log-abort [text 'list-get-p index out of bounds']]]
  [pindex [pfield pvec array] i]]

[genfn list-get [elem-type datatype] [pvec [pmem [list-data elem-type -sz]] i [i32]] elem-type
  [if [lt-s i 0] [log-abort [text 'list-get index negative']]]
  [if [le-s [list-size pvec] i] [log-abort [text 'list-get index out of bounds']]]
  [deref [pindex [pfield pvec array] i]]]

[genfn list-last [elem-type datatype] [pvec [pmem [list-data elem-type -sz]]] elem-type
  [if [list-empty-is pvec] [log-abort [text 'list-last list is empty']]]
  [deref [pindex [pfield pvec array] [dec [list-size pvec]]]]]

[genfn list-set [elem-type datatype] [pvec [pmem [list-data elem-type -sz]] i [i32] elem elem-type] [tuple]
  [if [lt-s i 0] [log-abort [text 'list-set index negative']]]
  [if [le-s [list-size pvec] i] [log-abort [text 'list-set index out of bounds']]]
  [passign [pindex [pfield pvec array] i] elem]]

[genfn list-data-array [a datatype] [pvec [plist a]] [pmem [array a]]
  [pfield pvec array]]

[defn list-data-byte-array [pvec [plist [u8]]] [pmem [array [u8]]]
  [list-data-array pvec]]

[export list-data-byte-array]

[datatype growable-list [a datatype]
  [record
    [size [i32]]
    [capacity [i32]]
    [parray [pmem [array a]]]]]

[datatype p-growable-list [a datatype]
  [pmem [growable-list a]]]

[genfn growable-list-alloc-init [elem-type datatype] [init-capacity [i32]] [p-growable-list elem-type]
  [when [le-s init-capacity 0]
    [log-abort [text 'growable-list-alloc-init init-capacity <= 0']]]
  [alloc-init
    [record
      size 0
      capacity init-capacity
      parray [[instantiate alloc-fn [array elem-type [exp init-capacity]]]]]]]

[genfn growable-list-free [elem-type datatype] [pglist [p-growable-list elem-type]] [tuple]
  [let
    [parray [deref [pfield pglist parray]]]
    [free parray [size-of-type [array elem-type [exp [deref [pfield pglist capacity]]]]]]
    [free pglist [size-of-type [growable-list elem-type]]]]]

[genfn growable-list-resize [elem-type datatype] [pglist [p-growable-list elem-type] new-capacity [i32]] [tuple]
  [let
    [cur-capacity [deref [pfield pglist capacity]]
     cur-size [deref [pfield pglist size]]]
    [when [le-s new-capacity cur-size]
      [log-abort [text 'growable-list-resize new-capacity < cur-size']]]
    [passign [pfield pglist capacity] new-capacity]
    [passign [pfield pglist parray]
      [pointer [exp mem] [array elem-type]
        [realloc
          [deref [pfield pglist parray]]
          [size-of-type [array elem-type [exp cur-capacity]]]
          [size-of-type [array elem-type [exp new-capacity]]]]]]]]

[genfn growable-list-push [elem-type datatype] [pglist [p-growable-list elem-type] elem elem-type] [tuple]
  [let
    [cur-size [deref [pfield pglist size]]
     cur-capacity [deref [pfield pglist capacity]]]
    [when [le-s cur-capacity 0]
      [log-abort [text 'growable-list-push capacity <= 0']]]
    [if [eq cur-size cur-capacity]
      [growable-list-resize pglist [mul cur-capacity 2]]]
    [passign [pindex [deref [pfield pglist parray]] cur-size] elem]
    [passign [pfield pglist size] [inc cur-size]]]]

[genfn growable-list-pop [elem-type datatype] [pglist [p-growable-list elem-type]] [tuple]
  [let
    [cur-size [deref [pfield pglist size]]
     cur-capacity [deref [pfield pglist capacity]]]
    [when [eq cur-size 0]
      [log-abort [text 'growable-list-pop size == 0']]]
    [passign [pfield pglist size] [dec cur-size]]]]

[genfn growable-list-get-p [elem-type datatype] [pglist [p-growable-list elem-type] i [i32]] [pmem elem-type]
  [if [lt-s i 0] [log-abort [text 'growable-list-get i negative']]]
  [if [le-s [list-size pglist] i] [log-abort [text 'growable-list-get i out of bounds']]]
  [pindex [deref [pfield pglist parray]] i]]

[genfn growable-list-get [elem-type datatype] [pglist [p-growable-list elem-type] i [i32]] elem-type
  [if [lt-s i 0] [log-abort [text 'growable-list-get i negative']]]
  [if [le-s [list-size pglist] i] [log-abort [text 'growable-list-get i out of bounds']]]
  [deref [pindex [deref [pfield pglist parray]] i]]]

[genfn growable-list-to-list [elem-type datatype] [pglist [p-growable-list elem-type]] [plist elem-type]
  [let
    [cur-size [deref [pfield pglist size]]
     plist [[instantiate list-alloc elem-type] cur-size]]
    [memory-copy
      [list-data-array plist]
      [deref [pfield pglist parray]]
      [mul cur-size [size-of-type elem-type]]]
    plist]]

[defn growable-list-reset [pglist [p-growable-list -a]] [tuple]
  [passign [pfield pglist size] 0]]

[datatype text []
  [plist [u8]]]

[defn log-text [txt [text]] [tuple]
  [log [list-data-array txt] [list-size txt]]]

[datatype writer []
  [p-growable-list [text]]]

[defn writer-alloc [n [i32]] [writer]
  [[instantiate growable-list-alloc-init [text]] n]]

[defn writer-total-size [writer [writer]] [i32]
  [loop [i 0 n [list-size writer] total-size 0]
    [if [lt-s i n]
      [continue
        total-size [add total-size [list-size [growable-list-get writer i]]]
        i [inc i]]
      total-size]]]

[defn writer-to-text [writer [writer]] [text]
  [let
    [total-size [writer-total-size writer]
     result [list-alloc-byte total-size]
     result-data [list-data-array result]]
    [loop [i 0 n [list-size writer] offset 0]
      [if [lt-s i n]
        [let
          [txt [growable-list-get writer i]
           txt-size [list-size txt]]
          [memory-copy [pindex result-data offset] [list-data-array txt] txt-size]
          [continue
            offset [add offset txt-size]
            i [inc i]]]]]
    result]]

[defn write-text [writer [writer] txt [text]] [tuple]
  [growable-list-push writer txt]]

[defn integer-to-text [n [i64] negative [i32]] [text]
  [if [intrinsic i64.eq n [i64 0]]
    [static-list [text 0]]
    [let [gl [[instantiate growable-list-alloc-init [i64]] [i32 10]]]
      [if negative
        [do
          [loop [cur n]
            [when [intrinsic i64.ne cur [i64 0]]
              [let
                [rem [intrinsic i64.sub [i64 0] [intrinsic i64.rem-s cur [i64 10]]]]
                [growable-list-push gl [intrinsic i64.add [i64 48] rem]]
                [continue cur [intrinsic i64.div-s cur [i64 10]]]]]]
          [growable-list-push gl [i64 45]]]
        [do
          [loop [cur n]
            [when [intrinsic i64.ne cur [i64 0]]
              [let [rem [intrinsic i64.rem-s cur [i64 10]]]
                [growable-list-push gl [intrinsic i64.add [i64 48] rem]]
                [continue cur [intrinsic i64.div-s cur [i64 10]]]]]]
          ;[growable-list-push gl [i64 43]]
          ]]
      [let
        [rsz [list-size gl]
         result [list-alloc-byte rsz]
         result-data [list-data-array result]]
        [loop [i 0]
          [when [lt-s i rsz]
            [passign [pindex result-data i] [deref [pindex [deref [pfield gl parray]] [dec [sub rsz i]]]]]
            [continue i [inc i]]]]
        [growable-list-free gl]
        result]]]]

[datatype p-assoc-list [key datatype value datatype]
  [p-growable-list [tuple key value]]]

[genfn assoc-list-push [k datatype v datatype] [pglist [p-assoc-list k v] key k value v] [tuple]
  [growable-list-push pglist [tuple key value]]]

[genfn assoc-list-try-get-value [k datatype v datatype] [pglist [p-assoc-list k v] key k] [tuple [boolean] v]
  [loop
    [cur-size [deref [pfield pglist size]]
     i 0]
    [if [lt-s i cur-size]
      [if [eq [deref [pindex [pindex [deref [pfield pglist parray]] i] [i32 0]]] key]
        [tuple true [deref [pindex [pindex [deref [pfield pglist parray]] i] [i32 1]]]]
        [continue i [inc i]]]
      [tuple false [pointer [exp mem] v [i32 0]]]]]]

[genfn assoc-list-has [k datatype v datatype] [pglist [p-assoc-list k v] key k] [boolean]
  [let [[found -] [assoc-list-try-get-value pglist key]]
    found]]

[genfn assoc-list-alloc [k datatype v datatype] [sz [i32]] [p-assoc-list k v]
  [[instantiate growable-list-alloc-init [tuple k v]] sz]]

[datatype form []
  [enum tag [i32]
    [word
      pword [text]]
    [list
      forms [plist [pmem [form]]]]]]

[datatype pform []
  [pmem [form]]]

[defn form-word-alloc [ptext [text]] [pform]
  [alloc-init
    [enum [form] word
      pword ptext]]]

[defn form-list-alloc [pfs [plist [pform]]] [pform]
  [alloc-init
    [enum [form] list
      forms pfs]]]

[defn form-tag [pf [pform]] [i32]
  [deref [pfield pf tag]]]

[export form-tag]

[defn form-word-is [pf [pform]] [i32]
  [match pf
    word true
    false]]

[export form-word-is]

[defn form-word-get [pf [pform]] [text]
  [match pf
    word [deref [pfield pf pword]]
    [log-abort [text 'form-word-get not a form word']]]]

[export form-word-get]

[defn form-list-is [pf [pform]] [i32]
  [match pf
    list true
    false]]

[export form-list-is]

[defn form-list-get [pf [pform]] [plist [pform]]
  [match pf
    list [deref [pfield pf forms]]
    [log-abort [text 'form-list-get not a form list']]]]

[export form-list-get]

[defn list-get-form [pfl [plist [pform]] i [i32]] [pform]
  [list-get pfl i]]

[export list-get-form]

[defn text-free [txt [text]] [tuple]
  [list-free txt]]

[export text-free]

[defn form-free [pf [pform]] [tuple]
  [if [not [static-is pf]]
    [match pf
      word
      ; we no longer free the word here as they can be shared between forms
      [free pf [size-of-exp [deref pf]]]

      list
      [let [forms [deref [pfield pf forms]]]
        [loop [i 0 n [list-size forms]]
          [if [lt-s i n]
            [do
              [form-free [list-get forms i]]
              [continue i [inc i]]]]]
        [list-free forms]
        [free pf [size-of-exp [deref pf]]]]

      [log-abort [text 'form-free unknown form type']]]]]

[defn list-forms-free [pfs [plist [pform]]] [tuple]
  [loop [i 0 n [list-size pfs]]
    [if [lt-s i n]
      [do
        [form-free [list-get pfs i]]
        [continue i [inc i]]]]
  [list-free pfs]]]

[export form-free list-forms-free]

[defn scan-word-end [bytes [plist [u8]] start [i32]] [i32]
  [loop [i start n-of-bytes [list-size bytes]]
    [if [lt-s i n-of-bytes]
      [if [is-word-char [list-get bytes i]]
        [continue i [inc i]]
        i]
      i]]]

[defn make-stack [stack-size [i32] init-capacity [i32]] [pmem [array [p-growable-list [pform]]]]
  [if [le-s init-capacity 0] [log-abort [text 'make-stack init-capacity <= 0']]]
  [let [parray [[instantiate alloc-fn [array [p-growable-list [pform]] [exp stack-size]]]]]
    [loop [i 0]
      [if [lt-s i stack-size]
        [do
          [passign
            [pindex parray i]
            [[instantiate growable-list-alloc-init [pform]] init-capacity]
            ]
          [continue i [inc i]]]]]
    parray]]

[defn stack-free [pstack [pmem [array [p-growable-list [pform]]]] stack-size [i32]] [tuple]
  [loop [i 0]
    [if [lt-s i stack-size]
      [do
        [growable-list-free [deref [pindex pstack i]]]
        [continue i [inc i]]]]]
  [free pstack [size-of-type [array [p-growable-list [pform]] [exp stack-size]]]]]

[def stack-size [i32 8]]
[def init-capacity [i32 8]]

[defn list-slice-byte-array [psrc [pmem [array [u8]]] sz [i32]] [plist [u8]]
  [let
    [pdst [list-alloc-byte sz]]
    [memory-copy [list-data-array pdst] psrc sz]
    pdst]]

[defn unwind-stack [stack [pmem [array [p-growable-list [pform]]]] stack-index [i32]] [pform]
  [if [lt-s stack-index 0] [log-abort [text 'unwind-stack stack index negative']]]
  [loop [i stack-index]
    [let [glist [deref [pindex stack i]]
          form-list [growable-list-to-list glist]]
      [growable-list-reset glist]
      [let [fl [form-list-alloc form-list]]
        [if [eq i 0]
          fl
          [do
            [growable-list-push [deref [pindex stack [dec i]]] fl]
            [continue i [dec i]]]]]]]]

[defn text-intern [texts [p-growable-list [text]] pw [pmem [array [u8]]] word-size [i32]] [text]
  [loop [txts-i 0 txts-sz [list-size texts]]
    [if [lt-s txts-i txts-sz]
      [let
        [cur-txt [growable-list-get texts txts-i]
         cur-sz [list-size cur-txt]]
        [if [eq cur-sz word-size]
          [if [intrinsic i64.eq [i64 0] [memory-compare [list-data-array cur-txt] pw word-size]]
            cur-txt
            [continue txts-i [inc txts-i]]]
          [continue txts-i [inc txts-i]]]]
      [pointer [exp mem] [list-data [u8] -size] [i32 0]]]]]

[defn parse-n [bytes [text]]
  [tuple
    [p-growable-list [pform]]
    [p-growable-list [text]]
    [p-assoc-list [pform] [i32]]
    ]
  [let
    [stack [make-stack stack-size init-capacity]
     n-of-bytes [list-size bytes]
     bytes-array [list-data-array bytes]
     result [[instantiate growable-list-alloc-init [pform]] [i32 16]]
     texts [[instantiate growable-list-alloc-init [text]] [i32 10]]
     form-offsets [[instantiate growable-list-alloc-init [tuple [pform] [i32]]] [i32 128]]]
    [loop
      [i 0
       ; todo let stack-index be 0 based instead and result be the top growable-list
       stack-index [i32 -1]]
      [if [not [lt-s i n-of-bytes]]
        [if [not [is-negative stack-index]]
          [growable-list-push result [unwind-stack stack stack-index]]]
        [let [c [list-get bytes i]]
          [ifs
            [is-word-char c]
            [let
              [word-end [scan-word-end bytes [inc i]]
               word-size [sub word-end i]
               p [pointer [exp mem] [array [u8]] [pindex bytes-array i]]
               w-opt [text-intern texts p word-size]
               w
               [if [eq w-opt [i32 0]]
                [let
                  [new-word [list-slice-byte-array p word-size]]
                  [growable-list-push texts new-word]
                  new-word]
                  w-opt]
               fw [form-word-alloc w]]
              [assoc-list-push form-offsets fw i]
              [growable-list-push
                [if [is-negative stack-index]
                  result
                  [deref [pindex stack stack-index]]]
                fw]
              [continue i word-end]]

            [is-whitespace c]
            [continue i [inc i]]

            ; line comment
            [intrinsic i64.eq c [i64 59]]
            [let [comment-end
              [loop [j [inc i]]
                [if [lt-s j n-of-bytes]
                  [if [intrinsic i64.eq [i64 10] [list-get bytes j]]
                    [inc j]
                    [continue j [inc j]]]
                  j]]]
              [continue i comment-end]]

            [intrinsic i64.eq c [i64 91]]
            [do
              [if [lt-s stack-size stack-index] [log-abort [text 'stack max depth reached']]]
              [continue
                i [inc i]
                stack-index [inc stack-index]]]

            [intrinsic i64.eq c [i64 93]]
            [do
              [if [is-negative stack-index] [log-abort [text 'unmatched end bracket']]]
              [let [glist [deref [pindex stack stack-index]]
                    form-list [growable-list-to-list glist]]
                [growable-list-reset glist]
                [let [fl [form-list-alloc form-list]]
                  [assoc-list-push form-offsets fl i]
                  [if [eq stack-index 0]
                    [growable-list-push result fl]
                    [growable-list-push [deref [pindex stack [dec stack-index]]] fl]]
                  [continue
                    i [inc i]
                    stack-index [dec stack-index]]]]]

            [log-abort [text 'unexpected character']]]]]]
        [stack-free stack stack-size]
        [tuple result texts
        form-offsets
        ]]]

[defn parse-all-forms [bytes [text]] [plist [pform]]
  [let
    [[gforms gtexts gform-offsets] [parse-n bytes]
     forms [growable-list-to-list gforms]]
    [growable-list-free gtexts]
    [growable-list-free gforms]
    [growable-list-free gform-offsets]
    forms]]

[export parse-all-forms]

[defn text-eq [w1 [text] w2 [text]] [boolean]
  [if [eq w1 w2]
    true
    [let [n1 [list-size w1]
          n2 [list-size w2]]
      [if [eq n1 n2]
        [intrinsic i64.eq [i64 0] [memory-compare [list-data-array w1] [list-data-array w2] n1]]
        false]]]]

[datatype
  wtype-data []
  [enum tag [i32]
    [integer
      n-bytes [i32]
      signed [boolean]]
    [tuple
      types [plist [pmem [wtype-data]]]]
    [record
      types [plist [pmem [wtype-data]]]
      names [plist [text]]]
    [function
      parameters [plist [pmem [wtype-data]]]
      result [pmem [wtype-data]]]
    [union
      types [plist [pmem [wtype-data]]]]
]]

[datatype wtype [] [pmem [wtype-data]]]

[defn type-empty-is [t [wtype]] [boolean]
  [match t
    union [list-empty-is [deref [pfield t types]]]
    false]]

[def type-union-empty
  [data mem
    [enum [wtype-data] union
      types list-empty]]]

; [defn type-union-alloc [types [plist [wtype]]] [wtype]
;   ; todo filter empty types and sort the types to normalize...
;   [if [list-empty-is types]
;     type-union-empty
;     [alloc-init
;       [record
;         tag [annotation [exp type-union-tag] type-union-tag]
;         types types]]]]

; [defn write-debug-type [writer [writer] t [wtype]] []
;   [let
;     [tag [deref [pfield t tag]]]
;     [ifs
;       [eq tag type-integer-tag]
;       [let
;         [it [cast [pmem [type-integer]] t]
;          n-bytes [deref [pfield it n-bytes]]
;          signed [deref [pfield it signed]]]
;         [write-text writer [static-list [text '[integer ']]]
;         ; [intrinsic i64.extend-i32-s i]
;         [write-text writer [integer-to-text [intrinsic i64.extend-i32-s n-bytes] false]]
;         [write-text writer [static-list [text ' ']]]
;         [write-text writer [integer-to-text [intrinsic i64.extend-i32-s signed] false]]
;         [write-text writer [static-list [text ']']]]
;         ]

;       [eq tag type-error-tag]
;       [write-text writer [static-list [text '[error]']]]

;       [eq tag type-tuple-tag]
;       [write-text writer [static-list [text '[tuple]']]]

;       [eq tag type-record-tag]
;       [write-text writer [static-list [text '[record]']]]

;       [eq tag type-function-tag]
;       [write-text writer [static-list [text '[function]']]]

;       [do
;         [log-i32 tag]
;         [log-abort [text 'write-debug-type unknown type tag']]]]]]

[datatype
  pattern []
  [enum tag [i32]
    [var
      name [text]]
    [wildcard
      name [text]]
    [tuple
      patterns [plist [pmem [pattern]]]]
    [record
      patterns [plist [pmem [pattern]]]
      names [plist [text]]]]]

[datatype ppattern [] [pmem [pattern]]]

[def pattern-wildcard
  [data mem
    [enum [pattern] wildcard
      name [static-list [text -]]]]]

[datatype wexp []
  [enum tag [i32]
    [integer
      negative [i32]
      value [i64]
      type [wtype]]
    [var
      name [text]]
    [if
      condition [pexp]
      true [pexp]
      false [pexp]]
    [intrinsic
      iname [text]
      arguments [plist [pexp]]]
    [call
      func [pexp]
      arguments [plist [pexp]]]
    [tuple
      elements [plist [pexp]]]
    [record
      elements [plist [pexp]]
      names [plist [text]]]
    [let-loop
      is-let [boolean]
      bindings [plist [tuple [ppattern] [pexp]]]
      bodies [plist [pexp]]]
    [continue
      assignments [plist [tuple [text] [pexp]]]]]

    pexp []
    [pmem [wexp]]]

[def exp-tuple-empty
  [data mem
    [enum [wexp] tuple
      elements list-empty]]]

[def exp-record-empty
  [data mem
    [enum [wexp] record
      elements list-empty
      names list-empty]]]

[def type-i32
  [data mem
    [enum [wtype-data] integer
      n-bytes 4
      signed true]]]

[def type-i64
  [data mem
    [enum [wtype-data] integer
      n-bytes 8
      signed true]]]

[def type-tuple-empty
  [data mem
    [enum [wtype-data] tuple
      types list-empty]]]

[defn type-tuple-alloc [types [plist [wtype]]] [wtype]
  [if [list-empty-is types]
    type-tuple-empty
    [alloc-init
      [enum [wtype-data] tuple
        types types]]]]

[def type-record-empty
  [data mem
    [enum [wtype-data] record
      types list-empty
      names list-empty]]]

[defn type-record-alloc [types [plist [wtype]] names [plist [text]]] [wtype]
  [when [ne [list-size types] [list-size names]]
    [log-abort [text 'type-record-alloc types and names size mismatch']]]
  [if [and [list-empty-is types] [list-empty-is names]]
    type-record-empty
    [alloc-init
      [enum [wtype-data] record
        types types
        names names]]]]

[defn type-function-alloc [parameters [plist [wtype]] result [wtype]] [wtype]
  [alloc-init
    [enum [wtype-data] function
      parameters parameters
      result result]]]

[datatype global-desc-kind []
  [enum tag [i32]
    [func
      parameter-patterns [plist [ppattern]]
      parameter-types [plist [wtype]]
      result [wtype]]
    [def
      exp [pexp]
      mutable [i32]]]]

[datatype error []
  [record
    [message [text]]
    [offset [i32]]]]

[datatype local-context-kind []
  [i32]]

[def context-kind-func [i32 1]]
[def context-kind-let [i32 2]]
[def context-kind-loop [i32 3]]

[datatype local-frame []
  [record
    [context-kind [local-context-kind]]
    [variables [p-assoc-list [text] [wtype]]] ; func parameters/ let-loop bound names
    ]]

[datatype function-frame []
  [record
    [func-local-variables [p-assoc-list [text] [wtype]]] ; all local vars declared in function
  ]]

[datatype function-body []
  [record
    [locals [plist [tuple [text] [wtype]]]]
    [body [plist [pexp]]]]]

[datatype global-context []
  [record
    [errors [p-growable-list [error]]]
    [names [p-assoc-list [text] [pmem [global-desc-kind]]]]
    [form-offsets [p-assoc-list [pform] [i32]]]
    [exp-types [p-assoc-list [pexp] [wtype]]]
    [exp-local-context [p-assoc-list [pexp] [i32]]]
    [exports [p-assoc-list [text] [pmem [global-desc-kind]]]]
    [local-stack [p-growable-list [local-frame]]]
    [exp-to-forms [p-assoc-list [pmem -a] [pform]]]
    [function-bodies [p-assoc-list [pmem [global-desc-kind]] [pmem [function-body]]]]
    [function-stack [p-growable-list [function-frame]]]
    ]]

[defn global-context-alloc [form-offsets [p-assoc-list [pform] [i32]]] [pmem [global-context]]
  [alloc-init
    [record
      errors [[instantiate growable-list-alloc-init [error]] [i32 10]]
      names [[instantiate assoc-list-alloc [text] [pmem [global-desc-kind]]] [i32 10]]
      form-offsets form-offsets
      exp-types [[instantiate assoc-list-alloc [pexp] [wtype]] [i32 10]]
      exp-local-context [[instantiate assoc-list-alloc [pexp] [i32]] [i32 10]]
      exports [[instantiate assoc-list-alloc [text] [pmem [global-desc-kind]]] [i32 10]]
      local-stack [[instantiate growable-list-alloc-init [local-frame]] [i32 10]]
      exp-to-forms [[instantiate assoc-list-alloc [pmem -a] [pform]] [i32 10]]
      function-bodies [[instantiate assoc-list-alloc [pmem [global-desc-kind]] [pmem [function-body]]] [i32 8]]
      ; as do not have local functions yet the stack can only be empty or have one frame
      function-stack [[instantiate growable-list-alloc-init [function-frame]] [i32 1]]
]]]

[defn global-context-free [gctx [pmem [global-context]]] [tuple]
  [growable-list-free [deref [pfield gctx errors]]]
  [growable-list-free [deref [pfield gctx names]]]
  [growable-list-free [deref [pfield gctx exp-types]]]
  [growable-list-free [deref [pfield gctx exp-local-context]]]
  [growable-list-free [deref [pfield gctx exports]]]
  [growable-list-free [deref [pfield gctx local-stack]]]
  [growable-list-free [deref [pfield gctx exp-to-forms]]]
  [free gctx [size-of-type [global-context]]]]

[export global-context-alloc global-context-free]

[defn global-context-errors [gctx [pmem [global-context]]] [plist [error]]
  [growable-list-to-list [deref [pfield gctx errors]]]]

[defn error-list-get [errors [plist [error]] i [i32]] [pmem [error]]
  [list-get-p errors i]]

[defn error-get-message [error [pmem [error]]] [text]
  [deref [pfield error message]]]

[export global-context-errors error-list-get error-get-message]

[defn local-stack-lookup [gctx [pmem [global-context]] name [text]] [tuple [i32] [wtype]]
  [let
    [stack [deref [pfield gctx local-stack]]
     stack-size [list-size stack]]
    [loop [i stack-size]
      [if [eq i 0]
        [tuple false [pointer [exp mem] [wtype-data] 0]]
        [let
          [frame [growable-list-get-p stack [dec i]]
           locals [deref [pfield frame variables]]
           [found val] [assoc-list-try-get-value locals name]]
          [if found
            [tuple true val]
            [continue i [dec i]]]]]]]]

[defn local-stack-first-frame-by-context-kind [gctx [pmem [global-context]] context-kind [i32]] [pmem [local-frame]]
  [let
    [stack [deref [pfield gctx local-stack]]
     stack-size [list-size stack]]
    [loop [i stack-size]
      [if [eq i 0]
        [log-abort [text 'local-stack-first-frame-by-context-kind no enclosing frame found']]
        [let
          [frame [growable-list-get-p stack [dec i]]]
          [if [eq [deref [pfield frame context-kind]] context-kind]
            frame
            [continue i [dec i]]]]]]]]

[defn log-assoc [pglist [p-assoc-list [pexp] [wtype]]] [tuple]
  [log-i32 [deref [pfield pglist size]]]
  [loop
    [cur-size [deref [pfield pglist size]]
     i 0]
    [when [lt-s i cur-size]
      [log-i32 [deref [pindex [pindex [deref [pfield pglist parray]] i] [i32 0]]]]
      [log-i32 [deref [pindex [pindex [deref [pfield pglist parray]] i] [i32 1]]]]
      [continue i [inc i]]]]]

[defn push-error [gctx [pmem [global-context]] form [pform] msg [text]] [tuple]
  [let
    [errors [deref [pfield gctx errors]]
     [found offset] [assoc-list-try-get-value [deref [pfield gctx form-offsets]] form]]
    [if found
      [growable-list-push errors
        [record
          message msg
          offset offset]]
      [do
        [log-i32 [list-size [deref [pfield gctx form-offsets]]]]
        [log-assoc [deref [pfield gctx form-offsets]]]
        [log-abort [text 'push-error form not found in form-offsets']]]]]]

[defn push-error-exp [gctx [pmem [global-context]] exp [pmem -a] msg [text]] [tuple]
  [let
    [[found form] [assoc-list-try-get-value [deref [pfield gctx exp-to-forms]] exp]]
    [when [not found]
      [log-abort [text 'push-error-exp form not found in exp-to-forms']]]
    [push-error gctx form msg]]]

[defn form-word-get-report [gctx [pmem [global-context]] pf [pform]] [text]
  [if [form-word-is pf]
    [form-word-get pf]
    [do
      [push-error gctx pf [static-list [text 'not a form word']]]
      [static-list [text '']]]]]

[defn form-list-get-report [gctx [pmem [global-context]] pf [pform]] [plist [pform]]
  [if [form-list-is pf]
    [form-list-get pf]
    [do
      [push-error gctx pf [static-list [text 'not a form list']]]
      list-empty]]]

[defn is-digit [cc [i64]] [i32]
  [is-between-inclusive [i64 48] cc [i64 57]]]

; https://github.com/skeeto/scratch/blob/master/parsers/strtonum.c
[defn dec-word-to-i64-signed [gctx [pmem [global-context]] word-form [pform]] [tuple [i32] [i64]]
  [let
    [w [form-word-get-report gctx word-form]
     ws [list-size w]
     first [list-get w 0]]
    [if [intrinsic i64.eq first [i64 45]]
      [tuple
        true
        [loop [i 1 res [i64 0]]
          [if [lt-s i ws]
            [let [cc [list-get w i]]
              [if [not [is-digit cc]]
                [do
                  [push-error gctx word-form [static-list [text 'not a valid digit']]]
                  [i64 0]]
                [let
                  [n [intrinsic i64.mul res [i64 10]]
                   s [intrinsic i64.sub n [intrinsic i64.sub cc [i64 48]]]]
                  [if [intrinsic i64.lt-s n s]
                    [do
                      [push-error gctx word-form [static-list [text 'i64 underflow']]]
                      [i64 0]]
                    [continue
                      res s
                      i [inc i]]]]]]
            res]]]
      [tuple
        false
        [loop [i 0 res [i64 0]]
          [if [lt-s i ws]
            [let [cc [list-get w i]]
              [if [not [is-digit cc]]
                [do
                  [push-error gctx word-form [static-list [text 'not a valid digit']]]
                  [i64 0]]
                [let
                  [n [intrinsic i64.mul res [i64 10]]
                  s [intrinsic i64.add n [intrinsic i64.sub cc [i64 48]]]]
                  [if [intrinsic i64.lt-u s n]
                    [do
                      [push-error gctx word-form [static-list [text 'i64 overflow']]]
                      [i64 0]]
                    [continue
                      res s
                      i [inc i]]]]]]
            res]]]]]]

[def i32-singleton
  [static-list [array [wtype] type-i32]]]

[def i32i32
  [static-list [array [wtype] type-i32 type-i32]]]

[datatype intrinsic-info []
  [record
    [name [text]]
    [parameters [plist [wtype]]]
    [result [wtype]]
    ]]

[def type-boolean type-i32]

[def intrinsics
  [static-list
    [array [intrinsic-info]
      [record name [static-list [text i32.eqz]] parameters i32-singleton result type-boolean]

      [record name [static-list [text i32.eq]] parameters i32i32 result type-boolean]
      [record name [static-list [text i32.ne]] parameters i32i32 result type-boolean]

      [record name [static-list [text 'i32.lt_s']] parameters i32i32 result type-boolean]
      [record name [static-list [text 'i32.lt_u']] parameters i32i32 result type-boolean]
      [record name [static-list [text 'i32.gt_s']] parameters i32i32 result type-boolean]
      [record name [static-list [text 'i32.gt_u']] parameters i32i32 result type-boolean]

      [record name [static-list [text 'i32.le_s']] parameters i32i32 result type-boolean]
      [record name [static-list [text 'i32.le_u']] parameters i32i32 result type-boolean]
      [record name [static-list [text 'i32.ge_s']] parameters i32i32 result type-boolean]
      [record name [static-list [text 'i32.ge_u']] parameters i32i32 result type-boolean]

      ; lt gt and friends...

      [record name [static-list [text i32.clz]] parameters i32-singleton result type-i32]
      [record name [static-list [text i32.ctz]] parameters i32-singleton result type-i32]
      [record name [static-list [text i32.popcnt]] parameters i32-singleton result type-i32]

      [record name [static-list [text i32.add]] parameters i32i32 result type-i32]
      [record name [static-list [text i32.sub]] parameters i32i32 result type-i32]
      [record name [static-list [text i32.mul]] parameters i32i32 result type-i32]

      [record name [static-list [text i32.and]] parameters i32i32 result type-i32]
      [record name [static-list [text i32.or]] parameters i32i32 result type-i32]
      [record name [static-list [text i32.xor]] parameters i32i32 result type-i32]

      [record name [static-list [text i32.shl]] parameters i32i32 result type-i32]
      [record name [static-list [text 'i32.shr_s']] parameters i32i32 result type-i32]
      [record name [static-list [text 'i32.shr_u']] parameters i32i32 result type-i32]

      [record name [static-list [text i32.rotl]] parameters i32i32 result type-i32]
      [record name [static-list [text i32.rotr]] parameters i32i32 result type-i32]

      ]]]

[defn get-intrinsic-by-name [name [text]] [tuple [boolean] [pmem [intrinsic-info]]]
  [loop
    [cur-size [list-size intrinsics]
     arr [list-data-array intrinsics]
     i 0]
    [if [lt-s i cur-size]
      [let [pintrin [pindex arr i]]
        [if [text-eq [deref [pfield pintrin name]] name]
          [tuple true pintrin]
          [continue i [inc i]]]]
      [tuple false [pointer [exp mem] [intrinsic-info] [i32 0]]]]]]

[defn type-of [gctx [pmem [global-context]] e [pexp]] [wtype]
  [let [tag [deref [pfield e tag]]]
    [match e
      integer
      [deref [pfield e type]]

      intrinsic
      [let
        [[found intrinsic-info] [get-intrinsic-by-name [deref [pfield e iname]]]]
        [when [not found]
          [log-text [deref [pfield e iname]]]
          [log-abort [text 'type-of not found intrinsic-info']]]
        [deref [pfield intrinsic-info result]]]

      call
      [let [tf [type-of gctx [deref [pfield e func]]]]
        [match tf
          function [deref [pfield tf result]]
          [log-abort [text 'type-of not a function type']]]]

      tuple
      [let
        [elements [deref [pfield e elements]]
         n [list-size elements]]
        [if [eq n 0]
          type-tuple-empty
          [loop [types [[instantiate list-alloc [wtype]] n]
                 i 0]
            [if [lt-s i n]
              [do
                [list-set types i [type-of gctx [list-get elements i]]]
                [continue i [inc i]]]
              [type-tuple-alloc types]]]]]

      record
      [let
        [elements [deref [pfield e elements]]
         names [deref [pfield e names]]
         n [list-size elements]]
        [if [eq n 0]
          type-record-empty
          [loop [types [[instantiate list-alloc [wtype]] n]
                 i 0]
            [if [lt-s i n]
              [do
                [list-set types i [type-of gctx [list-get elements i]]]
                [continue i [inc i]]]
              [type-record-alloc types names]]]]]

      let-loop
      [let
        [bodies [deref [pfield e bodies]]]
        [if [list-empty-is bodies]
          type-tuple-empty
          [type-of gctx [list-last bodies]]]]

      continue
      type-union-empty

      [let [exp-types [deref [pfield gctx exp-types]]
            [found annotated-type] [assoc-list-try-get-value exp-types e]]
        [when [not found]
          [log-i32 tag]
          [log-i32 [list-size exp-types]]
          [log-abort [text 'type-of not annotated']]]
        annotated-type]]]]

[defn type-ofs [gctx [pmem [global-context]] es [plist [pexp]]] [wtype]
  [if [list-empty-is es]
    type-tuple-empty
    [type-of gctx [list-last es]]]]

[defn type-assignable [dst [wtype] src [wtype]] [i32]
  [or [eq dst src]
    [let [dst-tag [deref [pfield dst tag]]
          src-tag [deref [pfield src tag]]]
      [if [ne dst-tag src-tag]
        false
        [or
          [match dst
            integer
            [match src
              integer
              [and
                [eq [deref [pfield dst n-bytes]] [deref [pfield src n-bytes]]]
                [eq [deref [pfield dst signed]] [deref [pfield src signed]]]]
              false]

            [tuple record]
            [match src
              [tuple record]
              [let
                [dst-types [deref [pfield dst types]]
                 src-types [deref [pfield src types]]
                 n [list-size dst-types]]
                [if [ne n [list-size src-types]]
                  false
                  [loop [i 0]
                    [if [lt-s i n]
                      [if [not [type-assignable [list-get dst-types i] [list-get src-types i]]]
                        false
                        [continue i [inc i]]]
                      true]]]]
              false]

            false]]]]]]

[defn common-super-type [t1 [wtype] t2 [wtype]] [wtype]
  [if [eq t1 t2]
    t1
    [ifs
      [type-empty-is t1] t2
      [type-empty-is t2] t1
      [log-abort [text 'common-super-type different types']]]
    ]]

[defn primitive-int-name-to-signed-size [fw [text]] [tuple [i32] [i64]]
  [ifs
    [text-eq fw [static-list [text i8]]]
    [tuple true [i64 1]]

    [text-eq fw [static-list [text u8]]]
    [tuple false [i64 1]]

    [text-eq fw [static-list [text i16]]]
    [tuple true [i64 2]]

    [text-eq fw [static-list [text u16]]]
    [tuple false [i64 2]]

    [text-eq fw [static-list [text i32]]]
    [tuple true [i64 4]]

    [text-eq fw [static-list [text u32]]]
    [tuple false [i64 4]]

    [text-eq fw [static-list [text i64]]]
    [tuple true [i64 8]]

    [text-eq fw [static-list [text u64]]]
    [tuple false [i64 8]]

    [do
      [log-text fw]
      [log-abort [text 'primitive-int-name-to-signed-size unknown word']]]]]

[defn annotate [gctx [pmem [global-context]] exp [pexp] t [wtype]] [tuple]
  [assoc-list-push [deref [pfield gctx exp-types]] exp t]]

[defn annotate-local [gctx [pmem [global-context]] exp [pexp]] [tuple]
  [assoc-list-push [deref [pfield gctx exp-local-context]] exp [i32 1]]]

[defn lookup-global [gctx [pmem [global-context]] w [text]] [tuple [boolean] [pmem [global-desc-kind]]]
  [assoc-list-try-get-value [deref [pfield gctx names]] w]]

[defn half [i [i32]] [i32] [intrinsic i32.shr-s i 1]]

[defn add-pattern-to-form [gctx [pmem [global-context]] f [pmem [form]] pat [ppattern]] [ppattern]
  [assoc-list-push [deref [pfield gctx exp-to-forms]] pat f]
  pat]

[defn form-to-pattern [gctx [pmem [global-context]] f [pmem [form]]] [ppattern]
  [ifs
    [form-word-is f]
    [add-pattern-to-form gctx f
      [alloc-init
        [enum [pattern] var
          name [form-word-get f]]]]

    [form-list-is f]
    [let
      [fl [form-list-get-report gctx f]
       n [list-size fl]]
      [when [eq n 0]
        [log-abort [text 'empty list not allowed']]]
      [let [fw [form-word-get-report gctx [list-get fl 0]]]
        [ifs
          [text-eq fw [static-list [text tuple]]]
          [let
            [patterns [[instantiate list-alloc [ppattern]] [dec n]]]
            [loop [i 1]
              [when [lt-s i n]
                [list-set patterns [dec i] [form-to-pattern gctx [list-get fl i]]]
                [continue i [inc i]]]]
            [add-pattern-to-form gctx f
              [alloc-init
                [enum [pattern] tuple
                  patterns patterns]]]]

          [text-eq fw [static-list [text record]]]
          [let
            [patterns [[instantiate list-alloc [ppattern]] [half [dec n]]]
             names [[instantiate list-alloc [text]] [half [dec n]]]]
            [loop [fi 1 i 0]
              [when [lt-s fi n]
                [list-set names i [form-word-get-report gctx [list-get fl fi]]]
                [list-set patterns i [form-to-pattern gctx [list-get fl [inc fi]]]]
                [continue i [inc i] fi [add 2 fi]]]]
            [add-pattern-to-form gctx f
              [alloc-init
                [enum [pattern] record
                  patterns patterns
                  names names]]]]

          [do
            [log-text fw]
            [log-abort [text 'form-to-pattern unknown form-list case']]]]]]

    [log-abort [text 'form-to-pattern unknown form case']]]]

[defn push-pattern-type-local-stack
  [gctx [pmem [global-context]]
   variables [p-assoc-list [text] [wtype]]
   pattern [ppattern]
   type [wtype]
   ] []
  [match pattern
    var
    [assoc-list-push variables [deref [pfield pattern name]] type]

    [tuple record]
    [match type
      [tuple record]
      [loop [patterns [deref [pfield pattern patterns]]
             types [deref [pfield type types]]
             i 0]
        [when [lt-s i [list-size patterns]]
          [let
            [pat [list-get patterns i]
             ptype [if [lt-s i [list-size types]] [list-get types i]
              [do [push-error-exp gctx pat [static-list [text 'no type for pattern']]] type-union-empty]]]
            [push-pattern-type-local-stack gctx variables pat ptype]
            [continue i [inc i]]]]]

      [log-abort [text 'push-pattern-type-local-stack unknown type tag']]]

    [log-abort [text 'push-pattern-type-local-stack unknown pattern tag']]]]

[defn form-to-exp [gctx [pmem [global-context]] f [pmem [form]]] [pexp]
  [ifs
    [form-word-is f]
    [let
      [w [form-word-get-report gctx f]
       [lfound lvar-type] [local-stack-lookup gctx w]
       var-type
       [if lfound
          lvar-type
          [let [[gfound pdesc] [lookup-global gctx w]]
            [if
              [not gfound]
              [do
                [log-text w]
                [push-error gctx f [static-list [text 'variable not found']]]
                type-union-empty]

              [match pdesc
                def
                [type-of gctx [deref [pfield pdesc exp]]]

                func
                [type-function-alloc
                  [deref [pfield pdesc parameter-types]]
                  [deref [pfield pdesc result]]]

                [do
                  [push-error gctx f [static-list [text 'global variable has unknown tag']]]
                  type-union-empty]]]]]
       exp
       [alloc-init
        [enum [wexp] var
          name w]]]
      [when [eq 0 [list-size w]]
        [log-abort [text 'form-to-exp empty word']]]
      ; todo maybe drop the type annotation as the type can be gotten from lctx
      [annotate gctx exp var-type]
      [when lfound
        [annotate-local gctx exp]]
      exp]

    [form-list-is f]
    [let [fl [form-list-get-report gctx f]
          n [list-size fl]
          n-args [dec n]]
      [if [eq n 0]
        exp-tuple-empty
      [let [ff [list-get fl 0]
            fw [form-word-get-report gctx ff]
            [lfound ltype] [local-stack-lookup gctx fw]
            [gfound gdesc] [lookup-global gctx fw]]
        [when lfound
          [log-abort [text 'calling a local variable as a function not yet supported']]]
        [ifs
          gfound
          [let
            [fexp [form-to-exp gctx ff]
             args [[instantiate list-alloc [pexp]] n-args]]
            [loop [i 1]
              [when [lt-s i n]
                [list-set args [sub i 1] [form-to-exp gctx [list-get fl i]]]
                [continue i [inc i]]]]
            [alloc-init
              [enum [wexp] call
                func fexp
                arguments args]]]

          [or
            [text-eq fw [static-list [text i8]]]  [text-eq fw [static-list [text u8]]]
            [text-eq fw [static-list [text i16]]] [text-eq fw [static-list [text u16]]]
            [text-eq fw [static-list [text i32]]] [text-eq fw [static-list [text u32]]]
            [text-eq fw [static-list [text i64]]] [text-eq fw [static-list [text u64]]]]
          [let
            [[signed byte-size] [primitive-int-name-to-signed-size fw]
              bit-size [intrinsic i64.mul byte-size [i64 8]]
             [negative value]
             [if [ne n-args 1]
              [do
                [push-error gctx f [static-list [text 'expects one argument']]]
                [tuple [i32 0] [i64 0]]]
              [dec-word-to-i64-signed gctx [list-get fl 1]]]
              type
              [ifs
                [text-eq fw [static-list [text i32]]] type-i32
                [text-eq fw [static-list [text i64]]] type-i64
                [do
                  [log-text fw]
                  [log-abort [text 'form-to-exp primitive-int-name-to-signed-size unknown word']]]]]
            [if signed
              [let
                [pow2 [intrinsic i64.shl [i64 1] [intrinsic i64.sub bit-size [i64 1]]]
                 lower [intrinsic i64.sub [i64 0] pow2]
                 upper [intrinsic i64.sub pow2 [i64 1]]]
                [when [intrinsic i64.lt-s value lower]
                  [push-error gctx f [static-list [text 'signed value out of range, too low']]]]
                [when [intrinsic i64.lt-s upper value]
                  [push-error gctx f [static-list [text 'signed value out of range, too high']]]]]
              [do
                [when negative
                  [push-error gctx f [static-list [text 'negative value for unsigned type']]]]
                [let [unsigned-upper [intrinsic i64.shl [i64 1] bit-size]]
                  [when [intrinsic i64.le-s unsigned-upper value]
                    [push-error gctx f [static-list [text 'unsigned value out of range']]]]]]]
            [alloc-init
              [enum [wexp] integer
                negative negative
                value value
                type type]]]

          [text-eq fw [static-list [text if]]]
          [do
            [if [ne n-args 3]
              [log-abort [text 'form-to-exp if expects 3 arguments']]]
            [let
              [c [form-to-exp gctx [list-get fl 1]]
               t [form-to-exp gctx [list-get fl 2]]
               e [form-to-exp gctx [list-get fl 3]]
               if-exp
               [alloc-init
                [enum [wexp] if
                  condition c
                  true t
                  false e]]
               tc [type-of gctx c]]
              [when [not [type-assignable type-i32 tc]]
                [log-i32 tc]
                [push-error gctx [list-get fl 1] [static-list [text 'if condition not i32 here']]]]
              [annotate gctx if-exp [common-super-type [type-of gctx t] [type-of gctx e]]]
              if-exp]]

          [text-eq fw [static-list [text tuple]]]
          [if [eq n-args 0]
            exp-tuple-empty
            [let [exps [[instantiate list-alloc [pexp]] n-args]]
              [loop [i 1]
                [when [lt-s i n]
                  [list-set exps [dec i] [form-to-exp gctx [list-get fl i]]]
                  [continue i [inc i]]]]
              [alloc-init
                [enum [wexp] tuple
                  elements exps]]]]

          [text-eq fw [static-list [text record]]]
          [let [n-fields [half n-args]]
            [when [is-odd n-args]
              [push-error gctx f [static-list [text 'record expects an even number of arguments, extra is ignored']]]]
            [if [eq n-fields 0]
              exp-record-empty
              [let
                [names [[instantiate list-alloc [text]] n-fields]
                 exps [[instantiate list-alloc [pexp]] n-fields]]
                [loop [fi 1 i 0]
                  [when [lt-s fi n]
                    [list-set names i [form-word-get-report gctx [list-get fl fi]]]
                    [list-set exps i [form-to-exp gctx [list-get fl [inc fi]]]]
                    [continue fi [add 2 fi] i [inc i]]]]
                [alloc-init
                  [enum [wexp] record
                    elements exps
                    names names]]]]]

          [text-eq fw [static-list [text intrinsic]]]
          [do
            [if [eq n-args 0]
              [log-abort [text 'form-to-exp intrinsic expects at least a name argument']]]
            [let
              [name [form-word-get-report gctx [list-get fl 1]]
               [found intrinsic-info] [get-intrinsic-by-name name]
               n-intrinsic-args [dec n-args]
               args [[instantiate list-alloc [pexp]] n-intrinsic-args]
               params
               [if [not found]
                [do
                  [push-error gctx [list-get fl 1] [static-list [text 'intrinsic not found']]]
                  list-empty]
                [let [params [deref [pfield intrinsic-info parameters]]]
                  [when [ne [list-size params] n-intrinsic-args]
                    [push-error gctx f [static-list [text 'form-to-exp intrinsic expects the right number of arguments']]]]
                  params]]]
              [loop [i 2]
                [when [lt-s i n]
                  [list-set args [sub i 2] [form-to-exp gctx [list-get fl i]]]
                  [continue i [inc i]]]]
              [loop [i 0 nn [list-size params]]
                [when [lt-s i nn]
                  [continue i [inc i]]]]
              [loop [i 0 n-to-check [min [list-size params] n-intrinsic-args]]
                [when [lt-s i n-to-check]
                  [let
                    [param [list-get params i]
                     arg [list-get args i]
                     targ [type-of gctx arg]]
                    [when [not [type-assignable param targ]]
                      [log-ar [text 'i32 is']]
                      [log-i32 type-i32]
                      [log-ar [text 'parameter is']]
                      [log-i32 param]
                      [log-ar [text 'arg is']]
                      [log-i32 targ]
                      [push-error gctx [list-get fl [inc i]] [static-list [text 'intrinsic argument type mismatch']]]]
                    ; todo check type
                    [continue i [inc i]]]]]
              [alloc-init
                [enum [wexp] intrinsic
                  iname name
                  arguments args]]]]

          [or [text-eq fw [static-list [text let]]] [text-eq fw [static-list [text loop]]]]
          [do
            [if [lt-s n-args 1]
              [log-abort [text 'form-to-exp let/loop expects 1 or more arguments']]]
            [let
              [func-stack [deref [pfield gctx function-stack]]
               [] [when [list-empty-is func-stack]
                    [log-abort [text 'let/loop outside of function']]]
               enclosing-func-frame [growable-list-get-p func-stack [dec [list-size func-stack]]]
               func-local-variables [deref [pfield enclosing-func-frame func-local-variables]]
               bindings-list [form-list-get-report gctx [list-get fl 1]]
               n-bindings [list-size bindings-list]
               bindings [[instantiate list-alloc [tuple [ppattern] [pexp]]] [half n-bindings]]
               bindings-array [list-data-array bindings]
               bodies [[instantiate list-alloc [pexp]] [sub n 2]]
               variables [[instantiate assoc-list-alloc [text] [wtype]] [i32 8]]
               stack [deref [pfield gctx local-stack]]
               is-let [text-eq fw [static-list [text let]]]]
              [growable-list-push stack
                [record
                  context-kind [if is-let context-kind-let context-kind-loop]
                  variables variables]]
              [when [is-odd n-bindings]
                [push-error gctx [list-last bindings-list]
                  [static-list [text 'let/loop expects an even number of bindings, extra is ignored']]]]
              [loop [fi 0 i 0]
                [when [lt-s fi n-bindings]
                  [let
                    [pat [form-to-pattern gctx [list-get bindings-list fi]]
                     bound-exp [form-to-exp gctx [list-get bindings-list [inc fi]]]
                     bound-type [type-of gctx bound-exp]]
                    [push-pattern-type-local-stack gctx variables pat bound-type]
                    [passign [pindex bindings-array i] [tuple pat bound-exp]]
                    [continue fi [add 2 fi] i [inc i]]]]]
              ; copy local vars to function local vars
              [loop [i 0 n [list-size variables]]
                [when [lt-s i n]
                  [let
                    [assoc-pair [growable-list-get-p variables i]
                     name [deref [pindex assoc-pair [i32 0]]]
                     type [deref [pindex assoc-pair [i32 1]]]]
                    [when [assoc-list-has func-local-variables name]
                      [log-abort [text 'let/loop local variable already defined']]]
                    [assoc-list-push func-local-variables name type]
                    [continue i [inc i]]]]]
              [loop [fi 2]
                [when [lt-s fi n]
                  [list-set bodies [sub fi 2] [form-to-exp gctx [list-get fl fi]]]
                  [continue fi [inc fi]]]]
              [growable-list-pop stack]
              [alloc-init
                [enum [wexp] let-loop
                  is-let is-let
                  bindings bindings
                  bodies bodies]]]]

          [text-eq fw [static-list [text continue]]]
          [do
            [when [is-odd n-args]
              [push-error gctx f [static-list [text 'form-to-exp continue expects an even number of arguments']]]]
            [let
              [enclosing-loop-frame [local-stack-first-frame-by-context-kind gctx context-kind-loop]
               loop-variables [deref [pfield enclosing-loop-frame variables]]
               assignments [[instantiate list-alloc [tuple [text] [pexp]]] [half n-args]]
               assignments-array [list-data-array assignments]]
              [loop [fi 1 i 0]
                [when [lt-s fi n]
                  [let
                    [loopvar [form-word-get-report gctx [list-get fl fi]]
                     bound-exp [form-to-exp gctx [list-get fl [inc fi]]]
                     bound-type [type-of gctx bound-exp]
                     [found ploopvar-type] [assoc-list-try-get-value loop-variables loopvar]]
                    [when [not found]
                      [push-error gctx f [static-list [text 'continue variable not found']]]]
                    [when [not [type-assignable ploopvar-type bound-type]]
                      [push-error gctx f [static-list [text 'continue type mismatch']]]]
                    [passign [pindex assignments-array i] [tuple loopvar bound-exp]]
                    [continue i [inc i] fi [add 2 fi]]]]]
              [cast [pexp]
                [alloc-init
                  [enum [wexp] continue
                    assignments assignments]]]]]

          [do
            [log-text fw]
            [log-abort [text 'form-to-exp unknown form-list case']]]]]]]

    [log-abort [text 'form-to-exp unknown form case']]]]

[defn form-to-type [gctx [pmem [global-context]] f [pmem [form]]] [wtype]
  [ifs
    [form-word-is f]
    [let
      [var-name [form-word-get f]]
      [push-error gctx f [static-list [text 'unknown type var']]]
      type-union-empty]

    [form-list-is f]
    [let [fl [form-list-get-report gctx f]
          n [list-size fl]
          n-args [dec n]]
      [if [eq n 0]
        type-tuple-empty
        [let [fw [form-word-get-report gctx [list-get fl 0]]]
          [ifs
            [text-eq fw [static-list [text i32]]]
            [do
              [if [ne n-args 0]
                [log-abort [text 'form-to-type i32 expects no arguments']]]
              type-i32]

            [text-eq fw [static-list [text i64]]]
            [do
              [if [ne n-args 0]
                [log-abort [text 'form-to-type i64 expects no arguments']]]
              type-i64]

            [text-eq fw [static-list [text tuple]]]
            [if [eq n-args 0]
              type-tuple-empty
              [let [ts [[instantiate list-alloc [wtype]] n-args]]
                [loop [i 1]
                  [when [lt-s i n]
                    [list-set ts [dec i] [form-to-type gctx [list-get fl i]]]
                    [continue i [inc i]]]]
                [type-tuple-alloc ts]]]

            [text-eq fw [static-list [text record]]]
            [if [eq n-args 0]
              type-record-empty
              [let [ts [[instantiate list-alloc [wtype]] [half n-args]]
                    ns [[instantiate list-alloc [text]] [half n-args]]]
                [loop [fi 1 i 0]
                  [when [lt-s fi n]
                    [list-set ns i [form-word-get-report gctx [list-get fl fi]]]
                    [list-set ts i [form-to-type gctx [list-get fl [inc fi]]]]
                    [continue i [inc i] fi [add 2 fi]]]]
                [type-record-alloc ts ns]]]

            [log-abort [text 'form-to-type unknown form-list case']]]]]]

    [log-abort [text 'form-to-type unknown form case']]]]

[defn parameter-forms-to-lists
  [gctx [pmem [global-context]]
   param-list [plist [pform]]]
   [tuple [plist [ppattern]] [plist [wtype]]]
  [let
    [n-of-param-forms [list-size param-list]
     parameter-patterns [[instantiate list-alloc [ppattern]] [half n-of-param-forms]]
     parameter-patterns-array [list-data-array parameter-patterns]
     parameter-types [[instantiate list-alloc [wtype]] [half n-of-param-forms]]
     parameter-types-array [list-data-array parameter-types]]
    [if [is-odd n-of-param-forms]
      [push-error gctx [list-get param-list [dec n-of-param-forms]]
        [static-list [text 'functions expect a parameter list with names and type pairs']]]]
    [loop [i 0 ti 0]
      [when [lt-s i n-of-param-forms]
        [let
          [lpat [form-to-pattern gctx [list-get param-list i]]
           ltype [form-to-type gctx [list-get param-list [inc i]]]]
          [passign [pindex parameter-patterns-array ti] lpat]
          [passign [pindex parameter-types-array ti] ltype]
          [continue i [add 2 i] ti [inc ti]]]]]
    [tuple parameter-patterns parameter-types]]]

[defn forms-to-exps [gctx [pmem [global-context]]
                     fl [plist [pform]]
                     start [i32]
                     end [i32]] [plist [pexp]]
  [loop [j start bodies [[instantiate list-alloc [pexp]] [sub end start]]]
    [if [lt-s j end]
      [do
        ; list-map would have been nice here
        [list-set bodies [sub j start] [form-to-exp gctx [list-get fl j]]]
        [continue j [inc j]]]
      bodies]]]

[defn form-to-top [gctx [pmem [global-context]] form [pmem [form]]] [tuple]
  [ifs
    [form-word-is form]
    [do
      [log-abort [text 'form-to-top word case not implemented']]]

    [form-list-is form]
    [let [fl [form-list-get-report gctx form]
          n [list-size fl]
          n-args [dec n]]
      [if [eq n 0]
        [push-error gctx form [static-list [text 'form-to-top empty list not allowed']]]]
      [let [fw [form-word-get-report gctx [list-get fl 0]]]
        [ifs
          [text-eq fw [static-list [text defn]]]
          [do
            [if [lt-s n-args 3]
              [log-abort [text 'form-to-top defn expects at least 3 arguments']]]
            [let
              [name-form [list-get fl 1]
               param-list [form-list-get-report gctx [list-get fl 2]]
               result-type [form-to-type gctx [list-get fl 3]]
               fname [form-word-get-report gctx name-form]
               [ppatterns ptypes] [parameter-forms-to-lists gctx param-list]
               local-stack [deref [pfield gctx local-stack]]
               function-stack [deref [pfield gctx function-stack]]
               parameter-pat-vars [[instantiate assoc-list-alloc [text] [wtype]] [i32 8]]
               func-local-variables [[instantiate assoc-list-alloc [text] [wtype]] [i32 8]]]
              [when [ne [list-size local-stack] 0]
                [log-abort [text 'push-parameter-forms-local-stack stack not empty']]]
              [loop
                 [n-of-param-forms [list-size ppatterns]
                  i 0]
                [when [lt-s i n-of-param-forms]
                  [push-pattern-type-local-stack gctx parameter-pat-vars
                    [list-get ppatterns i] [list-get ptypes i]]
                  [continue i [inc i]]]]
              [growable-list-push local-stack
                [record
                  context-kind context-kind-func
                  variables parameter-pat-vars]]
              [growable-list-push function-stack
                [record
                  func-local-variables func-local-variables]]
              [if [assoc-list-has [deref [pfield gctx names]] fname]
                [push-error gctx name-form [static-list [text 'name already defined']]]]
              [let
                [desc
                  [alloc-init
                    [enum [global-desc-kind] func
                      parameter-patterns ppatterns
                      parameter-types ptypes
                      result result-type]]]
                ; push the desc before processing the body so its signature is available for recursive calls
                [assoc-list-push [deref [pfield gctx names]] fname desc]
                [let [bodies [forms-to-exps gctx fl 4 n]]
                  [when [not [type-assignable result-type [type-ofs gctx bodies]]]
                    [push-error gctx form [static-list [text 'result type mismatch']]]]
                  [growable-list-pop local-stack]
                  [growable-list-pop function-stack]
                  [assoc-list-push [deref [pfield gctx function-bodies]]
                    desc
                    [alloc-init
                      [record
                        locals [growable-list-to-list func-local-variables]
                        body bodies]]]]]]]

          [text-eq fw [static-list [text genfn]]]
          [do
            [if [lt-s n-args 4]
              [log-abort [text 'form-to-top genfn expects at least 4 arguments']]]
            [let
              [name-form [list-get fl 1]
               type-param-list [form-list-get-report gctx [list-get fl 2]]
               param-list [form-list-get-report gctx [list-get fl 3]]
               result-type-form [list-get fl 4]]
               [log-abort [text 'form-to-top genfn not implemented']]]]

          [or
            [text-eq fw [static-list [text def]]]
            [text-eq fw [static-list [text mutable]]]]
          [do
            [if [ne n-args 2]
              [log-abort [text 'form-to-top def expects a name and an expression']]]
            [let
              [dname [form-word-get-report gctx [list-get fl 1]]
               exp [form-to-exp gctx [list-get fl 2]]
               def-desc
               [alloc-init
                [enum [global-desc-kind] def
                  exp exp
                  mutable [text-eq fw [static-list [text mutable]]]]]]
              [assoc-list-push [deref [pfield gctx names]] dname def-desc]]]

          [text-eq fw [static-list [text datatype]]]
          [do
            [log-abort [text 'form-to-top datatype not implemented']]
          ]

          [text-eq fw [static-list [text import]]]
          [do
           [log-abort [text 'form-to-top import not implemented']]
          ]

          [text-eq fw [static-list [text export]]]
          [do
            [if [lt-s n-args 1]
              [log-abort [text 'form-to-top export expects at least 1 arguments']]]
            [let
              [names [deref [pfield gctx names]]
               exports [deref [pfield gctx exports]]]
              [loop [k 1]
                [when [lt-s k n]
                  [let
                    [ef [list-get fl k]
                     export-name [form-word-get-report gctx ef]
                     [found edesc] [assoc-list-try-get-value names export-name]]
                    [if [not found]
                      [push-error gctx ef [static-list [text 'export name not found']]]
                      [assoc-list-push exports export-name edesc]]
                    [continue k [inc k]]]]]]]

          [do
            [log-text fw]
            [log-abort [text 'form-to-top unknown form-list case']]]]]]

    [log-abort [text 'form-to-top unknown form case']]]]

[export form-to-top]

[defn parse-translate [bytes [text]] [pmem [global-context]]
  [let
    [[forms texts form-offsets] [parse-n bytes]
     gctx [global-context-alloc form-offsets]]
    [loop [i 0 n [list-size forms]]
      [when [lt-s i n]
        [form-to-top gctx [growable-list-get forms i]]
        [continue i [inc i]]]]
    gctx]]

[export parse-translate]

[datatype wasm-type [] [text]]

[datatype
  wasm-exp []
  [enum tag [i32]
    [constant
      type [wasm-type]
      value [text]]
    [intrinsic
      name [text]
      immediate-arguments [plist [text]]
      arguments [plist [pmem [wasm-exp]]]]
    [if
      result [plist [wasm-type]]
      condition [pmem [wasm-exp]]
      true [pmem [wasm-exp]]
      false [pmem [wasm-exp]]]
    [loop
      label [text]
      result [plist [wasm-type]]
      body [pmem [wasm-exp]]]
    [instructions
      insts [plist [pmem [wasm-exp]]]]]]

[datatype pwasm-exp [] [pmem [wasm-exp]]]

[def i32-text [static-list [text 'i32']]]
[def i64-text [static-list [text 'i64']]]
[def f32-text [static-list [text 'f32']]]
[def f64-text [static-list [text 'f64']]]

[defn type-to-wasm-type [t [wtype]] [wasm-type]
  [ifs
    [eq t type-i32]
    i32-text

    [eq t type-i64]
    i64-text

    [match t
      integer
      [do
        [when [not [deref [pfield t signed]]]
          [log-i32 [deref [pfield t n-bytes]]]
          [log-i32 [deref [pfield t signed]]]
          [log-abort [text 'type-to-wasm-type unsigned integer not supported']]]
        [ifs
          [eq [deref [pfield t n-bytes]] [i32 4]]
          i32-text

          [eq [deref [pfield t n-bytes]] [i32 8]]
          i64-text

          [log-abort [text 'type-to-wasm-type integer not supported']]]]
      [log-abort [text 'type-to-wasm-type non-integer not supported']]]]]

[defn wuns-type-to-num-of-primitives [t [wtype]] [i32]
  [match t
    [tuple record]
    [let
      [types [deref [pfield t types]]
       n-types [list-size types]]
      [loop [i 0 res 0]
        [if [lt-s i n-types]
          [continue
            res [add res [wuns-type-to-num-of-primitives [list-get types i]]]
            i [inc i]]
          res]]]

    [i32 1]]]

[defn flatten-wuns-type [gl [p-growable-list [wtype]] t [wtype]] []
  [match t
    [tuple record]
    [let
      [types [deref [pfield t types]]
       n-types [list-size types]]
      [loop [i 0]
        [when [lt-s i n-types]
          [flatten-wuns-type gl [list-get types i]]
          [continue i [inc i]]]]]

    [growable-list-push gl t]]]

[defn type-to-wasm-types [t [wtype]] [plist [wasm-type]]
  [let
    [types [[instantiate growable-list-alloc-init [wtype]] [i32 8]]
     [] [flatten-wuns-type types t]
     n-types [list-size types]
     wasm-types [[instantiate list-alloc [wasm-type]] n-types]]
    [loop [i 0]
      [when [lt-s i n-types]
        [list-set wasm-types i [type-to-wasm-type [growable-list-get types i]]]
        [continue i [inc i]]]]
    [growable-list-free types]
    wasm-types]]

[defn exp-get-var-name [exp [pexp]] [text]
  [match exp
    var [deref [pfield exp name]]
    [log-abort [text 'exp-get-var-name not a var']]]]

[defn get-tuple-record-name [t [wtype] i [i32]] [text]
  [match t
    tuple [integer-to-text [intrinsic i64.extend-i32-s i] false]
    record [list-get [deref [pfield t names]] i]
    [log-abort [text 'get-tuple-record-name unknown tag']]]]

[defn local-get-param-by-type [gl [p-growable-list [text]] t [wtype]] [pwasm-exp]
  [match t
    [tuple record]
    [loop [types [deref [pfield t types]]
           n-types [list-size types]
           insts [[instantiate list-alloc [pwasm-exp]] n-types]
           i 0]
      [if [lt-s i n-types]
        [do
          [growable-list-push gl [static-list [text -]]]
          [growable-list-push gl [get-tuple-record-name t i]]
          [list-set insts i [local-get-param-by-type gl [list-get types i]]]
          [growable-list-pop gl]
          [growable-list-pop gl]
          [continue i [inc i]]]
        [alloc-init
          [enum [wasm-exp] instructions
            insts insts]]]]

    [let
      [iargs [[instantiate list-alloc [text]] 1]
       concatted-name [writer-to-text gl]]
      [list-set iargs 0 concatted-name]
      [cast [pwasm-exp]
        [alloc-init
          [enum [wasm-exp] intrinsic
            name [static-list [text local.get]]
            immediate-arguments iargs
            arguments list-empty]]]]]]

[defn pattern-type-to-local-set-drop
   [gctx [pmem [global-context]]
    ginsts [p-growable-list [pwasm-exp]]
    pattern [ppattern]
    type [wtype]] []
  [match pattern
    var
    [let
      [pname [deref [pfield pattern name]]
        iargs [[instantiate list-alloc [text]] 1]]
      [list-set iargs 0 pname]
      [growable-list-push ginsts
        [alloc-init
          [enum [wasm-exp] intrinsic
            name [static-list [text local.set]]
            immediate-arguments iargs
            arguments list-empty]]]]

    wildcard
    [growable-list-push ginsts
      [alloc-init
        [enum [wasm-exp] intrinsic
          name [static-list [text drop]]
          immediate-arguments list-empty
          arguments list-empty]]]

    [tuple record]
    [let [patterns [deref [pfield pattern patterns]]
          n-pats [list-size patterns]
          ptype-tag [deref [pfield type tag]]]
      [match type
        [tuple record]
        [loop [types [deref [pfield type types]]
               i [dec [list-size types]]]
          [when [le-s 0 i]
            [let
              [pat [if [lt-s i n-pats] [list-get patterns i] pattern-wildcard]]
              [pattern-type-to-local-set-drop gctx ginsts pat [list-get types i]]
              [continue i [dec i]]]]]

        [log-abort [text 'pattern-type-to-local-set-drop tuple/record type expected']]]]

    [log-abort [text 'pattern kind not implemented yet']]]]

[defn exp-to-wasm-exp [gctx [pmem [global-context]] exp [pexp]] [pwasm-exp]
  [match exp
    integer
    [let
      [negative [deref [pfield exp negative]]
       value [deref [pfield exp value]]
       type [deref [pfield exp type]]
       txt [integer-to-text value negative]]
      [alloc-init
        [enum [wasm-exp] constant
          type [type-to-wasm-type type]
          value txt]]]

    var
    [let
      [name [deref [pfield exp name]]
       is-local [assoc-list-has [deref [pfield gctx exp-local-context]] exp]]
      [if is-local
        [let [gl [[instantiate growable-list-alloc-init [text]] [i32 10]]]
          [growable-list-push gl name]
          [local-get-param-by-type gl [type-of gctx exp]]]
        [let
          [iargs [[instantiate list-alloc [text]] 1]]
          [list-set iargs 0 name]
          [alloc-init
            [enum [wasm-exp] intrinsic
              name [static-list [text global.get]]
              immediate-arguments iargs
              arguments list-empty]]]]]

    intrinsic
    [let
      [iname [deref [pfield exp iname]]
       arguments [deref [pfield exp arguments]]
       nargs [list-size arguments]
       warguments [[instantiate list-alloc [pmem [wasm-exp]]] nargs]]
      [loop [i 0]
        [when [lt-s i nargs]
          [list-set warguments i [exp-to-wasm-exp gctx [list-get arguments i]]]
          [continue i [inc i]]]]
      [alloc-init
        [enum [wasm-exp] intrinsic
          name iname
          immediate-arguments list-empty
          arguments warguments]]]

    call
    [let
      [func [deref [pfield exp func]]
       arguments [deref [pfield exp arguments]]
       nargs [list-size arguments]
       iargs [[instantiate list-alloc [text]] 1]
       warguments [[instantiate list-alloc [pmem [wasm-exp]]] nargs]]
      [list-set iargs 0 [exp-get-var-name func]]
      [loop [i 0]
        [when [lt-s i nargs]
          [list-set warguments i [exp-to-wasm-exp gctx [list-get arguments i]]]
          [continue i [inc i]]]]
      [alloc-init
        [enum [wasm-exp] intrinsic
          name [static-list [text call]]
          immediate-arguments iargs
          arguments warguments]]]

    if
    [let
      [condition [deref [pfield exp condition]]
       true [deref [pfield exp true]]
       false [deref [pfield exp false]]
       econd [exp-to-wasm-exp gctx condition]
       etrue [exp-to-wasm-exp gctx true]
       efalse [exp-to-wasm-exp gctx false]
       tif [type-of gctx exp]]
      [alloc-init
        [enum [wasm-exp] if
          result [type-to-wasm-types tif]
          condition econd
          true etrue
          false efalse]]]

    [tuple record]
    [loop
      [i 0
       elements [deref [pfield exp elements]]
       n [list-size elements]
       insts [[instantiate list-alloc [pmem [wasm-exp]]] n]]
      [if [lt-s i n]
        [do
          [list-set insts i [exp-to-wasm-exp gctx [list-get elements i]]]
          [continue i [inc i]]]
        [alloc-init
          [enum [wasm-exp] instructions
            insts insts]]]]

    let-loop
    [let
      [bindings [deref [pfield exp bindings]]
       bodies [deref [pfield exp bodies]]
       ginsts [[instantiate growable-list-alloc-init [pmem [wasm-exp]]] [i32 10]]]
      [loop [i 0]
        [when [lt-s i [list-size bindings]]
          [let
            [binding [list-get-p bindings i]
             pattern [deref [pindex binding [i32 0]]]
             value [deref [pindex binding [i32 1]]]
             wvalue [exp-to-wasm-exp gctx value]
             pat-tag [deref [pfield pattern tag]]]
            [growable-list-push ginsts wvalue]
            [pattern-type-to-local-set-drop gctx ginsts pattern [type-of gctx value]]
            [continue i [inc i]]]]]
      [if [deref [pfield exp is-let]]
        [loop [i 0]
          [when [lt-s i [list-size bodies]]
            [growable-list-push ginsts [exp-to-wasm-exp gctx [list-get bodies i]]]
            [continue i [inc i]]]]
        [let [ginsts-body [[instantiate growable-list-alloc-init [pmem [wasm-exp]]] [i32 8]]]
          [loop [i 0]
            [when [lt-s i [list-size bodies]]
              [growable-list-push ginsts-body [exp-to-wasm-exp gctx [list-get bodies i]]]
              [continue i [inc i]]]]
          [growable-list-push ginsts
            [alloc-init
              [enum [wasm-exp] loop
                label [static-list [text lab]]
                result [type-to-wasm-types [type-of gctx exp]]
                body
                [alloc-init
                  [enum [wasm-exp] instructions
                    insts [growable-list-to-list ginsts-body]]]]]]]]
      [alloc-init
        [enum [wasm-exp] instructions
          insts [growable-list-to-list ginsts]]]]

    continue
    [let
      [assignments [deref [pfield exp assignments]]
       n-ass [list-size assignments]
       insts [[instantiate list-alloc [pwasm-exp]] [inc n-ass]]]
      [loop [i 0]
        [when [lt-s i n-ass]
          [let
            [assignment [list-get-p assignments i]
             loop-var [deref [pindex assignment [i32 0]]]
             value [deref [pindex assignment [i32 1]]]
             iargs [[instantiate list-alloc [text]] 1]
             arguments [[instantiate list-alloc [pwasm-exp]] 1]]
            [list-set iargs 0 loop-var]
            [list-set arguments 0 [exp-to-wasm-exp gctx value]]
            [list-set insts i
              [alloc-init
                [enum [wasm-exp] intrinsic
                  name [static-list [text local.set]]
                  immediate-arguments iargs
                  arguments arguments]]]
            [continue i [inc i]]]]]
        [let [br-iargs [[instantiate list-alloc [text]] 1]]
          [list-set br-iargs 0 [static-list [text lab]]]
          [list-set insts n-ass
            [alloc-init
              [enum [wasm-exp] intrinsic
                name [static-list [text br]]
                immediate-arguments br-iargs
                arguments list-empty]]]]
      [alloc-init
        [enum [wasm-exp] instructions
          insts insts]]]

      [log-abort [text 'exp-to-wasm-exp unknown tag']]]]

[def lparen [static-list [text '(']]]
[def rparen [static-list [text ')']]]
[def dollar [static-list [text '$']]]
[def dquote [static-list [text '"']]]
[def space [static-list [text ' ']]]
[def newline [static-list [array [u8] [u8 10]]]]

[defn write-dollar-id [writer [writer] txt [text]] [tuple]
  [write-text writer dollar]
  [write-text writer txt]]

[defn write-results [writer [writer] results [plist [wasm-type]]] []
  [let
    [n-results [list-size results]]
    [when [ne n-results 0]
      [write-text writer space]

      [write-text writer lparen]
      [write-text writer [static-list [text result]]]
      [loop [i 0]
        [when [lt-s i n-results]
          [write-text writer space]
          [write-text writer [list-get results i]]
          [continue i [inc i]]]]

      [write-text writer rparen]]]]

[def indent [static-list [text '  ']]]

[defn write-indents [writer [writer] indent-n [i32]] []
  [write-text writer newline]
  [loop [i 0]
    [when [lt-s i indent-n]
      [write-text writer indent]
      [continue i [inc i]]]]]

[defn write-wasm-exp [writer [writer] indent-n [i32] exp [pwasm-exp]] [tuple]
  [match exp
    instructions
    [let [insts [deref [pfield exp insts]]]
      [loop [i 0 n [list-size insts]]
        [when [lt-s i n]
          [write-text writer space]
          [write-wasm-exp writer indent-n [list-get insts i]]
          [continue i [inc i]]]]]

    [do
      [write-indents writer indent-n]
      [match exp
        constant
        [do
          [write-text writer lparen]
          [write-text writer [deref [pfield exp type]]]
          [write-text writer [static-list [text '.const']]]
          [write-text writer space]
          [write-text writer [deref [pfield exp value]]]
          [write-text writer rparen]]

        intrinsic
        [let
          [iargs [deref [pfield exp immediate-arguments]]
          args [deref [pfield exp arguments]]]
          [write-text writer lparen]
          [write-text writer [deref [pfield exp name]]]
          [loop [i 0 n [list-size iargs]]
            [when [lt-s i n]
              [write-text writer space]
              [write-dollar-id writer [list-get iargs i]]
              [continue i [inc i]]]]
          [loop [i 0 n [list-size args]]
            [when [lt-s i n]
              [write-text writer space]
              [write-wasm-exp writer [inc indent-n] [list-get args i]]
              [continue i [inc i]]]]
          [write-text writer rparen]]

        if
        [do
          [write-text writer lparen]
          [write-text writer [static-list [text 'if']]]

          [write-results writer [deref [pfield exp result]]]

          [write-text writer space]
          [write-wasm-exp writer [inc indent-n] [deref [pfield exp condition]]]
          [write-text writer space]

          [write-indents writer [inc indent-n]]
          [write-text writer lparen]
          [write-text writer [static-list [text then]]]
          [write-wasm-exp writer [add 2 indent-n] [deref [pfield exp true]]]
          [write-text writer rparen]

          [write-text writer space]

          [write-indents writer [inc indent-n]]
          [write-text writer lparen]
          [write-text writer [static-list [text else]]]
          [write-text writer space]
          [write-wasm-exp writer [add 2 indent-n] [deref [pfield exp false]]]
          [write-text writer rparen]
          [write-text writer rparen]]

        loop
        [let
          [label [deref [pfield exp label]]
          result [deref [pfield exp result]]
          body [deref [pfield exp body]]]
          [write-text writer lparen]
          [write-text writer [static-list [text 'loop']]]
          [write-text writer space]
          [write-dollar-id writer label]
          [write-results writer result]
          [write-wasm-exp writer [inc indent-n] body]
          [write-text writer rparen]]

        [log-abort [text 'write-wasm-exp unknown tag']]]]]]

[defn write-func-param-by-type [writer [writer] gl [p-growable-list [text]] ppat [ppattern] t [wtype]] []
  [match t
    [tuple record]
    [match ppat
      [var wildcard]
      [loop [types [deref [pfield t types]]
              n-types [list-size types]
              i 0]
        [when [lt-s i n-types]
          [growable-list-push gl [get-tuple-record-name t i]]
          [write-func-param-by-type writer gl ppat [list-get types i]]
          [growable-list-pop gl]
          [continue i [inc i]]]]

      tuple
      [let [patterns [deref [pfield ppat patterns]]
            types [deref [pfield t types]]
            n-types [list-size types]
            n-pats [list-size patterns]]
        [loop [i 0]
          [when [lt-s i n-types]
            [let [pat [if [lt-s i n-pats] [list-get patterns i] pattern-wildcard]]
              [write-func-param-by-type writer gl pat [list-get types i]]]
            [continue i [inc i]]]]]

      record
      [let [patterns [deref [pfield ppat patterns]]
            types [deref [pfield t types]]
            n-types [list-size types]
            n-pats [list-size patterns]]
        [loop [i 0]
          [when [lt-s i n-types]
            [let [pat [if [lt-s i n-pats] [list-get patterns i] pattern-wildcard]]
              [write-func-param-by-type writer gl pat [list-get types i]]]
            [continue i [inc i]]]]]

      [log-abort [text 'unexpected pattern for tuple']]]

    [match ppat
      var
      [do
        [write-text writer space]
        [write-text writer lparen]
        [write-text writer [static-list [text param]]]
        [write-text writer space]

        [write-dollar-id writer [deref [pfield ppat name]]]
        [loop [i 0 n [list-size gl]]
          [when [lt-s i n]
            [write-text writer [static-list [text -]]]
            [write-text writer [growable-list-get gl i]]
            [continue i [inc i]]]]
        [write-text writer space]

        [write-text writer [type-to-wasm-type t]]
        [write-text writer rparen]]

      wildcard
      [do
        [write-text writer space]
        [write-text writer lparen]
        [write-text writer [static-list [text param]]]
        [write-text writer space]

        [write-text writer [type-to-wasm-type t]]
        [write-text writer rparen]]

      [log-abort [text 'write-func-param-by-type unknown tag']]]]]

[defn write-export [writer [writer] export-name [text] export-kind [text] internal-name [text]] [tuple]
  [write-text writer lparen]
  [write-text writer [static-list [text 'export']]]
  [write-text writer space]

  [write-text writer dquote]
  [write-text writer export-name]
  [write-text writer dquote]

  [write-text writer space]

  [write-text writer lparen]

  [write-text writer export-kind]

  [write-text writer space]

  [write-dollar-id writer internal-name]

  [write-text writer rparen]
  [write-text writer rparen]
  [write-text writer newline]
  ]

[defn write-global-context [writer [writer] gctx [pmem [global-context]]] []
  [let
    [names [deref [pfield gctx names]]
     exports [deref [pfield gctx exports]]]
    [loop
      [n [list-size names]
       i 0]
      [when [lt-s i n]
        [let
          [assoc-pair [growable-list-get-p names i]
           name [deref [pindex assoc-pair [i32 0]]]
           desc [deref [pindex assoc-pair [i32 1]]]]
          [match desc
            func
            [do
              [write-text writer lparen]
              [write-text writer [static-list [text func]]]
              [write-text writer space]

              [write-dollar-id writer name]

              [let
                [ppats [deref [pfield desc parameter-patterns]]
                 ptypes [deref [pfield desc parameter-types]]
                 result [deref [pfield desc result]]
                 gl [[instantiate growable-list-alloc-init [text]] 8]]
                [loop [i 0 n [list-size ppats]]
                  [when [lt-s i n]
                    [let
                      [ppat [list-get ppats i]
                      wuns-type [list-get ptypes i]]
                      [write-func-param-by-type writer gl ppat wuns-type]]
                    [continue i [inc i]]]]
                [growable-list-free gl]

                [write-results writer [type-to-wasm-types result]]
                [let
                  [[found fbody] [assoc-list-try-get-value [deref [pfield gctx function-bodies]] desc]
                   [] [when [not found] [log-abort [text 'write-global-context function body not found']]]
                   locals [deref [pfield fbody locals]]
                   body [deref [pfield fbody body]]]
                  [loop [n-locals [list-size locals] i 0]
                    [when [lt-s i n-locals]
                      [let [binding [list-get-p locals i]]
                        [write-text writer space]
                        [write-text writer lparen]
                        [write-text writer [static-list [text local]]]
                        [write-text writer space]
                        [write-dollar-id writer [deref [pindex binding [i32 0]]]]
                        [write-text writer space]
                        [write-text writer [type-to-wasm-type [deref [pindex binding [i32 1]]]]]
                        [write-text writer rparen]
                        [continue i [inc i]]]]]

                  [loop [i 0 n [list-size body]]
                    [when [lt-s i n]
                      [let [b [list-get body i]]
                        [write-text writer indent]
                        [write-wasm-exp writer 1 [exp-to-wasm-exp gctx b]]
                        [when [lt-s i [dec n]]
                          [let
                            [t [type-of gctx b]
                             n-prim [wuns-type-to-num-of-primitives t]]
                            [loop [j 0]
                              [when [lt-s j n-prim]
                                [write-text writer [static-list [text ' (drop)']]]
                                [continue j [inc j]]]]]]
                        [continue i [inc i]]]]]]]

              [write-text writer rparen]
              [write-text writer newline]
            ]

            def
            [let [exp [deref [pfield desc exp]]]
              [write-text writer lparen]
              [write-text writer [static-list [text global]]]
              [write-text writer space]
              [write-dollar-id writer name]
              [write-text writer space]
              [if [deref [pfield desc mutable]]
                [do
                  [write-text writer [static-list [text '(mut ']]]
                  [write-text writer [type-to-wasm-type [type-of gctx exp]]]
                  [write-text writer rparen]]
                [write-text writer [type-to-wasm-type [type-of gctx exp]]]]

              [write-text writer space]
              [write-wasm-exp writer 1 [exp-to-wasm-exp gctx exp]]
              [write-text writer rparen]
              [write-text writer newline]]

            [log-ar [text 'write-global-context ignoring unknown tag']]]
          [continue i [inc i]]]]]
    [loop
      [n [list-size exports]
       i 0]
      [when [lt-s i n]
        [let
          [assoc-pair [growable-list-get-p exports i]
           name [deref [pindex assoc-pair [i32 0]]]
           desc [deref [pindex assoc-pair [i32 1]]]]
          [match desc
            func
            [write-export writer name [static-list [text 'func']] name]

            [log-ar [text 'write-global-context export ignoring unknown tag']]]
          [continue i [inc i]]]]]

          ]]

[defn parse-translate-to-wat [bytes [text]] [text]
  [let
    [gctx [parse-translate bytes]
     errors [deref [pfield gctx errors]]]
    [when [ne [list-size errors] 0]
      [log-ar [text 'parse-translate-to-wat there were errors']]
      [log-i32 [list-size errors]]
      [loop [j 0 nerr [list-size errors]]
        [when [lt-s j nerr]
          [let [error [growable-list-get-p errors j]]
            [log-text [deref [pfield error message]]]
            [log-i32 [deref [pfield error offset]]]
            [continue j [inc j]]]]]
      [log-abort [text 'parse-translate-to-wat aborting due to errors']]]
    [let
      [writer [[instantiate growable-list-alloc-init [text]] [i32 128]]]
      [write-global-context writer gctx]
      [global-context-free gctx]
      [let [wat [writer-to-text writer]]
        [growable-list-free writer]
        wat]]]]

[export parse-translate-to-wat]

; [defn test-switch [i [i32]] [i64]
;   [switch i
;     [i32 0] [i64 10]
;     [i32 69] [i64 11]
;     [i32 2] [i64 12]
;     [i64 100]]]

; [export test-switch]