[import env
  [mem [memory [i32] 1]]
  [log
    [func
      [par [pointer [exp mem] [array [u8]]]
       n-bytes [i32]]
      [tuple]]]
  [log-i32
    [func
      [n [i32]]
      [tuple]]]
  [dump-mem
    [func
      [par [pointer [exp mem] -a]
       n-bytes [i32]]
      [tuple]]]
      ]

[def-comp-fn log-ar [ar [array [u8]]] [tuple]
  [log [data mem ar] [size-of-exp ar]]]

[def-comp-fn log-abort [ar [array [u8]]] [union]
  [log [data mem ar] [size-of-exp ar]]
  [intrinsic unreachable]]

[def 0 [i32 0]]
[def 1 [i32 1]]
[def 2 [i32 2]]
[def 3 [i32 3]]
[def 4 [i32 4]]

[def false [i32 0]]
[def true [i32 1]]

[defn not [x [i32]] [i32] [if x 0 1]]

[defn eq [x [i32] y [i32]] [i32] [intrinsic i32.eq x y]]
[defn ne [x [i32] y [i32]] [i32] [intrinsic i32.ne x y]]
[defn lt-s [x [i32] y [i32]] [i32] [intrinsic i32.lt-s x y]]
[defn lt-u [x [i32] y [i32]] [i32] [intrinsic i32.lt-u x y]]
[defn le-s [x [i32] y [i32]] [i32] [intrinsic i32.le-s x y]]
[defn le-u [x [i32] y [i32]] [i32] [intrinsic i32.le-u x y]]
[defn is-negative [x [i32]] [i32] [lt-s x 0]]

[defn add [x [i32] y [i32]] [i32] [intrinsic i32.add x y]]
[defn sub [x [i32] y [i32]] [i32] [intrinsic i32.sub x y]]
[defn mul [x [i32] y [i32]] [i32] [intrinsic i32.mul x y]]

[defn inc [x [i32]] [i32] [add x 1]]
[defn dec [x [i32]] [i32] [sub x 1]]

[defn bitwise-and [x [i32] y [i32]] [i32] [intrinsic i32.and x y]]
[defn bitwise-ior [x [i32] y [i32]] [i32] [intrinsic i32.or x y]]
[defn bitwise-xor [x [i32] y [i32]] [i32] [intrinsic i32.xor x y]]

[defn is-odd [x [i32]] [i32] [bitwise-and x 1]]

[datatype pmem [a datatype]
  [pointer [exp mem] a]]

[def static-mem-top [memory-static-top mem]]

[defn static-is [p [pmem -a]] [i32]
  [lt-s [cast [i32] p] static-mem-top]]

[mutable mem-top [memory-static-top mem]]

[defn get-top [] [i32]
  mem-top]

[defn set-top [new-top [i32]] [tuple]
  [assign mem-top new-top]]

[defn align [p [i32] x [i32]] [i32]
  [bitwise-and
    [add x [dec p]]
    [bitwise-xor [i32 -1] [dec p]]]]

[defn mem-align [p [i32]] [i32]
  [align [i32 16] p]]

[defn mem-align-is [p [i32]] [i32]
  [eq p [mem-align p]]]

[defn memory-fill [p [pmem -a] value [i32] n-bytes [i32]] [tuple]
  [intrinsic memory.fill mem [cast [i32] p] value n-bytes]]

[defn memory-zero [p [pmem -a] n-bytes [i32]] [tuple]
  [memory-fill p 0 n-bytes]]

[defn memory-copy [pdst [pmem -a] psrc [pmem -a] n-bytes [i32]] [tuple]
  [intrinsic memory.copy mem [cast [i32] pdst] [cast [i32] psrc] n-bytes]]

[defn memory-compare [p1 [pmem [array [u8]]] p2 [pmem [array [u8]]] n-bytes [i32]] [i32]
  [loop [i 0]
    [if [lt-s i n-bytes]
      [let [diff [sub [index [deref p1] i] [index [deref p2] i]]]
        [if [eq diff 0]
          [continue i [inc i]]
          diff]]
      [i32 0]]]]

[defn memory-size-bytes [] [i32]
  [intrinsic i32.shl [intrinsic memory.size mem] [i32 16]]]

[def null [cast [pmem -a] [i32 0]]]

[defn is-null [p [pmem -a]] [i32]
  [eq [cast [i32] p] 0]]

[defn resize-mem-to-fit [new-top [i32]] [tuple]
  [let
    [mem-size [memory-size-bytes]]
    [if [lt-s mem-size new-top]
      [let
        [missing-bytes [sub new-top mem-size]
         missing-pages [intrinsic i32.shr-s [align [i32 65536] missing-bytes] [i32 16]]
         res [intrinsic memory.grow mem missing-pages]]
        [if [is-negative res] [log-abort [text 'resize-mem memory.grow failed']]]
        [log-ar [text 'resize-mem grew mem pages']]
        [log-i32 missing-bytes]
        [log-i32 missing-pages]]]]]

[defn resize-mem [frame-size [i32]] [tuple]
  [let
    [new-top [add [get-top] frame-size]]
    [resize-mem-to-fit new-top]
    [set-top new-top]]]

[datatype alloc-stack-frame [byte-aligned-size [exp [i32]]]
  [record
    [frame-size [i32]]
    [byte-size [i32]]
    [byte-aligned-size [i32]]
    [realloc-size [i32]] ; a size less than equal to the original for when the block is reallocated to a smaller size in place
    [abandoned [i32]] ; when the block could not be reallocated in place
    [data [array [u8] byte-aligned-size]]
    [canary [i32]]
    [frame-size-end [i32]]
    ]]

[def canary-value [i32 0xdeadbeef]]

[mutable num-of-frames [i32 0]]

[defn get-number-of-frames [] [i32] num-of-frames]

[export get-number-of-frames]

[defn alloc-frame-log [pframe [pmem [alloc-stack-frame -a]]] [tuple]
  [let
    [frame-size [field [deref pframe] frame-size]
     byte-size [field [deref pframe] byte-size]
     realloc-size [field [deref pframe] realloc-size]
     byte-aligned-size [field [deref pframe] byte-aligned-size]
     abandoned [field [deref pframe] abandoned]
     pframe-sized [cast [pmem [alloc-stack-frame [exp byte-aligned-size]]] pframe]
     canary [field [deref pframe-sized] canary]
     frame-size-end [field [deref pframe-sized] frame-size-end]]
  [log-ar [text 'alloc-frame-log']]
  [log-i32 frame-size]
  [log-i32 byte-size]
  [log-i32 realloc-size]
  [log-i32 byte-aligned-size]
  [log-i32 abandoned]
  [log-ar [text 'alloc-frame-log data start']]
  [log [pfield pframe data] byte-size]
  [log-ar [text 'alloc-frame-log data end']]
  ]]

[defn alloc-frame-validate [pframe [pmem [alloc-stack-frame -a]]] [tuple]
  ; todo check if top is within memory bounds
  [if [static-is pframe]
    [log-abort [text 'alloc-frame-validate pframe points to static mem']]]
  [if [lt-s [memory-size-bytes] [add [cast [i32] pframe] [size-of-type [alloc-stack-frame [exp [mem-align 1]]]]]]
    [log-abort [text 'alloc-frame-validate memory-size-bytes < frame-size']]]
  [let
    [frame-size [field [deref pframe] frame-size]
     byte-size [field [deref pframe] byte-size]
     realloc-size [field [deref pframe] realloc-size]
     byte-aligned-size [field [deref pframe] byte-aligned-size]
     abandoned [field [deref pframe] abandoned]
     pframe-sized [cast [pmem [alloc-stack-frame [exp byte-aligned-size]]] pframe]
     canary [field [deref pframe-sized] canary]
     frame-size-end [field [deref pframe-sized] frame-size-end]]
    [if [lt-s frame-size [size-of-type [alloc-stack-frame [exp 0]]]]
      [log-abort [text 'validate-alloc frame-size < size-of-type alloc-stack-frame 0']]]
    [if [ne [mem-align byte-size] byte-aligned-size]
      [log-abort [text 'validate-alloc byte-size != byte-aligned-size']]]
    [if [lt-s byte-size realloc-size]
      [log-abort [text 'validate-alloc byte-size < realloc-size']]]
    [if [lt-s abandoned 0] [log-abort [text 'validate-alloc abandoned < 0']]]
    [if [lt-s 1 abandoned] [log-abort [text 'validate-alloc abandoned > 1']]]
    ; todo check bytes after realloc-size and before byte-size are overwritten
    ; todo check bytes after byte-size and before byte-aligned-size are properly zeroed
    [if [ne canary canary-value] [log-abort [text 'validate-alloc canary value mismatch']]]
    [if [ne frame-size frame-size-end] [log-abort [text 'validate-alloc frame-size != frame-size-end']]]]]

[defn alloc-frames-validate-all [] [i32]
  [loop
    [cur-top [get-top]
     i static-mem-top
     n-frames 0]
    [if [lt-s i cur-top]
      [let
        [pframe [cast [pmem [alloc-stack-frame -a]] i]
         frame-size [field [deref pframe] frame-size]]
        [alloc-frame-validate pframe]
        [continue i [add i frame-size] n-frames [inc n-frames]]]
      [do
        [if [ne n-frames num-of-frames]
          [log-abort [text 'alloc-frames-validate-all n-frames != num-of-frames']]]
        n-frames]]]]

[export alloc-frames-validate-all]

[defn alloc-stack-frame-push [byte-size [i32]] [pmem -a]
  [let
    [byte-aligned-size [mem-align byte-size]
     frame-size [size-of-type [alloc-stack-frame [exp byte-aligned-size]]]
     cur-top [get-top]
     pframe [cast [pmem [alloc-stack-frame [exp byte-aligned-size]]] cur-top]
     frame-data [pfield pframe data]]
    [resize-mem frame-size]
    [assign [field [deref pframe] frame-size] frame-size]
    [assign [field [deref pframe] byte-size] byte-size]
    [assign [field [deref pframe] byte-aligned-size] byte-aligned-size]
    [assign [field [deref pframe] realloc-size] byte-size]
    [assign [field [deref pframe] abandoned] 0]
    [memory-zero frame-data byte-aligned-size]
    [assign [field [deref pframe] canary] canary-value]
    [assign [field [deref pframe] frame-size-end] frame-size]
    [alloc-frame-validate pframe]
    [assign num-of-frames [inc num-of-frames]]

    frame-data]]

[defn alloc-stack-frame-update [pframe [pmem [alloc-stack-frame -a]] new-byte-size [i32]] [pmem -a]
  [if [eq new-byte-size 0] [log-abort [text 'alloc-stack-frame-update new-byte-size == 0']]]
  [let
    [old-frame-size [field [deref pframe] frame-size]
     byte-aligned-size [mem-align new-byte-size]
     pframe-sized [cast [pmem [alloc-stack-frame [exp byte-aligned-size]]] pframe]
     frame-size [size-of-type [alloc-stack-frame [exp byte-aligned-size]]]
     frame-data [pfield pframe data]]
    [resize-mem [sub frame-size old-frame-size]]
    [assign [field [deref pframe] frame-size] frame-size]
    [assign [field [deref pframe] byte-size] new-byte-size]
    [assign [field [deref pframe] byte-aligned-size] byte-aligned-size]
    [assign [field [deref pframe] realloc-size] new-byte-size]
    [assign [field [deref pframe] abandoned] 0]
    [assign [field [deref pframe-sized] canary] canary-value]
    [assign [field [deref pframe-sized] frame-size-end] frame-size]

    frame-data]]

[mutable memory-overwrite-value [i32 0xa0]]

[defn memory-overwrite [pdata [pmem -a] n-bytes [i32]] [tuple]
  [if [lt-s n-bytes 0] [log-abort [text 'overwrite n-bytes < 0']]]
  ; write between 0xa0 and 0xfe to the memory
  [let [overwrite-val memory-overwrite-value]
    [memory-fill pdata overwrite-val n-bytes]
    [assign memory-overwrite-value
      [if [eq overwrite-val [i32 0xfe]]
        [i32 0xa0]
        [inc overwrite-val]]]]]

[defn alloc-stack-frame-abandon [pframe [pmem [alloc-stack-frame -a]]] [tuple]
  ; overwrite data area to avoid dangling pointers using it
  [memory-overwrite [pfield pframe data] [field [deref pframe] byte-aligned-size]]
  [assign [field [deref pframe] abandoned] 1]]

[defn get-top-frame [] [pmem [alloc-stack-frame -a]]
  [let [cur-top [get-top]]
    [if [eq cur-top static-mem-top]
      [cast [pmem [alloc-stack-frame -a]] null]
      [let
        [pframe-size [cast [pmem [i32]] [sub cur-top [size-of-type [i32]]]]
         frame-size [deref pframe-size]
         pframe [cast [pmem [alloc-stack-frame -a]] [sub cur-top frame-size]]]
        [alloc-frame-validate pframe]
        pframe]]]]

[defn alloc-frame-top-log [] [tuple]
  [let [top-frame [get-top-frame]]
    [if [is-null top-frame]
      [log-ar [text 'alloc-frame-top-log stack is empty']]
      [alloc-frame-log top-frame]]]]

[export alloc-frame-top-log]

[defn alloc-stack-pop [] [tuple]
  [let [pframe [get-top-frame]]
    [if [is-null pframe]
      [log-abort [text 'alloc-stack-pop stack empty']]]
    [set-top [cast [i32] pframe]]
    [assign num-of-frames [dec num-of-frames]]
    [memory-zero pframe [field [deref pframe] frame-size]]]]

; inspired by the lua lua_Alloc function signature
; https://ligurio.github.io/lua-c-manual-pages/lua_Alloc.3.html
; from https://nullprogram.com/blog/2023/12/17/

[defn realloc-debug [old-p [pmem -a] old-n-bytes [i32] new-n-bytes [i32]] [pmem -a]
  [ifs
    [is-null old-p]
    [do
      [if [ne old-n-bytes 0] [log-abort [text 'realloc old-p == 0 && old-n-bytes != 0']]]
      [alloc-stack-frame-push new-n-bytes]]

    [eq old-n-bytes 0]
    [do
      [if [ne [cast [i32] old-p] 0] [log-abort [text 'realloc old-n-bytes == 0 && old-p != 0']]]
      [alloc-stack-frame-push new-n-bytes]]

    [let
      ; todo check if old-p is a valid pointer first, non static and within memory bounds
      ; find the frame from the data pointer
      [pframe-i [sub [cast [i32] old-p] [offset-of [alloc-stack-frame -a] data]]
       pframe [cast [pmem [alloc-stack-frame -a]] pframe-i]
       frame-end [add pframe-i [field [deref pframe] frame-size]]]
      [alloc-frame-validate pframe]
      [if [eq [field [deref pframe] abandoned] 1]
        [log-abort [text 'realloc frame is abandoned, should not happen']]]

      ; check if old-n matches the frame realloc-size
      [if [ne old-n-bytes [field [deref pframe] realloc-size]]
        [log-abort [text 'realloc old-n-bytes != realloc-size']]]
      ; if the frame is the top frame
      [if [eq [get-top] frame-end]
        ; if we are freeing the frame
        [if [eq new-n-bytes 0]
          [do
            ; pop top frame
            [alloc-stack-pop]
            ; pop abandoned frames till we find a non-abandoned frame or the bottom of the stack
            [loop []
              [let [ptframe [get-top-frame]]
                [if [not [is-null ptframe]]
                  [if [eq [field [deref ptframe] abandoned] 1]
                    [do
                      [alloc-stack-pop]
                      [continue]]]]]]
            null]
          [do
            [if [eq [field [deref pframe] abandoned] 1]
              [log-abort [text 'realloc top frame is abandoned, should not happen']]]
            ; if we are updating the size of the frame
            [if [ne old-n-bytes new-n-bytes]
              [alloc-stack-frame-update pframe new-n-bytes]
              old-p]]]
        ; else, frame is not the last frame
        [ifs
          [eq new-n-bytes 0]
          [do
            [alloc-stack-frame-abandon pframe]
            null]

          [eq old-n-bytes new-n-bytes]
          old-p

          ; if we are within the frame size
          [le-s new-n-bytes [field [deref pframe] byte-size]]
          [do
            [if [eq [field [deref pframe] abandoned] 1]
              [log-abort [text 'realloc cannot update abandoned frame']]]
            [assign [field [deref pframe] realloc-size] new-n-bytes]
            [if [lt-s old-n-bytes new-n-bytes]
              ; zero new memory area
              [memory-zero
                [cast [pmem -a] [add [pfield pframe data] old-n-bytes]]
                [sub new-n-bytes old-n-bytes]]
              ; overwrite now unused parts of the data area to avoid dangling pointers using it
              [memory-overwrite
                [cast [pmem -a] [add [pfield pframe data] new-n-bytes]]
                [sub old-n-bytes new-n-bytes]]]
            old-p]
          ; else, allocate a new frame copying over old data, then abandon the old frame
          [let
            [new-data [alloc-stack-frame-push new-n-bytes]]
            [memory-copy new-data old-p old-n-bytes]
            [alloc-stack-frame-abandon pframe]
            new-data]]]]]]

[export realloc-debug]

[defn pointer-dynamic-is [p [pmem -a]] [i32]
  [if [is-null p]
    1
    [let [pi [cast [i32] p]]
      [if [lt-u pi static-mem-top]
      0
      [lt-u pi [memory-size-bytes]]]]]]

[defn realloc-production [old-p [pmem -a] old-n-bytes [i32] new-n-bytes [i32]] [pmem -a]
  [if [not [mem-align-is [cast [i32] old-p]]] [log-abort [text 'realloc-production old-p not aligned']]]
  [if [not [pointer-dynamic-is old-p]] [log-abort [text 'realloc-production old-p not dynamic']]]
  [let
    [old-n-aligned [mem-align old-n-bytes]
     new-n-aligned [mem-align new-n-bytes]
     old-pi [cast [i32] old-p]
     old-end [add old-pi old-n-aligned]
     cur-top [get-top]]
    [if [eq old-end cur-top]
      ; reallocating the top frame
      [do
        ; ensure the memory fits the new size
        [if [lt-u old-n-aligned new-n-aligned]
          [do
            [resize-mem [sub new-n-aligned old-n-aligned]]
            [memory-zero [cast [pmem -a] [add old-pi old-n-bytes]] [sub new-n-bytes old-n-bytes]]
            [memory-overwrite [cast [pmem -a] [add old-pi new-n-bytes]] [sub new-n-aligned new-n-bytes]]]]
        old-p]
      [if [le-u new-n-bytes old-n-bytes]
        ; not the top frame but smaller than before
        [do
          ; overwrite now unused parts of the data area to avoid dangling pointers using it
          [memory-overwrite [cast [pmem -a] [add old-pi new-n-bytes]] [sub old-n-bytes new-n-bytes]]
          old-p]
        ; else allocating a new frame
        [let [new-p [cast [pmem -a] cur-top]]
          [resize-mem new-n-aligned]
          ; copy old data to new location
          [memory-copy new-p old-p old-n-bytes]
          ; abandon old frame
          [memory-overwrite old-p old-n-aligned]
          new-p]]]]]

[defn realloc [old-p [pmem -a] old-n-bytes [i32] new-n-bytes [i32]] [pmem -a]
  [realloc-production old-p old-n-bytes new-n-bytes]]

[functor alloc [t datatype]
  [cast [pmem t] [realloc null 0 [size-of-type t]]]]

[defn free [old-p [pmem -a] old-n-bytes [i32]] [tuple]
  [realloc old-p old-n-bytes 0]
  [do]]

[defn is-between-inclusive [lower [i32] c [i32] upper [i32]] [i32]
  [bitwise-and [le-s lower c] [le-s c upper]]]

[defn is-whitespace [c [i32]] [i32]
  [bitwise-ior [eq c [i32 32]] [eq c [i32 10]]]]

[defn is-word-char [c [i32]] [i32]
  [bitwise-ior
    [is-between-inclusive [i32 97] c [i32 122]]
    [is-between-inclusive [i32 45] c [i32 57]]]]

[datatype list-data [a datatype size [exp [i32]]]
  [record
    [size [i32]]
    [array [array a size]]]]

[datatype plist [vp datatype]
  [pmem [list-data vp -size]]]

[defn list-size [pvec [pmem [record [size [i32]]]]] [i32]
  [field [deref pvec] size]]

[export list-size]

[functor list-alloc [elem-type datatype]
  [func [sz [i32]] [plist elem-type]
    [let [p [alloc [list-data elem-type [exp sz]]]]
      [assign [field [deref p] size] sz]
      p]]]

[genfn list-free [elem-type datatype] [pvec [pmem [list-data elem-type -sz]]] [tuple]
  [if [not [static-is pvec]]
    [free pvec [size-of-type [list-data elem-type [exp [field [deref pvec] size]]]]]]]

[def list-alloc-byte [list-alloc [u8]]]
[export list-alloc-byte]

[genfn list-get [elem-type datatype] [pvec [pmem [list-data elem-type -sz]] i [i32]] elem-type
  [if [lt-s i 0] [log-abort [text 'list-get index negative']]]
  [if [le-s [list-size pvec] i] [log-abort [text 'list-get index out of bounds']]]
  [index [field [deref pvec] array] i]]

[genfn list-data-array [a datatype] [pvec [plist a]] [pmem [array a]]
  [pfield pvec array]]

[defn list-data-byte-array [pvec [plist [u8]]] [pmem [array [u8]]]
  [list-data-array pvec]]

[export list-data-byte-array]

[datatype growable-list [a datatype]
  [record
    [size [i32]]
    [capacity [i32]]
    [parray [pmem [array a]]]]]

[functor growable-list-alloc-init [elem-type datatype]
  [func [init-capacity [i32]] [pmem [growable-list elem-type]]
    [let
      [p [alloc [growable-list elem-type]]]
      [assign [deref p]
        [record
          size 0
          capacity init-capacity
          parray [alloc [array elem-type [exp init-capacity]]]]]
      p]]]

[genfn growable-list-free [elem-type datatype] [pglist [pmem [growable-list elem-type]]] [tuple]
  [let
    [parray [field [deref pglist] parray]]
    [free parray [size-of-type [array elem-type [exp [field [deref pglist] capacity]]]]]
    [free pglist [size-of-type [growable-list elem-type]]]]]

[genfn growable-list-resize [elem-type datatype] [pglist [pmem [growable-list elem-type]] new-capacity [i32]] [tuple]
  [let
    [cur-capacity [field [deref pglist] capacity]
     cur-size [field [deref pglist] size]]
    [if [le-s new-capacity cur-size] [log-abort [text 'growable-list-resize new-capacity < cur-size']]]
    [assign [field [deref pglist] capacity] new-capacity]
    [assign [field [deref pglist] parray]
      [cast [pmem [array elem-type]]
        [realloc
          [field [deref pglist] parray]
          [size-of-type [array elem-type [exp cur-capacity]]]
          [size-of-type [array elem-type [exp new-capacity]]]]]]]]

[genfn growable-list-push [elem-type datatype] [pglist [pmem [growable-list elem-type]] elem elem-type] [tuple]
  [let
    [cur-size [field [deref pglist] size]
     cur-capacity [field [deref pglist] capacity]]
    [if [eq cur-size cur-capacity]
      [growable-list-resize pglist [mul cur-capacity 2]]]
    [assign [index [deref [field [deref pglist] parray]] cur-size] elem]
    [assign [field [deref pglist] size] [inc cur-size]]]]

[genfn growable-list-get [elem-type datatype] [pglist [pmem [growable-list elem-type]] i [i32]] elem-type
  [if [lt-s i 0] [log-abort [text 'growable-list-get i negative']]]
  [if [le-s [list-size pglist] i] [log-abort [text 'growable-list-get i out of bounds']]]
  [index [deref [field [deref pglist] parray]] i]]

[genfn growable-list-to-list [elem-type datatype] [pglist [pmem [growable-list elem-type]]] [plist elem-type]
  [let
    [cur-size [field [deref pglist] size]
     plist [cast [plist elem-type] [alloc [list-data elem-type [exp cur-size]]]]]
    [assign [field [deref plist] size] cur-size]
    [loop [i 0]
      [when [lt-s i cur-size]
        [assign
          [index [field [deref plist] array] i]
          [index [deref [field [deref pglist] parray]] i]]
        [continue i [inc i]]]]
    plist]]

[defn growable-list-reset [pglist [pmem [growable-list -a]]] [tuple]
  [assign [field [deref pglist] size] 0]]

[datatype text []
  [plist [u8]]]

[datatype hash-entry [key datatype value datatype]
  [record
    [key key]
;    [hash [i32]]
    [value value]]]

[datatype hash [key datatype value datatype]
  [record
    [size [i32]]
    [capacity [i32]]
    [parray [pmem [array [hash-entry key value]]]]]]

[functor hash-alloc [key datatype value datatype]
  [func [init-capacity [i32]] [pmem [hash key value]]
    [let
      [p [alloc [hash key value]]]
      [assign [deref p]
        [record
          size 0
          capacity init-capacity
          parray [alloc [array [hash-entry key value] [exp init-capacity]]]]]
      p]]]

[def form-word-tag [i32 10]]
[def form-list-tag [i32 11]]

[datatype form-word []
  [record
    [tag [exp form-word-tag]]
    [pword [text]]]]

[datatype
  form-list []
  [record
    [tag [exp form-list-tag]]
    [forms [plist [pmem [form]]]]]

  form []
  [union
    [form-word]
    [form-list]]]

[datatype pform []
  [pmem [form]]]

[defn form-word-alloc [ptext [text]] [pform]
  [let [p [alloc [form-word]]]
    [assign [deref p]
      [record
        tag [annotation [exp form-word-tag] form-word-tag]
        pword ptext]]
    p]]

[defn form-list-alloc [pfs [plist [pform]]] [pform]
  [let [p [alloc [form-list]]]
    [assign [deref p]
      [record
        tag [annotation [exp form-list-tag] form-list-tag]
        forms pfs]]
    p]]

[defn form-tag [pf [pform]] [i32]
  [field [deref pf] tag]]

[export form-tag]

[defn form-word-is [pf [pform]] [i32]
  [eq [field [deref pf] tag] form-word-tag]]

[export form-word-is]

[defn form-word-get [pf [pform]] [text]
  [if [not [form-word-is pf]] [log-abort [text 'form-word-get not a form-word']]]
  [let [pfw [cast [pmem [form-word]] pf]]
    [field [deref pfw] pword]]]

[export form-word-get]

[defn form-list-is [pf [pform]] [i32]
  [eq [field [deref pf] tag] form-list-tag]]

[export form-list-is]

[defn form-list-get [pf [pform]] [plist [pform]]
  [if [not [form-list-is pf]] [log-abort [text 'form-list-get not a form-list']]]
  [let [pfl [cast [pmem [form-list]] pf]]
    [field [deref pfl] forms]]]

[export form-list-get]

[defn list-get-form [pfl [plist [pform]] i [i32]] [pform]
  [list-get pfl i]]

[export list-get-form]

[defn text-free [txt [text]] [tuple]
  [list-free txt]]

[export text-free]

[defn form-free [pf [pform]] [tuple]
  [if [not [static-is pf]]
    [ifs
      [form-word-is pf]
      ; we no longer free the word here as they can be shared between forms
      [free pf [size-of-type [form-word]]]

      [form-list-is pf]
      [let [forms [form-list-get pf]]
        [loop [i 0 n [list-size forms]]
          [if [lt-s i n]
            [do
              [form-free [list-get forms i]]
              [continue i [inc i]]]]]
        [list-free forms]
        [free pf [size-of-type [form-list]]]]

      [log-abort [text 'form-free unknown form type']]]]]

[defn list-forms-free [pfs [plist [pform]]] [tuple]
  [loop [i 0 n [list-size pfs]]
    [if [lt-s i n]
      [do
        [form-free [list-get pfs i]]
        [continue i [inc i]]]]
  [list-free pfs]]]

[export form-free list-forms-free]

[def growable-list-alloc-init-form
  [growable-list-alloc-init [pform]]]

[defn scan-word-end [bytes [plist [u8]] start [i32]] [i32]
  [loop [i start n-of-bytes [list-size bytes]]
    [if [lt-s i n-of-bytes]
      [if [is-word-char [list-get bytes i]]
        [continue i [inc i]]
        i]
      i]]]

[defn make-stack [stack-size [i32] init-capacity [i32]] [pmem [array [pmem [growable-list [pform]]]]]
  [if [le-s init-capacity 0] [log-abort [text 'make-stack init-capacity <= 0']]]
  [let [parray [alloc [array [pmem [growable-list [pform]]] [exp stack-size]]]]
    [loop [i 0]
      [if [lt-s i stack-size]
        [do
          [assign
            [index [deref parray] i]
            [growable-list-alloc-init-form init-capacity]]
          [continue i [inc i]]]]]
    parray]]

[defn stack-free [pstack [pmem [array [pmem [growable-list [pform]]]]] stack-size [i32]] [tuple]
  [loop [i 0]
    [if [lt-s i stack-size]
      [do
        [growable-list-free [index [deref pstack] i]]
        [continue i [inc i]]]]]
  [free pstack [size-of-type [array [pmem [growable-list [pform]]] [exp stack-size]]]]]

[def stack-size [i32 8]]
[def init-capacity [i32 8]]

[defn list-slice-byte-array [psrc [pmem [array [u8]]] sz [i32]] [plist [u8]]
  [let
    [pdst [list-alloc-byte sz]]
    [memory-copy [list-data-array pdst] psrc sz]
    pdst]]

[defn unwind-stack [stack [pmem [array [pmem [growable-list [pform]]]]] stack-index [i32]] [pform]
  [if [lt-s stack-index 0] [log-abort [text 'unwind-stack stack index negative']]]
  [loop [i stack-index]
    [let [glist [index [deref stack] i]
          form-list [growable-list-to-list glist]]
      [growable-list-reset glist]
      [let [fl [form-list-alloc form-list]]
        [if [eq i 0]
          fl
          [do
            [growable-list-push [index [deref stack] [dec i]] fl]
            [continue i [dec i]]]]]]]]

[def growable-list-alloc-init-text
  [growable-list-alloc-init [text]]]

[defn text-intern [texts [pmem [growable-list [text]]] pw [pmem [array [u8]]] word-size [i32]] [text]
  [loop [txts-i 0 txts-sz [list-size texts]]
    [if [lt-s txts-i txts-sz]
      [let
        [cur-txt [growable-list-get texts txts-i]
         cur-sz [list-size cur-txt]]
        [if [eq cur-sz word-size]
          [if [eq 0 [memory-compare [list-data-array cur-txt] pw word-size]]
            cur-txt
            [continue txts-i [inc txts-i]]]
          [continue txts-i [inc txts-i]]]]
      [cast [text] [i32 0]]]]]

[defn parse-n [bytes [text]] [tuple [plist [pform]] [plist [text]]]
  [let
    [stack [make-stack stack-size init-capacity]
     texts [growable-list-alloc-init-text [i32 10]]
     n-of-bytes [list-size bytes]
     bytes-array [list-data-array bytes]
     result [growable-list-alloc-init-form [i32 20]]]
    [loop
      [i 0
       ; todo let stack-index be 0 based instead and result be the top growable-list
       stack-index [i32 -1]]
      [if [not [lt-s i n-of-bytes]]
        [if [not [is-negative stack-index]]
          [growable-list-push result [unwind-stack stack stack-index]]]
        [let [c [list-get bytes i]]
          [ifs
            [is-word-char c]
            [let
              [word-end [scan-word-end bytes [inc i]]
               word-size [sub word-end i]
               p [cast [pmem [array [u8]]] [pindex bytes-array i]]
               w-opt [text-intern texts p word-size]
               w
               [if [eq w-opt [i32 0]]
                [let
                  [new-word [list-slice-byte-array p word-size]]
                  [growable-list-push texts new-word]
                  new-word]
                  w-opt]]
              [growable-list-push
                [if [is-negative stack-index]
                  result
                  [index [deref stack] stack-index]]
                [form-word-alloc w]]
              [continue i word-end]]

            [is-whitespace c]
            [continue i [inc i]]

            [eq c [i32 91]]
            [do
              [if [lt-s stack-size stack-index] [log-abort [text 'stack max depth reached']]]
              [continue
                i [inc i]
                stack-index [inc stack-index]]]

            [eq c [i32 93]]
            [do
              [if [is-negative stack-index] [log-abort [text 'unmatched end bracket']]]
              [let [glist [index [deref stack] stack-index]
                    form-list [growable-list-to-list glist]]
                [growable-list-reset glist]
                [let [fl [form-list-alloc form-list]]
                  [if [eq stack-index 0]
                    [growable-list-push result fl]
                    [growable-list-push [index [deref stack] [dec stack-index]] fl]]
                  [continue
                    i [inc i]
                    stack-index [dec stack-index]]]]]

            [log-abort [text 'unexpected character']]]]]]
        [stack-free stack stack-size]
        [let
          [lres [growable-list-to-list result]
           txts-res [growable-list-to-list texts]]
          [growable-list-free result]
          [growable-list-free texts]
          [tuple lres txts-res]]]]

[export parse-n]

[defn word-eq [w1 [text] w2 [text]] [i32]
  [if [eq w1 w2]
    true
    [let [n1 [list-size w1]
          n2 [list-size w2]]
      [if [eq n1 n2]
        [eq [memory-compare [list-data-array w1] [list-data-array w2] n1] 0]
        false]]]]

[def exp-i32-tag [i32 1]]
[def exp-var-tag [i32 2]]
[def exp-if-tag [i32 3]]

[datatype
  wexp-i32 []
  [record
    [tag [exp exp-i32-tag]]
    [value [i32]]]

  wexp-var []
  [record
    [tag [exp exp-var-tag]]
    [name [text]]]

  wexp-if []
  [record
    [tag [exp exp-if-tag]]
    [condition [pexp]]
    [true [pexp]]
    [false [pexp]]]

  pexp [] [pmem [wexp]]

  wexp []
  [union
    [wexp-i32]
    [wexp-var]
    [wexp-if]
    ]]

[defn wexp-i32-alloc [i [i32]] [pexp]
  [let
    [p [alloc [wexp-i32]]]
    [assign [deref p]
      [record
        tag [annotation [exp exp-i32-tag] exp-i32-tag]
        value i]]
    p]]

[defn wexp-var-alloc [name [text]] [pexp]
  [let
    [p [alloc [wexp-var]]]
    [assign [deref p]
      [record
        tag [annotation [exp exp-var-tag] exp-var-tag]
        name name]]
    p]]

[defn wexp-if-alloc [c [pexp] t [pexp] e [pexp]] [pexp]
  [let
    [p [alloc [wexp-if]]]
    [assign [deref p]
      [record
        tag [annotation [exp exp-if-tag] exp-if-tag]
        condition c
        true t
        false e]]
    p]]

; look here for overflow check https://github.com/skeeto/scratch/blob/master/parsers/strtonum.c
[defn dec-word-to-i32 [w [text]] [i32]
  [loop [i 0 ws [list-size w] res 0]
    [if [lt-s i ws]
      [let [cc [list-get w i]]
        [if [lt-s cc [i32 48]]
          [log-abort [text 'dec-word-to-i32 cc < 48']]]
        [if [lt-s [i32 57] cc]
          [log-abort [text 'dec-word-to-i32 cc > 57']]]
        ; here we should check for overflow and abort if it happens
        [let
          [n [mul res [i32 10]]
           s [add n [sub cc [i32 48]]]]
          [if [lt-s s n]
            [log-abort [text 'dec-word-to-i32 overflow']]]
          [continue
            res s
            i [inc i]]]]
      res]]]

[def-comp-fn static-list [ar [array [u8]]] [plist [u8]]
  [data mem
    [record
      size [size-of-exp ar]
      array ar]]]

[def type-i32 [i32 0x7f]]
[def type-i64 [i32 0x7e]]
[def type-f32 [i32 0x7d]]
[def type-f64 [i32 0x7c]]

[datatype wtype [] [i32]]

[defn type-of [e [pexp]] [i32]
  [let [tag [field [deref e] tag]]
    [ifs
      [eq tag exp-i32-tag]
      type-i32

      [log-abort [text 'type-of unknown tag']]]]]

[defn type-assignable [dst [wtype] src [wtype]] [tuple]
  [let
    []
    [when [ne dst src]
      [log-abort [text 'type-assignable different types']]

      ]]
     ]

[defn common-super-type [t1 [wtype] t2 [wtype]] [wtype]
  [if [eq t1 t2]
    t1
    [log-abort [text 'common-super-type different types']]]]

[datatype global-desc-defn []
  [record
    [tag [exp [i32 1]]]
    [parameters [plist [tuple [text] [wtype]]]]
    [result [wtype]]]]

[datatype global-desc-def []
  [record
    [tag [exp [i32 2]]]
    [type [wtype]]]]

[datatype global-context-kind []
  [union
    [global-desc-defn]
    [global-desc-def]]]

[datatype global-context []
  [record
    [names [pmem [hash [text] [pmem [global-context-kind]]]]]]]

[def hash-alloc-text-global-context-kind [hash-alloc [text] [pmem [global-context-kind]]]]

[defn global-context-alloc [] [pmem [global-context]]
  [let
    [p [alloc [global-context]]]
    [assign [field [deref p] names] [hash-alloc-text-global-context-kind [i32 10]]]
    p]]

[export global-context-alloc]

[datatype local-context-kind []
  [i32]]

[datatype
  local-context [size [exp [i32]]]
  [record
    [context-kind [local-context-kind]]
    [outer [pmem [local-context -sz]]]
    [locals [list-data [tuple [text] [wtype]] size]]]]

[datatype
  plocal-context []
  [pmem [local-context -sz]]]

[def local-context-empty [cast [plocal-context] [i32 0]]]

[defn local-context-alloc [kind [i32] outer [plocal-context] size [i32]] [plocal-context]
  [let
    [p [alloc [local-context [exp size]]]]
    [assign [field [deref p] context-kind] kind]
    [assign [field [deref p] outer] outer]
    [assign [field [field [deref p] locals] size] size]
    p]]

[defn local-context-lookup [lctx [plocal-context] name [text]] [tuple [plocal-context] [wtype]]
  [loop [i 0 cur-ctx lctx]
    [let
      [locals [pfield lctx locals]
       n [list-size locals]
       tuple-array [list-data-array locals]]
      [if [lt-s i n]
        [do
          [if [word-eq [index [index [deref tuple-array] i] [i32 0]] name]
            [tuple cur-ctx [index [index [deref tuple-array] i] [i32 1]]]
            [continue i [inc i] cur-ctx [field [deref lctx] outer]]]]
        [tuple local-context-empty type-i32]]]]]

[defn form-to-exp [gctx [pmem [global-context]] lctx [plocal-context] f [pmem [form]]] [pmem [wexp]]
  [ifs
    [form-word-is f]
    [let [w [form-word-get f]]
      ; todo check if it was actually found!
      [local-context-lookup lctx w]
      [wexp-var-alloc w]]

    [form-list-is f]
    [let [fl [form-list-get f]
          n [list-size fl]
          n-args [dec n]]
      [if [eq n 0]
        [log-abort [text 'form-to-exp empty list not allowed']]]
      [let [fw [form-word-get [list-get fl 0]]]
        [ifs
          [word-eq fw [static-list [text i32]]]
          [do
            [if [ne n-args 1]
              [log-abort [text 'form-to-exp i32 expects one argument']]]
            [wexp-i32-alloc [dec-word-to-i32 [form-word-get [list-get fl 1]]]]]

          [word-eq fw [static-list [text if]]]
          [do
            [if [ne n-args 3]
              [log-abort [text 'form-to-exp if expects 3 arguments']]]
            [let
              [c [form-to-exp gctx lctx [list-get fl 1]]
               t [form-to-exp gctx lctx [list-get fl 2]]
               e [form-to-exp gctx lctx [list-get fl 3]]]
              [type-assignable type-i32 [type-of c]]
              [common-super-type [type-of t] [type-of e]]
              [wexp-if-alloc c t e]]]

          [log-abort [text 'form-to-exp unknown form-list case']]]]]

    [log-abort [text 'form-to-exp unknown form case']]]]

[defn form-to-type [gctx [pmem [global-context]] f [pmem [form]]] [wtype]
  [ifs
    [form-word-is f]
    [do
      [log-abort [text 'form-to-type word case not implemented']]]

    [form-list-is f]
    [let [fl [form-list-get f]
          n [list-size fl]
          n-args [dec n]]
      [if [eq n 0]
        [log-abort [text 'form-to-type empty list not allowed']]]
      [let [fw [form-word-get [list-get fl 0]]]
        [ifs
          [word-eq fw [static-list [text i32]]]
          [do
            [if [ne n-args 0]
              [log-abort [text 'form-to-type i32 expects no arguments']]]
            type-i32]

          [log-abort [text 'form-to-type unknown form-list case']]]]]

    [log-abort [text 'form-to-type unknown form case']]]]

[defn half [i [i32]] [i32] [intrinsic i32.shr-s i 1]]

[def context-kind-func [i32 1]]

[defn form-to-top [gctx [pmem [global-context]] f [pmem [form]]] [tuple]
  [ifs
    [form-word-is f]
    [do
      [log-abort [text 'form-to-top word case not implemented']]]

    [form-list-is f]
    [let [fl [form-list-get f]
          n [list-size fl]
          n-args [dec n]]
      [if [eq n 0]
        [log-abort [text 'form-to-top empty list not allowed']]]
      [let [fw [form-word-get [list-get fl 0]]]
        [ifs
          [word-eq fw [static-list [text defn]]]
          [do
            [if [lt-s n-args 3]
              [log-abort [text 'form-to-top defn expects at least 3 arguments']]]
            [let
              [fname [form-word-get [list-get fl 1]]
               param-list [form-list-get [list-get fl 2]]
               result-type [form-to-type gctx [list-get fl 3]]
               n-of-param-forms [list-size param-list]
               lctx [local-context-alloc context-kind-func local-context-empty [half n-of-param-forms]]
               locals-array [list-data-array [pfield lctx locals]]
               ]
              [if [is-odd n-of-param-forms]
                [log-abort [text 'form-to-top defn expects a parameter list with names and type pairs']]]
              [loop [i 0]
                [when [lt-s i [dec n-of-param-forms]]
                  [let
                    [lname [form-word-get [list-get param-list i]]
                     ltype [form-to-type gctx [list-get param-list [inc i]]]]
                    [assign
                      [index [index [deref locals-array] [half i]] [i32 0]] lname
                      [tuple lname ltype]]
                    [continue i [add 2 i]]]]]
              [loop [j 4]
                [when [lt-s j n]
                  [form-to-exp gctx lctx [list-get fl j]]
                  [continue j [inc j]]]]]]

          [word-eq fw [static-list [text def]]]
          [do
            [if [ne n-args 2]
              [log-abort [text 'form-to-top def expects a name and an expression']]]
            [let
              [dname [form-word-get [list-get fl 1]]
               exp [form-to-exp gctx local-context-empty [list-get fl 2]]]]]

          [word-eq fw [static-list [text export]]]
          [do
            [if [lt-s n-args 1]
              [log-abort [text 'form-to-top export expects at least 1 arguments']]]
            [do
              [loop [k 1]
                [when [lt-s k n]
                  [form-word-get [list-get fl k]]
                  [continue k [inc k]]]]]]

          [log-abort [text 'form-to-top unknown form-list case']]]]]

    [log-abort [text 'form-to-top unknown form case']]]]

[export form-to-top]
