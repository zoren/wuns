[macro comment [.. -] []]

[func list [.. l] l]

[macro constant-id [name]
  [list [quote constant] name [list [quote quote] name]]]

[constant-id 0]
[constant-id 1]
[constant-id 2]
[constant-id 3]

[func inc [x] [add x 1]]

[func dec [x] [sub x 1]]

[func not [c] [eqz c]]

[func is-zero [x] [eqz x]]

[func is-odd [x] [bit-and x 1]]

[func is-even [x] [not [is-odd x]]]

[func is-negative [x] [lt x 0]]

[func first [l] [at l 0]]
[func second [l] [at l 1]]
[func third [l] [at l 2]]

[func rest [l] [slice l 1 [size l]]]

[func concat [.. lists]
  [let [result [mutable-list]
        s-lists [size lists]]    
    [loop [i 0]
      [if [lt i s-lists]
        [let [list [at lists i]
              s-list [size list]]
          [if [not [is-list list]]
            [let []
              [log [list [quote [concat not a list]] list]]
              [abort]]
            []
          ]
          [loop [j 0]
            [if [lt j s-list]
              [let []
                [push result [at list j]]
                [cont [inc j]]]
              []]]
          [cont [inc i]]]
        [freeze result]]]]]

[macro do [.. forms]
  [concat [quote [let []]] forms]]

[macro when [cond .. forms]
  [list
    [quote if] cond
    [concat [quote [do]] forms]
    []]]

[macro when-not [cond .. forms]
  [list
    [quote if] cond
    []
    [concat [quote [do]] forms]]]

[macro assert [cond .. lmsg]
  [list [quote when-not] cond
    [list [quote log] [list [quote quote] [concat [list [quote assert-fail]] lmsg]]]
    [quote [abort]]]]

[macro ifs [.. clauses]
  [let [s [size clauses]]
    [assert [not [is-zero s]] ifs requires an odd number of arguments]
    [if [eq s 1]
        [first clauses]
        [list [quote if] [first clauses]
          [second clauses]
          [concat [quote [ifs]] [slice clauses 2 [size clauses]]]]]]]

[macro and [.. clauses]
  [let [s [size clauses]]
    [ifs
      [is-zero s]
      1

      [eq s 1]
      [first clauses]

      [let [gs [gensym]]
        [list [quote let] [list gs [first clauses]]
          [list [quote if] gs
            [concat [quote [and]] [rest clauses]]
            gs]]]]]]

[macro or [.. clauses]
  [let [s [size clauses]]
    [ifs
      [is-zero s]
      0

      [eq s 1]
      [first clauses]

      [let [gs [gensym]]
        [list [quote let] [list gs [first clauses]]
          [list [quote if] gs
            gs
            [concat [quote [or]] [rest clauses]]]]]]]]

[func concat-lists [lists]
  [let [res [mutable-list] s [size lists]]
    [loop [i 0]
      [when [lt i s]
        [let [l [at lists i]]
          [loop [j 0]
            [when [lt j [size l]]
              [push res [at l j]]
              [cont [inc j]]]]
          [cont [inc i]]]]]
    [freeze res]]]

[log [concat-lists [quote [[1 2] [3 4]]]]]

[func u32-word-to-leb-128 [w]
  [assert [not [is-negative w]] expected 32 bit ints]
  [let [res [mutable-list]]
    [loop [n w]
    [let
      [byte [bit-and n [quote 127]]
       nn [bit-shift-right-signed n [quote 7]]]
      [if [is-zero nn]
        [do
          [push res byte]
          [freeze res]]
        [do
          [push res [bit-or byte [quote 128]]]
          [cont nn]]]]]]]

[func s32-word-to-leb-128 [value]
  [let [res [mutable-list]]
    [loop [value1 value]
      [let
        [byte [bit-and value1 [quote 127]]
         value2 [bit-shift-right-signed value1 [quote 7]]
         sign-bit [bit-and byte [quote 64]]]
        [if [or [and [is-zero value2]       [not sign-bit]]
                [and [eq value2 [quote -1]] sign-bit]]
          [push res byte]
          [do
            [push res [bit-or byte [quote 128]]]
            [cont value2]]]]]
    [freeze res]]]

[func reverse [l]
  [let [res [mutable-list]]
    [loop [i [dec [size l]]]
      [when-not [is-negative i]
        [push res [at l i]]
        [cont [dec i]]]]
    [freeze res]]]

[constant ascii-x [quote 120]]

[func dec-word-to-hex-word [dw]
  [assert [not [is-negative dw]] expected non-negative decimal word]
  [if [is-zero dw]
    [quote 0x0]
    [let [hex-digits [quote 0123456789abcdef]
          res [mutable-list]]
      [loop [n dw]
        [if [is-zero n]
          [do
            [push res ascii-x]
            [push res [quote 48]]
            [word-from-codepoints [reverse res]]]
          [let [remainder [bit-and n [quote 15]]
                quotient [bit-shift-right-signed n [quote 4]]]
            [push res [at hex-digits remainder]]
            [cont quotient]]]]]]]

[func dec-words-to-hex [decs]
  [let [res [mutable-list] s [size decs]]
    [loop [i 0]
      [if [lt i s]
        [do
          [push res [dec-word-to-hex-word [at decs i]]]
          [cont [inc i]]]
        [freeze res]]]]]

[func eq-word [a b]
  [and [eq [size a] [size b]]
    [loop [i 0]
      [if [lt i [size a]]
        [if [eq [at a i] [at b i]]
          [cont [inc i]]
          0]
        1]]]]

[func = [a b]
  [if
    [and [is-word a] [is-word b]]
    [eq-word a b]

    [and [is-list a] [is-list b]
      [let [s [size a]]
        [and [eq s [size b]]
          [loop [i [quote 0]]
            [or [ge i s]
              [and [= [at a i] [at b i]] [cont [inc i]]]]]]]]]]

[func test [expected actual]
  [when-not [= expected actual]
    [log [list [quote expected] expected [quote [but got]] actual]]]]

[comment wikipedia says 0xe5 0x8e 0x26]

[test [quote [0xe5 0x8e 0x26]] [dec-words-to-hex [u32-word-to-leb-128 [quote 624485]]]]

[comment wikipedia says 0xc0 0xbb 0x78]

[test [quote [0xc0 0xbb 0x78]] [dec-words-to-hex [s32-word-to-leb-128 [quote -123456]]]]

[constant i32.const [quote 65]]
[constant local.get [quote 32]]

[func constant [n]
  [concat [i32.const] [s32-word-to-leb-128 n]]]

[func lookup [ctx sym]
  [let [s [size ctx]]
    [loop [i [quote 0]]
      [if [ge i s]
        []
        [let [k [at ctx i]
              v [at ctx [inc i]]]
          [if [eq k sym]
            v
            [cont [add i 2]]]]]]]]

[func get-local-index [ctx sym]
  [let [s [size ctx]]
    [loop [i [sub s 2]]
      [if [lt i [quote -1]]
        [abort]
        [let [k [at ctx i]]
          [if [eq-word k sym]
            [bit-shift-right-signed i 1]
            [cont [sub i 2]]]]]]]]

[constant local.get [quote 32]]

[constant i32.const [quote 65]]

[constant instructions
  [quote
    [name i32.add op-code 0x6a parameters [i32 i32] results [i32]]
    [name i32.sub op-code 0x6b parameters [i32 i32] results [i32]]]]

[func get-opcode [name]
  []
]

[func comp-form [ctx form]
  [if [is-word form]
    [let [i [get-local-index ctx form]]
      [concat [list local.get] [u32-word-to-leb-128 i]]]
    [let [inst [first form]
          args [rest form]]
      [ifs
        [eq-word inst [quote i32.add]]
        [concat [comp-form ctx [first args]] [comp-form ctx [second args]] [quote [0x6a]]]

        [eq-word inst [quote i32.sub]]
        [concat [comp-form ctx [first args]] [comp-form ctx [second args]] [quote [0x6b]]]

        [log [quote error]]]]]]

[func compile-form [ctx form]

]

[func type-function [params results]
  [concat
    [quote [0x60]]
    [u32-word-to-leb-128 [size params]]
    params
    [u32-word-to-leb-128 [size results]]
    results]]

[func code [locals instructions]
  [assert [is-zero [size locals]] locals not supported yet]
  [let
    [bytes
      [concat
        [u32-word-to-leb-128 [size locals]]
        [comment missing locals here]
        instructions]]
    [concat [u32-word-to-leb-128 [size bytes]] bytes]]]

[func vector-section [section-id content]
  [concat [list section-id] [u32-word-to-leb-128 [size content]] content]]

[func type-section [.. types]
  [vector-section 1 [concat [u32-word-to-leb-128 [size types]] [concat-lists types]]]]

[func func-section [.. func-indexes]
  [vector-section 3 [concat [u32-word-to-leb-128 [size func-indexes]] func-indexes]]]

[func index-of-word [words word]
  [let [s-words [size words]]
    [loop [i 0]
      [if [lt i s-words]
        [if [eq-word word [at words i]]
          i
          [cont [inc i]]]
        [quote -1]]]]]

[func kind-to-tag [kind]
  [let [index [index-of-word [quote function memory global] kind]]
    [assert [not [is-negative index]] kind-to-tag unexpected kind]
    index]]

[func export-section [.. exports]
  [vector-section [quote 7]
    [concat
      [u32-word-to-leb-128 [size exports]]
      [concat-lists exports]]]]

[func code-section [.. codes]
  [vector-section [quote 10] [concat [u32-word-to-leb-128 [size codes]] [concat-lists codes]]]]

[constant i32 [quote 0x7f]]
[constant end [quote 0x0b]]

[func word-to-codepoints [w]
  [let [ml [mutable-list]]
    [loop [i 0]
      [when [lt i [size w]]
        [push ml [at w i]]
        [cont [inc i]]]]
    [freeze ml]]]

[func export [name kind index]
  [concat
    [u32-word-to-leb-128 [size name]]
    [word-to-codepoints name]
    [list [kind-to-tag kind]]
    [u32-word-to-leb-128 index]]]

[func module []
  [comment wasm magic and version 1]
  [concat
    [quote [0 97 115 109
            1 0 0 0]]
    [type-section
      [type-function [list i32 i32] [list i32]]]
    
    [func-section 0 0]

    [export-section
      [export [quote add] [quote function] 0]
      [export [quote sub] [quote function] 1]]

    [code-section
      [code []
        [concat 
          [comp-form [quote [x [param i32] y [param i32]]] [quote [i32.add x y]]]
          [list end]]]    
      [code []
        [concat 
          [comp-form [quote [x [param i32] y [param i32]]] [quote [i32.sub x y]]]
          [list end]]]]]]

[log [module]]

[let
  [wm [wasm-module [module]]
   wi [wasm-instance wm]]
  [wasm-import-func wi add my-add]
  [wasm-import-func wi sub my-sub]]

[log [my-add 2 1]]
[log [my-add 0 1]]
[log [my-add 1 3]]

[log [my-sub 2 1]]
[log [my-sub 0 1]]
[log [my-sub 1 3]]
