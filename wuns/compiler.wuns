[macro comment [.. -] []]

[func list [.. l] l]

[macro global-id [name]
  [list [quote global] name [list [quote quote] name]]]

[global-id 0]
[global-id 1]
[global-id 2]
[global-id 3]

[func inc [x] [add x 1]]

[func dec [x] [sub x 1]]

[func not [c] [eqz c]]

[func is-zero [x] [eqz x]]

[func is-odd [x] [bit-and x 1]]

[func is-even [x] [not [is-odd x]]]

[func is-negative [x] [lt x 0]]

[func first [l] [at l 0]]
[func second [l] [at l 1]]
[func third [l] [at l 2]]

[func rest [l] [slice l 1 [size l]]]

[macro do [.. forms]
  [concat [quote [let []]] forms]]

[macro when [cond .. forms]
  [list
    [quote if] cond
    [concat [quote [do]] forms]
    []]]

[macro when-not [cond .. forms]
  [list
    [quote if] cond
    []
    [concat [quote [do]] forms]]]

[macro assert [cond .. lmsg]
  [list [quote when-not] cond
    [list [quote log] [list [quote quote] [concat [list [quote assert-fail]] lmsg]]]
    [quote [abort]]]]

[macro ifs [.. clauses]
  [let [s [size clauses]]
    [assert [not [is-zero s]] ifs requires an odd number of arguments]
    [if [eq s 1]
        [first clauses]
        [list [quote if] [first clauses]
          [second clauses]
          [concat [quote [ifs]] [slice clauses 2 [size clauses]]]]]]]

[macro and [.. clauses]
  [let [s [size clauses]]
    [ifs
      [is-zero s]
      1

      [eq s 1]
      [first clauses]

      [let [gs [gensym]]
        [list [quote let] [list gs [first clauses]]
          [list [quote if] gs
            [concat [quote [and]] [rest clauses]]
            gs]]]]]]

[macro or [.. clauses]
  [let [s [size clauses]]
    [ifs
      [is-zero s]
      0

      [eq s 1]
      [first clauses]

      [let [gs [gensym]]
        [list [quote let] [list gs [first clauses]]
          [list [quote if] gs
            gs
            [concat [quote [or]] [rest clauses]]]]]]]]

[func u32-word-to-leb-128 [w]
  [assert [not [is-negative w]] expected 32 bit ints]
  [let [res [mutable-list]]
    [loop [n w]
    [let
      [byte [bit-and n [quote 127]]
       nn [bit-shift-right-signed n [quote 7]]]
      [if [is-zero nn]
        [do
          [push res byte]
          [freeze res]]
        [do
          [push res [bit-or byte [quote 128]]]
          [cont nn]]]]]]]

[func dec-word-to-hex-word [dw]
  [assert [not [is-negative dw]] expected non-negative decimal word]
  [if [is-zero dw]
    [quote [48]]
    [let [hex-digits [quote 0123456789abcdef]]
      [loop [n dw
             res []]
        [if [is-zero n]
          [word-from-codepoints res]
          [let [remainder [bit-and n [quote 15]]
                quotient [bit-shift-right-signed n [quote 4]]]
            [cont quotient [concat [list [at hex-digits remainder]] res]]]]]]]]

[func dec-words-to-hex [decs]
  [let [res [mutable-list] s [size decs]]
    [loop [i 0]
      [if [lt i s]
        [do
          [push res [dec-word-to-hex-word [at decs i]]]
          [cont [inc i]]]
        [freeze res]]]]]

[comment wikipedia says 0xe5 0x8e 0x26]
[log [dec-words-to-hex [u32-word-to-leb-128 [quote 624485]]]]

[func write-unsigned-leb-128 [output-buffer n] [comment return number of bytes written]
  [loop [n n]
    [let 
      [byte [bit-and n [quote 127]]
       n [slr]]

    ]
  ]]

[func write-signed-leb-128 [output-buffer n] [comment return number of bytes written]
  []]