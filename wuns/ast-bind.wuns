[load std.wuns]
[load interpreter-externs.wuns]

[type syntax-word []
  [record
    [word word]
    [opt-form [option form]]]]

[type btype []
  [union
    [var syntax-word]
    [func [list btype] [option btype] btype]
    [apply syntax-word [list btype]]
    [memory syntax-word [option syntax-word]]
    [error]]]

[type btype-scheme []
  [record
    [type-params [list syntax-word]]
    [type btype]]]

[type type-decl-kind []
  [union
    [union [list [pair syntax-word [list btype]]]]
    [record [list [pair syntax-word btype]]]]]

[type type-decl []
  [record
    [name syntax-word]
    [type-params [list syntax-word]]
    [kind type-decl-kind]]]

[type match-pattern [] [record [ctor syntax-word] [params [list syntax-word]]]]

[type literal []
  [union
    [i32 syntax-word]
    [f64 syntax-word]
    [word syntax-word]]]

[type
  intrinsic-memargs []
  [record
    [memory syntax-word]
    [offset syntax-word]
    [align syntax-word]]]

[todo in match allow multiple patterns for one branch]
[type
  bfunc []
  [record
    [name syntax-word]
    [parameters [list syntax-word]]
    [rest-param [option syntax-word]]
    [body [list bexp]]]

  intrinsic-args []
  [union
    [bin bexp bexp]
    [load intrinsic-memargs bexp]
    [store intrinsic-memargs bexp bexp]
    [none]]

  bexp []
  [union
    [var syntax-word]
    [literal literal]
    [intrinsic syntax-word intrinsic-args]

    [func bfunc]

    [if bexp bexp bexp]
    [do [list bexp]]
    [switch bexp [list [pair [list bexp] bexp]] bexp]
    [match bexp [list [pair match-pattern bexp]] [option bexp]]
    [letfn [list bfunc] [list bexp]]
    [let [list [pair syntax-word bexp]] [list bexp]]
    [loop [list [pair syntax-word bexp]] [list bexp]]
    [continue [list [pair syntax-word bexp]]]
    [call bexp [list bexp]]
    [call-fexpr bexp [list form]]
    ]]

[type bdefunc-kind []
  [union [func] [fexpr] [macro]]]

[type btop []
  [union
    [defunc bdefunc-kind bfunc]
    [type [list type-decl]]
    [def syntax-word bexp]
    [do [list btop]]
    [export [list syntax-word]]
    [import syntax-word syntax-word btype-scheme]
    [memory syntax-word syntax-word [option syntax-word]]
    [load syntax-word]
    ]]

[defn bexp-recur [f]
  [func go [bform]
    [when
      [f bform]
      [match bform
        [bexp/var sw]
        [do]

        [bexp/literal l]
        [do]

        [bexp/intrinsic w ic]
        [match ic
          [intrinsic-args/bin a b] [do [go a] [go b]]
          [intrinsic-args/load ma a] [go a]
          [intrinsic-args/store ma a b] [do [go a] [go b]]
          [intrinsic-args/none] [do]

          [logq-abort bexp-recur not implemented]]

        [bexp/call fn args]
        [do
          [go fn]
          [for-each a args [go a]]]

        [bexp/if c t e]
        [do [go c] [go t] [go e]]

        [bexp/do bs]
        [for-each b bs [go b]]

        [bexp/let bs body]
        [do
          [for-each b bs [go [pair/snd b]]]
          [for-each b body [go b]]]

        [bexp/loop bs body]
        [do
          [for-each b bs [go [pair/snd b]]]
          [for-each b body [go b]]]

        [bexp/continue ass]
        [for-each as ass
          [go [pair/snd as]]]

        [do
          [log bform]
          [logq-abort bform-recur not implemented]]]]]]

[type local-var-kind []
  [union
    [param word i32]
    [match-param]
    [let]
    [loop]
    [letfn]
    [func-internal-self]]]

[type local-context-kind []
  [union
    [let]
    [loop]
    [letfn]
    [match]
    [func]]]

[type local-context [v]
  [record
    [vars [transient-kv-map word v]]
    [kind local-context-kind]]]

[type local-stack [v]
  [union
    [empty]
    [frame [local-stack v] [local-context v]]]]

[defn try-get-local [lstack w]
  [match lstack
    [local-stack/empty] [option/none]
    [local-stack/frame outer lctx]
      [match [try-get [local-context/vars lctx] w]
        [option/none] [try-get-local outer w]
        [option/some kind] [option/some kind]]]]

[type record-desc []
  [record
    [name syntax-word]
    [type-params [list syntax-word]]
    [fields [list [pair syntax-word btype]]]]]

[type union-desc []
  [record
    [name syntax-word]
    [type-params [list syntax-word]]
    [ctors [list [pair syntax-word [list btype]]]]]]

[type def-desc []
  [union
    [defunc bdefunc-kind]
    [any]

    [type]
    [union-ctor union-desc i32]
    [record-ctor] [record-proj record-desc i32]
    [import syntax-word btype-scheme]
    [memory i32]]]

[type diagnostic-severity []
  [union [error] [warning] [information] [hint]]]

[type report-message []
  [record
    [message form]
    [form form]
    [severity diagnostic-severity]]]

[defn builtin-type-arity-ok [type-name n-of-type-args]
  [switch type-name
    [[word tuple]] [option/some true]
    [[word i32] [word f64] [word word]] [option/some [eq n-of-type-args 0]]
    [[word list]] [option/some [eq n-of-type-args 1]]
    [[word memory]] [option/some [or [eq n-of-type-args 1] [eq n-of-type-args 2]]]
    [option/none]]]

[defn is-reserved-type-name [type-name]
  [switch type-name
    [[word type-scheme] [word func]] true

    [if-let [arity [builtin-type-arity-ok type-name 0]]
      true
      false]]]

[defn log-report-message [error]
  [log-location [report-message/form error]]
  [log [report-message/message error]]]

[defn sword [form]
  [if-let [w [try-get-word form]]
    [syntax-word
      w
      [option/some form]]
    [logq-abort sword expected word]]]

[defn try-get-enclosing-loop-context [lstack]
  [match lstack
    [local-stack/empty] [option/none]

    [local-stack/frame outer lctx]
    [match [local-context/kind lctx]
      [local-context-kind/loop] [option/some lctx]
      [local-context-kind/func] [option/none]

      [try-get-enclosing-loop-context outer]]]]

[type syntax-info []
  [record
    [try-get-ldesc [func [form] [option [pair local-var-kind form]]]]
    [try-get-def-desc [func [syntax-word] [option def-desc]]]
    [try-get-form [func [js-value] [option form]]]
    [try-get-top [func [word] [option btop]]]]]

[defn shake-tops [sinfo btops]
  [let [tgdd [syntax-info/try-get-def-desc sinfo]
        tgt [syntax-info/try-get-top sinfo]
        ddescs [growable-list]
        def-names [set]]
    [letfn [
      [func add-def-exp [bform]
        [match bform
          [bexp/intrinsic w ic]
          [match ic
            [intrinsic-args/load ma a] [add-def-name [syntax-word/word [intrinsic-memargs/memory ma]]]
            [intrinsic-args/store ma a b] [add-def-name [syntax-word/word [intrinsic-memargs/memory ma]]]
            [do]
            ]

          [bexp/var sw]
          [when-let [ddesc [tgdd sw]]
            [add-def-name [syntax-word/word sw]]]

          [do]]
        true]
      [func add-def-name [name]
        [when-not [set-has def-names name]
          [if-let [btop [tgt name]]
            [do
              [match btop
                [btop/memory name min-size opt-max-size]
                [do]

                [btop/def k bfunc]
                [do]

                [btop/defunc k bfunc]
                [for-each b [bfunc/body bfunc]
                  [[bexp-recur add-def-exp] b]]

                [do
                  [log btop]
                  [logq-abort shake-tops only supports function exports now]]]
              [push ddescs btop]]
            [logq-abort shake-tops def name not found]]
          [set-add def-names name]]]
      ]
    [for-each btop btops
      [match btop
        [btop/export snames]
        [do
          [for-each sname snames
            [add-def-name [syntax-word/word sname]]]
          [push ddescs btop]]

        [do]]]]
    [clone-growable-to-frozen-list ddescs]]]

[type form-to-ast-converter []
  [record
    [form-to-top-async [func [form] [promise btop]]]
    [form-to-exp [func [form] bexp]]
    [errors [growable-list report-message]]
    [syntax-info syntax-info]]]

[defn is-i32-bin-inst [w2]
  [switch w2
    [[word i32.add] [word i32.sub] [word i32.mul] [word i32.rem-s] [word i32.div-s]
     [word i32.and] [word i32.or] [word i32.xor]
     [word i32.shl] [word i32.shr-s] [word i32.shr-u]
     [word i32.eq] [word i32.lt-s] [word i32.le-s]]
    true
    false]]

[defn is-f64-bin-inst [w2]
  [switch w2
    [[word f64.add] [word f64.sub] [word f64.mul]] true
    false]]

[defn is-f64-comp-inst [w2]
  [switch w2
    [[word f64.eq] [word f64.lt] [word f64.le]] true
    false]]

[defn mk-form-to-ast []
  [let
    [evaluator [make-evaluator]
     errors [growable-list]
     push-error [func pe [form msg] [push errors [report-message msg form [diagnostic-severity/error]]]]
     def-ctx [transient-kv-map]
     name-to-top [transient-kv-map]
     node-to-ldesc [transient-kv-map]
     node-to-def-desc [transient-kv-map]
     try-get-word-report
     [func gw [form]
      [match form
        [form/word w] [option/some w]
        [do
          [push-error form [quote [expected word]]]
          [option/none]]]]
     get-word
     [func gw [form]
      [if-let [w [try-get-word-report form]]
        w
        [word ---word-not-found---]]]
     get-sword
     [func gw [form]
      [if-let [w [try-get-word-report form]]
        [sword form]
        [syntax-word [word ---word-not-found---] [option/none]]]]
     get-list
     [func gl [form]
      [match form
        [form/list l] l
        [do
          [push-error form [quote [expected list]]]
          [list]]]]
    set-local
    [func sl [lvars f kind]
      [let [w [get-word f]]
        [when [has lvars w] [push-error f [quote [redeclaring local]]]]
        [let [lvar-desc [pair kind f]]
          [set-kv-map lvars w lvar-desc]
          [set-kv-map node-to-ldesc f lvar-desc]]]]
    set-def
    [func sd [f kind]
      [let [w [get-word f]]
        [when [has def-ctx w] [push-error f [quote [redefing def]]]]
        [set-kv-map def-ctx w kind]]]
    set-def-form
    [func sdf [wf btop]
      [set-kv-map name-to-top [get-word wf] btop]
      btop]
    try-bind-get-ddesc
    [func tbdd [sw]
      [let [opt-ddesc [try-get def-ctx [syntax-word/word sw]]]
        [when-let [ddesc opt-ddesc] [set-kv-map node-to-def-desc sw ddesc]]
        opt-ddesc]]
    type-ctx [transient-kv-map]
    set-type
    [func st [f arity]
      [let [w [get-word f]]
        [if [is-reserved-type-name w]
          [push-error f [quote [type name is reserved]]]
          [do
            [when [has type-ctx w] [push-error f [quote [redefing type]]]]
            [set-kv-map type-ctx w arity]]]]]
    parse-param-list
    [func ppl [param-list]
      [let
        [n-of-param-forms [size param-list]]
        [if [and
              [lt-s 1 n-of-param-forms]
              [if-let [but-last-param [try-get-word [at param-list -2]]]
                [eq-word but-last-param [word ..]]
                false]]
          [pair [slice param-list 0 [sub n-of-param-forms 2]] [option/some [last param-list]]]
          [pair param-list [option/none]]]]]
    bst-to-form [transient-kv-map]
    insert-form
    [func i [form bform]
      [do
        [set-kv-map bst-to-form [to-js-value bform] form]
        bform]]
    mem-counter-atom [atom 0]]
    [letfn [
      [func mk-form-to-type [type-param-map]
        [func f2t [form]
          [match form
            [form/word w]
            [if-let [arity-ok [builtin-type-arity-ok w 0]]
              [do
                [when-not arity-ok
                  [push-error form [quote [wrong number of type arguments to builtin]]]]
                [btype/apply [sword form] [list]]]
              [if [has type-param-map w]
                [btype/var [sword form]]
                [if-let [arity [try-get type-ctx w]]
                  [do
                    [when-not [eq 0 arity]
                      [push-error form [quote [wrong number of type arguments]]]]
                    [btype/apply [sword form] [list]]]
                  [do
                    [push-error form [quote [undefined type or type param]]]
                    [btype/var [sword form]]]]]]

            [form/list l]
            [if [is-empty l]
              [do
                 [push-error form [quote [type is empty]]]
                 [btype/error]]
              [let [fw [get-word [first l]]]
                [switch fw
                  [[word type-scheme]]
                  [do
                    [push-error form [quote [does not accept type-scheme]]]
                    [btype/error]]

                  [[word func]]
                  [if [lt-s [size l] 3]
                    [do
                      [push-error form [quote [func expects a parameter list and a return type]]]
                      [btype/error]]
                    [let [parsed-params [parse-param-list [get-list [second l]]]]
                      [btype/func
                        [list-map p [pair/fst parsed-params] [f2t p]]
                        [if-let [rest-param [pair/snd parsed-params]]
                          [option/some [f2t rest-param]]
                          [option/none]]
                        [f2t [third l]]]]]

                  [let [n-of-args [dec [size l]]]
                    [if-let [arity-ok [builtin-type-arity-ok fw n-of-args]]
                      [do
                        [when-not arity-ok
                          [push-error form [quote [wrong number of type arguments to builtin]]]]
                        [if [eq-word [word memory] fw]
                          [btype/memory
                            [sword [second l]]
                            [if [lt-s 2 [size l]]
                              [option/some [sword [third l]]]
                              [option/none]]]
                          [btype/apply [sword [first l]] [list-map arg [rest l] [f2t arg]]]]]
                      [do
                        [if-let [arity [try-get type-ctx fw]]
                          [when-not [eq n-of-args arity]
                            [push-error form [quote [wrong number of type arguments]]]]
                          [push-error [first l] [quote [undefined type]]]]
                        [btype/apply [sword [first l]] [list-map arg [rest l] [f2t arg]]]]]]]]]]]]
      [func form-to-type [form] [[mk-form-to-type [transient-kv-map]] form]]
      [func form-to-type-param-list [form]
        [let
          [type-param-words [growable-list]
           word-to-form [transient-kv-map]]
          [for-each tpf [get-list form]
            [when-let [tpw [try-get-word-report tpf]]
              [do
                [when [has word-to-form tpw]
                  [push-error tpf [quote [duplicate type param]]]]
                [when [is-reserved-type-name tpw]
                  [push-error tpf [quote [reserved types cannot be used as type params]]]]
                [set-kv-map word-to-form tpw tpf]
                [push type-param-words [sword tpf]]]]]
          [pair
            [clone-growable-to-frozen-list type-param-words]
            word-to-form]]]
      [func form-to-type-scheme [form]
        [match form
          [form/word w]
          [btype-scheme [list] [form-to-type form]]

          [form/list l]
          [if [is-empty l]
            [do
              [push-error form [quote [type is empty]]]
              [btype-scheme [list] [btype/error]]]
            [if [eq-word [get-word [first l]] [word type-scheme]]
              [let
                [param-pair [form-to-type-param-list [second l]]]
                [btype-scheme
                  [pair/fst param-pair]
                  [[mk-form-to-type [pair/snd param-pair]] [third l]]]]
              [btype-scheme [list] [form-to-type form]]]]]]
      [func form-to-func [lstack form]
        [let
           [form-list [get-list form]
            - [when [lt-s [size form-list] 3] [push-error form [quote [function-like form expected at least 3 elements]]]]
            name [get-word [second form-list]]
            parsed-params [parse-param-list [get-list [third form-list]]]
            regular-param-forms [pair/fst parsed-params]
            opt-rest-param [pair/snd parsed-params]
            lvars [transient-kv-map]
            lctx [local-context lvars [local-context-kind/func]]
            new-lstack [local-stack/frame lstack lctx]
            counter-atom [atom 0]]
          [set-local lvars [second form-list] [local-var-kind/func-internal-self]]
          [for-each param regular-param-forms
            [set-local lvars param [local-var-kind/param name [inc-atom counter-atom]]]]
          [when-let [rest-param opt-rest-param]
            [set-local lvars rest-param [local-var-kind/param name [inc-atom counter-atom]]]]
          [insert-form form
            [bfunc
              [sword [second form-list]]
              [list-map param regular-param-forms [sword param]]
              [match opt-rest-param [option/none] [option/none] [option/some v] [option/some [sword v]]]
              [list-map f [slice form-list 3 [size form-list]] [form-to-ast new-lstack f]]]]]]
      [func form-to-top-eval-async [form]
        [let [btop [form-to-top form]]
          [insert-form form btop]
          [match btop
            [btop/do bs]
            [if [is-empty bs]
              [promise-resolve btop]
              [logq-abort form-to-top-eval-async do at top level not supported]]

            [btop/load file-name]
            [promise-bind
              [read-parse-file-async [syntax-word/word file-name]]
              [func then [forms]
                [promise-then
                  [promises-seq forms form-to-top-eval-async]
                  [func f [bforms] [btop/do bforms]]]]]

            [promise-then
              [evaluate-top-async evaluator form]
              [func t [r] btop]]]]]
      [func form-to-top [form]
        [let
          [report-error [func r [msg] [push-error form msg]]]
          [match form
          [form/word w]
          [logq-abort form-to-top word form not implemented]

          [form/list l]
          [let [n-of-args [dec [size l]]
                assert-n-args [func ana [n] [when-not [eq n-of-args n] [report-error [quote [expected n-of-args arguments]]]]]
                get-arg [func get-arg [i] [if [lt-s i n-of-args] [at l [inc i]] [quote 0]]]
                first-form [first l]]
            [match first-form
              [form/word first-word]
              [switch first-word
                [[word do]]
                [btop/do [list-map arg [rest l] [form-to-top arg]]]

                [[word def]]
                [let [name-form [get-arg 0]]
                  [assert-n-args 2]
                  [set-def name-form [def-desc/any]]
                  [set-def-form name-form
                    [btop/def [sword name-form] [form-to-ast [local-stack/empty] [third l]]]]]

                [[word defn] [word defexpr] [word defmacro]]
                [let [name-form [get-arg 0]
                      f2f [form-to-func [local-stack/empty] form]
                      def-desc
                      [switch first-word
                        [[word defn]] [bdefunc-kind/func]
                        [[word defexpr]] [bdefunc-kind/fexpr]
                        [[word defmacro]] [bdefunc-kind/macro]
                        [logq-abort form-to-top def kind not recognized]]]
                  [set-def name-form [def-desc/defunc def-desc]]
                  [set-def-form name-form [btop/defunc def-desc f2f]]]

                [[word load]]
                [do
                  [assert-n-args 1]
                  [btop/load [get-sword [get-arg 0]]]]

                [[word type]]
                [let
                  [triples [triplewise [rest l]]
                   -
                   [for-each triple triples
                     [set-type [first triple] [size [get-list [second triple]]]]]
                   fb
                    [btop/type
                      [list-map triple triples
                        [let
                          [type-name-form [first triple]
                           stype-name [get-sword type-name-form]
                           type-name [syntax-word/word stype-name]
                           type-prefix [concat-words type-name [word /]]
                           def-prefix
                           [func dp [name desc]
                            [let [full-name [concat-words type-prefix name]]
                              [when [has def-ctx full-name]
                                [report-error [quote [redefining type thing]]]]
                              [set-kv-map def-ctx full-name desc]]]
                           param-pair [form-to-type-param-list [second triple]]
                           type-params [pair/fst param-pair]
                           type-params-map [pair/snd param-pair]
                           form-to-type-with-params [mk-form-to-type type-params-map]]
                          [type-decl
                            stype-name
                            type-params
                            [match [third triple]
                              [form/list fl]
                              [do
                                [assert [not [is-empty fl]] type decl kind form is empty]
                                [switch [get-word [first fl]]
                                  [[word union]]
                                  [let
                                    [ctors
                                      [list-map ctor [rest fl]
                                        [let [ctor-list [get-list ctor]
                                              ctor-name-form [first ctor-list]]
                                          [assert [not [is-empty ctor-list]] type decl kind union ctor is empty]
                                          [pair
                                            [sword ctor-name-form]
                                            [list-map arg [rest ctor-list] [form-to-type-with-params arg]]]]]
                                     lunion-desc [union-desc stype-name type-params ctors]]
                                    [for i 0 [size ctors]
                                      [def-prefix
                                        [syntax-word/word [pair/fst [at ctors i]]]
                                        [def-desc/union-ctor lunion-desc i]]]
                                    [type-decl-kind/union ctors]]

                                  [[word record]]
                                  [let [fields
                                        [list-map field [rest fl]
                                          [let [field-list [get-list field]
                                                field-name-form [first field-list]
                                                field-name [get-word field-name-form]]
                                            [assert [not [is-empty field-list]] type decl kind record field is empty]
                                            [pair [sword field-name-form] [form-to-type-with-params [second field-list]]]]]
                                        lrecord-desc [record-desc stype-name type-params fields]]
                                    [for i 0 [size fields]
                                      [def-prefix
                                        [syntax-word/word [pair/fst [at fields i]]]
                                        [def-desc/record-proj lrecord-desc i]]]
                                    [set-def [first triple] [def-desc/record-ctor]]
                                    [type-decl-kind/record fields]]

                                  [logq-abort unknown type kind]]]

                              [logq-abort form-to-type-decl-kind not implemented]]]]]]]
                  fb]

                [[word export]]
                [btop/export
                  [list-map f [rest l]
                    [let [sw [get-sword f]]
                      [if-let [ddesc [try-get def-ctx [syntax-word/word sw]]]
                        [set-kv-map node-to-def-desc sw ddesc]
                        [push-error f [quote [not a defined name]]]]
                      sw]]]

                [[word import]]
                [let [module-name [get-sword [get-arg 0]]
                      module-import-form [get-arg 1]
                      module-import [get-sword module-import-form]
                      import-type [form-to-type-scheme [get-arg 2]]]
                  [set-def module-import-form [def-desc/import module-name import-type]]
                  [set-def-form module-import-form
                    [btop/import
                      module-name
                      module-import
                      import-type]]]

                [[word memory]]
                [let
                  [name-form [get-arg 0]
                   mem-name [get-sword name-form]
                   mem-min-size [get-sword [get-arg 1]]
                   mem-index [inc-atom mem-counter-atom]]
                  [set-def name-form [def-desc/memory mem-index]]
                  [set-def-form name-form
                    [btop/memory mem-name mem-min-size [option/none]]]]

                [if-let [ddesc [try-get def-ctx first-word]]
                  [do
                    [set-kv-map node-to-def-desc [get-sword first-form] ddesc]
                    [match ddesc
                      [def-desc/defunc defunc-desc]
                      [match defunc-desc
                        [bdefunc-kind/macro]
                        [if-let [macro-func [try-get-macro evaluator first-word]]
                          [form-to-top [apply macro-func [rest l]]]
                          [logq-abort form-to-top macro not found]]

                        [logq-abort form-to-top func/fexpr call at top level not supported]]

                      [do
                        [report-error [quote [call at top level not supported]]]
                        [btop/do [list]]]]]
                  [do
                    [report-error [quote [undefined word]]]
                    [btop/do [list]]]]]

              [form/list fl]
              [logq-abort direct call at top not supported]]]]]]
      [func form-to-ast [lstack form]
        [let
          [report-error [func r [msg] [push-error form msg]]
           assert-empty-stack [func aes []
            [match lstack
              [local-stack/empty] [do]
              [local-stack/frame lvars lctx] [report-error [quote [not allowed in local context]]]]]]
          [insert-form form
          [match form
          [form/word w]
          [let [sname [get-sword form]
                bf [bexp/var sname]]
            [if-let [ldesc [try-get-local lstack w]]
              [set-kv-map node-to-ldesc form ldesc]
              [if-let [ddesc [try-get def-ctx w]]
                [set-kv-map node-to-def-desc sname ddesc]
                [report-error [quote [undefined word]]]]]
            bf]

          [form/list l]
          [let [n-of-args [dec [size l]]
                assert-n-args [func ana [n] [when-not [eq n-of-args n] [report-error [quote [expected n-of-args arguments]]]]]
                get-arg [func get-arg [i] [if [lt-s i n-of-args] [at l [inc i]] [quote 0]]]
                first-form [first l]]
            [match first-form
              [form/word first-word]
              [switch first-word
                [[word i32]]
                [bexp/literal [literal/i32 [get-sword [get-arg 0]]]]

                [[word f64]]
                [bexp/literal [literal/f64 [get-sword [get-arg 0]]]]

                [[word i64] [word f32] [word v128]]
                [logq-abort form-to-ast not implemented [identity first-form]]

                [[word word]]
                [bexp/literal [literal/word [get-sword [get-arg 0]]]]

                [[word intrinsic]]
                [let [inst-sname [get-sword [get-arg 0]]
                      inst-name [syntax-word/word inst-sname]]
                  [bexp/intrinsic inst-sname
                    [if [or [is-i32-bin-inst inst-name] [is-f64-bin-inst inst-name] [is-f64-comp-inst inst-name]]
                      [do
                        [assert-n-args 3]
                        [intrinsic-args/bin [form-to-ast lstack [get-arg 1]] [form-to-ast lstack [get-arg 2]]]]
                      [let [parse-mem-args
                            [func pma []
                              [let [mem-sword [get-sword [get-arg 1]]]
                                [if-let [ddesc [try-bind-get-ddesc mem-sword]]
                                  [do]
                                  [push-error [get-arg 1] [quote [memory not bound to a def at all]]]]
                                [intrinsic-memargs
                                  mem-sword
                                  [get-sword [get-arg 2]]
                                  [get-sword [get-arg 3]]]]]]
                        [switch inst-name
                        [[word i32.load] [word i32.load8-u]]
                        [do
                          [todo we need to check the memory is deffed as a memory]
                          [assert-n-args 5]
                          [intrinsic-args/load
                            [parse-mem-args]
                            [form-to-ast lstack [get-arg 4]]]]

                        [[word i32.store] [word i32.store8]]
                        [do
                          [assert-n-args 6]
                          [intrinsic-args/store
                            [parse-mem-args]
                            [form-to-ast lstack [get-arg 4]]
                            [form-to-ast lstack [get-arg 5]]]]

                        [[word unreachable]]
                        [do
                          [assert-n-args 1]
                          [intrinsic-args/none]]

                        [do
                          [log form]
                          [logq-abort form-to-ast not implemented]]]]]]]

                [[word func]]
                [bexp/func [form-to-func lstack form]]

                [[word if]]
                [do
                  [assert-n-args 3]
                  [bexp/if [form-to-ast lstack [get-arg 0]] [form-to-ast lstack [get-arg 1]] [form-to-ast lstack [get-arg 2]]]]

                [[word switch]]
                [do
                  [when-not [is-odd [size l]] [report-error [quote [expected even number of arguments]]]]
                  [bexp/switch
                    [form-to-ast lstack [get-arg 0]]
                    [list-map p [pairwise [slice l 2 [dec [size l]]]]
                      [pair
                        [list-map v [get-list [first p]] [form-to-ast lstack v]]
                        [form-to-ast lstack [second p]]]]
                      [form-to-ast lstack [last l]]]]

                [[word match]]
                [let
                  [union-type-name-atom [atom [option/none]]
                   clauses
                   [list-map p [pairwise-pairs [slice l 2 [size l]]]
                    [let [pat-list [get-list [pair/fst p]]]
                      [do
                        [assert [not [is-empty pat-list]] match pattern is empty]
                        [let [
                          ctor-form [first pat-list]
                          ctor-sname [get-sword ctor-form]
                          params [rest pat-list]
                          lvars [transient-kv-map]
                          lctx [local-context lvars [local-context-kind/match]]
                          new-lstack [local-stack/frame lstack lctx]]
                          [if-let [ddesc [try-get def-ctx [syntax-word/word ctor-sname]]]
                            [do
                              [set-kv-map node-to-def-desc ctor-sname ddesc]
                              [match ddesc
                                [def-desc/union-ctor union-desc index]
                                [let [union-type-name [syntax-word/word [union-desc/name union-desc]]
                                      ctors [union-desc/ctors union-desc]
                                      ctor-pair [at ctors index]
                                      ctor-params [pair/snd ctor-pair]
                                      ldesc [local-var-kind/match-param]]
                                  [when-let [prev-union-type-name [atom-get union-type-name-atom]]
                                    [when-not [eq-word prev-union-type-name union-type-name]
                                      [push-error ctor-form [quote [mismatched union types]]]]]
                                  [atom-set union-type-name-atom [option/some union-type-name]]
                                  [when-not [eq [size ctor-params] [size params]]
                                    [push-error [pair/fst p] [quote [wrong number of arguments to union ctor]]]]
                                  [for i 0 [min [size ctor-params] [size params]]
                                    [set-local lvars [at params i] ldesc]]]
                                [push-error ctor-form [quote [not bound to a union constructor]]]]]
                            [push-error ctor-form [quote [not bound to def at all]]]]
                          [pair
                            [match-pattern
                              ctor-sname
                              [list-map param params [get-sword param]]]
                            [form-to-ast new-lstack [pair/snd p]]]]]]]]
                  [bexp/match
                    [form-to-ast lstack [get-arg 0]]
                    clauses
                    [if [is-odd [size l]]
                      [option/some [form-to-ast lstack [last l]]]
                      [option/none]]]]

                [[word do]]
                [bexp/do [list-map arg [rest l] [form-to-ast lstack arg]]]

                [[word loop]]
                [let
                  [bindings [get-list [get-arg 0]]
                   lvars [transient-kv-map]
                   lctx [local-context lvars [local-context-kind/loop]]
                   new-lstack [local-stack/frame lstack lctx]]
                  [when [lt-s n-of-args 2] [report-error [quote [expected at least 2 arguments]]]]
                  [bexp/loop
                    [list-map p [pairwise bindings]
                      [let [name [first p]
                            sname [get-sword name]
                            name-word [get-word name]
                            be [form-to-ast new-lstack [second p]]
                            ldesc [local-var-kind/loop]]
                        [if-let [ldesc [try-get-local lstack name-word]]
                          [push-error name [quote [let var shadows local]]]
                          [when-let [ddesc [try-get def-ctx name-word]]
                            [push-error name [quote [let var shadows def]]]]]
                        [set-local lvars name ldesc]
                        [pair sname be]]]
                    [list-map f [slice l 2 [size l]] [form-to-ast new-lstack f]]]]

                [[word continue]]
                [let [loop-vars
                        [if-let [loop-context [try-get-enclosing-loop-context lstack]]
                          [local-context/vars loop-context]
                          [do
                            [push-error form [quote [not in a loop context]]]
                            [transient-kv-map]]]]
                  [bexp/continue
                    [list-map p [pairwise-pairs [rest l]]
                      [let [name [pair/fst p]
                            sname [sword name]
                            name-word [get-word name]
                            be [form-to-ast lstack [pair/snd p]]]
                        [if-let [ldesc [try-get loop-vars name-word]]
                          [set-kv-map node-to-ldesc name ldesc]
                          [push-error name [quote [not a loop var of the current loop]]]]
                        [pair sname be]]]]]

                [[word let]]
                [let
                  [bindings [get-list [get-arg 0]]
                   lvars [transient-kv-map]
                   lctx [local-context lvars [local-context-kind/let]]
                   new-lstack [local-stack/frame lstack lctx]
                   ldesc [local-var-kind/let]]
                  [when [lt-s n-of-args 2] [report-error [quote [expected at least 2 arguments]]]]
                  [bexp/let
                    [list-map p [pairwise bindings]
                      [let [name [first p]
                            sname [get-sword name]
                            name-word [get-word name]
                            be [form-to-ast new-lstack [second p]]]
                        [if-let [ldesc [try-get-local lstack name-word]]
                          [push-error name [quote [let var shadows local]]]
                          [when-let [ddesc [try-get def-ctx name-word]]
                            [push-error name [quote [let var shadows def]]]]]
                        [set-local lvars name ldesc]
                        [pair sname be]]]
                    [list-map f [slice l 2 [size l]] [form-to-ast new-lstack f]]]]

                [[word letfn]]
                [let
                  [funcs [get-list [get-arg 0]]
                   lvars [transient-kv-map]
                   lctx [local-context lvars [local-context-kind/letfn]]
                   new-lstack [local-stack/frame lstack lctx]]
                  [when [lt-s n-of-args 2] [report-error [quote [expected at least 2 arguments]]]]
                  [for-each ff funcs
                    [let [name [second [get-list ff]]]
                      [set-local lvars name [local-var-kind/letfn]]]]
                  [bexp/letfn
                    [list-map ff funcs
                      [do
                        [todo check ff starts with func]
                        [form-to-func new-lstack ff]]]
                    [list-map f [slice l 2 [size l]] [form-to-ast new-lstack f]]]]

                [if-let [ldesc [try-get-local lstack first-word]]
                  [bexp/call [form-to-ast lstack first-form] [list-map arg [rest l] [form-to-ast lstack arg]]]
                  [if-let [ddesc [try-get def-ctx first-word]]
                    [do
                      [set-kv-map node-to-def-desc [get-sword first-form] ddesc]
                      [match ddesc
                        [def-desc/defunc defunc-desc]
                        [match defunc-desc
                          [bdefunc-kind/fexpr]
                          [bexp/call-fexpr [bexp/var [get-sword first-form]] [rest l]]

                          [bdefunc-kind/macro]
                          [if-let [macro-func [try-get-macro evaluator first-word]]
                            [form-to-ast lstack [apply macro-func [rest l]]]
                            [logq-abort form-to-top macro not found]]

                          [bexp/call [form-to-ast lstack first-form] [list-map arg [rest l] [form-to-ast lstack arg]]]]

                        [bexp/call [form-to-ast lstack first-form] [list-map arg [rest l] [form-to-ast lstack arg]]]]]
                    [do
                      [report-error [quote [undefined word]]]
                      [bexp/do [list]]]
                    ]]]

              [form/list fl]
              [bexp/call [form-to-ast lstack [first l]] [list-map arg [rest l] [form-to-ast lstack arg]]]]]]]]]]
    [form-to-ast-converter
      form-to-top-eval-async
      [func f2e [exp-form] [form-to-ast [local-stack/empty] exp-form]]
      errors
      [syntax-info
        [func try-get-ldesc [n] [try-get node-to-ldesc n]]
        [func try-get-def-desc [n] [try-get node-to-def-desc n]]
        [func try-get-form [n] [try-get bst-to-form n]]
        [func try-get-top [n] [try-get name-to-top n]]]]]]]

[defn bind-forms [converter forms]
  [let
    [f2t [form-to-ast-converter/form-to-top-async converter]]
    [promise-then
      [promises-seq forms f2t]
      [func then [btops]
        [let
          [errors [clone-growable-to-frozen-list [form-to-ast-converter/errors converter]]]

          [when-not [is-empty errors]
            [for-each error errors
              [log [report-message/message error]]
              [log [try-get-syntax-node [report-message/form error]]]]
            [logq-abort bind-forms errors]]

          btops]]]]]

[export mk-form-to-ast]
