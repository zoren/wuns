[load std.wuns]

[type type []
  [union
    [word word]
    [apply word [list type]]]]

[type type-decl-kind []
  [union
    [union [list [pair word [list type]]]]
    [record [list [pair word type]]]]]

[type type-decl []
  [record
    [name word]
    [type-params [list word]]
    [kind type-decl-kind]]]

[type match-pattern [] [record [ctor word] [params [list word]]]]

[type literal []
  [union
    [i32 word]
    [f64 word]
    [word word]]]
[type
  bfunc []
  [record
    [name word]
    [parameters [list word]]
    [rest-param [option word]]
    [body bform]]
  bform []
  [union
    [var word]
    [literal literal]
    [intrinsic word]
    [extern [list word]]
    [type [list type-decl]]

    [func bfunc]
    [if bform bform bform]
    [do [list bform]]
    [switch bform [list [pair [list bform] bform]] bform]
    [match bform [list [pair match-pattern bform]] [option bform]]
    [letfn [list bfunc] bform]
    [let [list [pair word bform]] bform]
    [def word bform]
    [defexpr bfunc]
    [defmacro bfunc]
    [call bform [list bform]]
    [call-fexpr bform [list form]]
    [type-anno bform type]
    ]]

[defn form-to-type [form]
  [match form
    [form/word w]
    [type/word w]

    [form/list l]
    [let-do [fw [form-to-word [first l]]]
      [assert [not [is-empty l]] type form-to-type is empty]
      [assert [not [eq-word fw [word type-scheme]]] type form-to-type does not accept type-scheme]
      [type/apply
        fw
        [list-map arg [rest l] [form-to-type arg]]]]]]

[defn form-to-type-decl-kind [form]
  [match form
    [form/list l]
    [do
      [assert [not [is-empty l]] type decl kind form is empty]
      [switch [form-to-word [first l]]
        [[word union]]
        [type-decl-kind/union
          [list-map ctor [rest l]
            [let-do [ctor-list [form-to-list ctor]]
              [assert [not [is-empty ctor-list]] type decl kind union ctor is empty]
              [pair
                [form-to-word [first ctor-list]]
                [list-map arg [rest ctor-list] [form-to-type arg]]]]]]

        [[word record]]
        [logq-abort form-to-type-decl-kind not implemented record]

        [logq-abort form-to-type-decl-kind not implemented]]]

    [logq-abort form-to-type-decl-kind not implemented]]]

[type report-message []
  [record
    [message form]
    [form form]]]

[type local-var-kind []
  [union
    [param]
    [match-param]
    [let]
    [letfn]
    [func-internal-self]]]

[type local-context []
  [record
    [vars [transient-kv-map word local-var-kind]]
    [binding-form form]]]

[type local-stack []
  [union
    [empty]
    [frame local-stack local-context]]]

[defn try-get-local [lstack w]
  [match lstack
    [local-stack/empty] [none]
    [local-stack/frame outer lctx]
      [match [try-get [local-context/vars lctx] w]
        [option/none] [try-get-local outer w]
        [option/some kind] [some kind]]]]

[type def-desc [] [union [func] [fexpr] [macro]]]

[type form-to-ast-converter []
  [record
    [form-to-ast [func [form] [result bform [list report-message]]]]
    [errors [growable-list report-message]]]]

[defn mk-form-to-ast []
  [let
    [eval-ctx [make-eval-context [current-dir]]
     errors [growable-list]
     push-error [func pe [form msg] [push errors [report-message msg form]]]
     def-ctx [transient-kv-map]
     get-word
     [func gw [form]
      [match form
        [form/word w] w
        [do
          [push-error form [quote [expected word]]]
          [word 0]]]]
     get-list
     [func gl [form]
      [match form
        [form/list l] l
        [do
          [push-error form [quote [expected list]]]
          [list]]]]
    set-local
    [func sl [lvars f kind]
      [let-do [w [get-word f]]
        [when [has lvars w] [push-error f [quote [redeclaring local]]]]
        [set-kv-map lvars w kind]]]
    set-def
    [func sd [f kind]
      [let-do [w [get-word f]]
        [when [has def-ctx w] [push-error f [quote [redefing def]]]]
        [set-kv-map def-ctx w kind]]]
    ]
    [letfn [
      [func form-to-func [lstack form]
          [let-do
               [form-list [get-list form]
                name [get-word [second form-list]]
                param-list [get-list [third form-list]]
                n-of-param-forms [size param-list]
                has-rest-param [and [lt-s 1 n-of-param-forms] [eq-word [get-word [at param-list -2]] [word ..]]]
                regular-param-forms [if has-rest-param [slice param-list 0 [sub n-of-param-forms 2]] param-list]
                opt-rest-param [if has-rest-param [some [last param-list]] [none]]
                lvars [transient-kv-map]
                lctx [local-context lvars form]
                new-lstack [local-stack/frame lstack lctx]]
            [for-each param regular-param-forms
              [set-local lvars param [local-var-kind/param]]]
            [when-let [rest-param opt-rest-param]
              [set-local lvars rest-param [local-var-kind/param]]]
            [bfunc
              name
              [list-map param regular-param-forms [get-word param]]
              [match opt-rest-param [option/none] [option/none] [option/some v] [option/some [get-word v]]]
              [form-to-ast new-lstack [fourth form-list]]]]]
      [func form-to-ast [lstack form]
        [let [report-error [func r [msg] [push-error form msg]]
              assert-empty-stack [func aes []
                [match lstack
                  [local-stack/empty] [do]
                  [local-stack/frame lvars lctx] [report-error [quote [not allowed in local context]]]]]]
          [match form
          [form/word w]
          [do
            [if-let [ldesc [try-get-local lstack w]]
              [do]
              [if-let [ddesc [try-get def-ctx w]]
                [do]
                [report-error [quote [undefined word]]]]]
            [bform/var [get-wordf form]]]

          [form/list l]
          [let [n-of-args [dec [size l]]
                assert-n-args [func ana [n] [when-not [eq n-of-args n] [report-error [quote [expected n-of-args arguments]]]]]
                get-arg [func get-arg [i] [if [lt-s i n-of-args] [at l [inc i]] [quote 0]]]
                first-form [first l]]
            [match first-form
              [form/word first-word]
              [switch first-word
                [[word i32]]
                [bform/literal [literal/i32 [get-word [get-arg 0]]]]

                [[word f64]]
                [bform/literal [literal/f64 [get-word [get-arg 0]]]]

                [[word word]]
                [bform/literal [literal/word [get-word [get-arg 0]]]]

                [[word extern]]
                [bform/extern [list-map w [rest l] [get-word w]]]

                [[word intrinsic]]
                [bform/intrinsic [get-word [get-arg 0]]]

                [[word func]]
                [bform/func [form-to-func lstack form]]

                [[word atom]]
                [logq-abort form-to-ast not implemented atom]

                [[word if]]
                [do
                  [assert-n-args 3]
                  [bform/if [form-to-ast lstack [get-arg 0]] [form-to-ast lstack [get-arg 1]] [form-to-ast lstack [get-arg 2]]]]

                [[word switch]]
                [do
                  [when [is-odd [size l]] [report-error [quote [expected even number of arguments]]]]
                  [bform/switch
                    [form-to-ast lstack [get-arg 0]]
                    [list-map p [pairwise [slice l 2 [dec [size l]]]]
                      [pair
                        [list-map v [get-list [first p]] [form-to-ast lstack v]]
                        [form-to-ast lstack [second p]]]]
                      [form-to-ast lstack [last l]]]]

                [[word match]]
                [bform/match
                  [form-to-ast lstack [get-arg 0]]
                  [list-map p [pairwise [slice l 2 [size l]]]
                    [let-do [pat-list [get-list [first p]]
                              lvars [transient-kv-map]
                              lctx [local-context lvars form]
                              new-lstack [local-stack/frame lstack lctx]]
                      [assert [not [is-empty pat-list]] match pattern is empty]
                      [pair
                        [match-pattern
                          [get-word [first pat-list]]
                          [list-map param [rest pat-list]
                            [do
                              [set-local lvars param [local-var-kind/match-param]]
                              [get-word param]]]]
                        [form-to-ast new-lstack [second p]]]]]
                  [if [is-odd [size l]]
                    [some [form-to-ast lstack [last l]]]
                    [none]]]

                [[word do]]
                [bform/do [list-map arg [rest l] [form-to-ast lstack arg]]]

                [[word let]]
                [let-do
                  [bindings [get-list [get-arg 0]]
                   lvars [transient-kv-map]
                   lctx [local-context lvars form]
                   new-lstack [local-stack/frame lstack lctx]]
                  [assert-n-args 2]
                  [bform/let
                    [list-map p [pairwise bindings] [pair [get-word [first p]] [form-to-ast new-lstack [second p]]]]
                    [form-to-ast new-lstack [get-arg 1]]]]

                [[word letfn]]
                [let-do
                  [funcs [get-list [get-arg 0]]
                   lvars [transient-kv-map]
                   lctx [local-context lvars form]
                   new-lstack [local-stack/frame lstack lctx]]
                  [assert-n-args 2]
                  [for-each ff funcs
                    [let [name [second [get-list ff]]]
                      [set-local lvars name [local-var-kind/letfn]]]]
                  [bform/letfn
                    [list-map ff funcs
                      [do
                        [todo check ff starts with func]
                        [form-to-func new-lstack ff]]]
                    [form-to-ast new-lstack [get-arg 1]]]]

                [[word def]]
                [do
                  [assert-n-args 2]
                  [assert-empty-stack]
                  [bform/def [get-word [get-arg 0]] [form-to-ast lstack [third l]]]]

                [[word defmacro] [word defexpr]]
                [do
                  [assert-n-args 2]
                  [assert-empty-stack]
                  [set-def [get-arg 0]
                    [switch first-word
                      [[word defexpr]] def-desc/fexpr
                      [[word defmacro]] def-desc/macro
                      [unreachable]]]
                  [bform/defmacro [form-to-func lstack form]]]

                [[word fexpr] [word macro] [word letrec]]
                [logq-abort form-to-ast [identity first-form] deprecated]

                [[word load]]
                [logq-abort form-to-ast not implemented load]

                [[word type]]
                [bform/type
                  [list-map triple [triplewise [rest l]]
                    [type-decl
                      [get-word [first triple]]
                      [list-map tv [get-list [second triple]] [get-word tv]]
                      [form-to-type-decl-kind [third triple]]]]]

                [[word type-anno]]
                [do
                  [assert-n-args 2]
                  [todo check for type-scheme]
                  [bform/type-anno
                    [form-to-ast lstack [get-arg 0]]
                    [form-to-type [get-arg 1]]]]

                [if-let [ldesc [try-get-local lstack first-word]]
                  [bform/call [form-to-ast lstack first-form] [list-map arg [rest l] [form-to-ast lstack arg]]]
                  [if-let [ddesc [try-get def-ctx first-word]]
                    [match ddesc
                      [def-desc/fexpr]
                      [bform/call-fexpr [bform/var [get-word first-form]] [rest l]]

                      [def-desc/macro]
                      [if-let [macro-func [try-get-macro eval-ctx first-word]]
                        [form-to-ast lstack [interpreter-apply macro-func [rest l]]]
                        [logq-abort form-to-ast macro not found]]

                      [def-desc/func]
                      [bform/call [form-to-ast lstack first-form] [list-map arg [rest l] [form-to-ast lstack arg]]]]
                    [do
                      [report-error [quote [undefined word]]]
                      [bform/call [form-to-ast lstack first-form] [list-map arg [rest l] [form-to-ast lstack arg]]]]]

                    ]]

              [form/list fl]
              [bform/call [form-to-ast lstack [first l]] [list-map arg [rest l] [form-to-ast lstack arg]]]]]]]]]
    [form-to-ast-converter
      [func f2a [top-form]
        [let [bform [form-to-ast [local-stack/empty] top-form]
              errors [clone-growable-to-frozen-list errors]]
          [if [is-empty errors]
            [do
              [comment eval top forms for their side effects]
              [match [evaluate-result eval-ctx top-form]
                [result/error -] [logq-abort form-to-ast error evaluating top form]
                [result/ok -] [do]]
              [result/ok bform]]
            [result/error errors]]]]
      errors]]]]
