[load std.wuns]
[load interpreter-externs.wuns]

[type btype []
  [union
    [var word]
    [func [list btype] [option btype] btype]
    [apply word [list btype]]
    [error]]]

[type btype-scheme []
  [record
    [type-params [list word]]
    [type btype]]]

[type type-decl-kind []
  [union
    [union [list [pair word [list btype]]]]
    [record [list [pair word btype]]]]]

[type type-decl []
  [record
    [name word]
    [type-params [list word]]
    [kind type-decl-kind]]]

[type match-pattern [] [record [ctor word] [params [list word]]]]

[type literal []
  [union
    [i32 word]
    [f64 word]
    [word word]]]

[type
  bfunc []
  [record
    [name word]
    [parameters [list word]]
    [rest-param [option word]]
    [body bform]]

  bform []
  [union
    [var word]
    [literal literal]
    [intrinsic word]
    [extern [list word]]
    [type [list type-decl]]

    [atom bform]
    [func bfunc]
    [if bform bform bform]
    [do [list bform]]
    [switch bform [list [pair [list bform] bform]] bform]
    [match bform [list [pair match-pattern bform]] [option bform]]
    [letfn [list bfunc] bform]
    [let [list [pair word bform]] bform]
    [def word bform]
    [defexpr bfunc]
    [defmacro bfunc]
    [call bform [list bform]]
    [call-fexpr bform [list form]]
    [type-anno bform btype-scheme]
    ]]

[type report-message []
  [record
    [message form]
    [form form]]]

[type local-var-kind []
  [union
    [param word i32]
    [match-param]
    [let]
    [letfn]
    [func-internal-self]]]

[type local-context []
  [record
    [vars [transient-kv-map word local-var-kind]]
    [binding-form form]]]

[type local-stack []
  [union
    [empty]
    [frame local-stack local-context]]]

[defn try-get-local [lstack w]
  [match lstack
    [local-stack/empty] [none]
    [local-stack/frame outer lctx]
      [match [try-get [local-context/vars lctx] w]
        [option/none] [try-get-local outer w]
        [option/some kind] [some kind]]]]

[type def-desc [] [union [fexpr] [macro] [any] [union-ctor] [record-ctor] [record-proj]]]

[type form-to-ast-converter []
  [record
    [form-to-ast [func [form] [result bform [list report-message]]]]
    [errors [growable-list report-message]]
    [node-to-ldesc [transient-kv-map bform local-var-kind]]]]

[defn builtin-type-arity-ok [type-name n-of-type-args]
  [switch type-name
    [[word tuple]] [some true]
    [[word i32] [word f64] [word word]] [some [eq n-of-type-args 0]]
    [[word list] [word atom]] [some [eq n-of-type-args 1]]
    [none]]]

[defn is-reserved-type-name [type-name]
  [switch type-name
    [[word type-scheme] [word func]] true

    [if-let [arity [builtin-type-arity-ok type-name 0]]
      true
      false]]]

[defn mk-form-to-ast []
  [let
    [eval-ctx [make-eval-context [current-dir]]
     evaluator [make-evaluator externs-object-value eval-ctx]
     errors [growable-list]
     push-error [func pe [form msg] [push errors [report-message msg form]]]
     eval-form [func ef [top-form]
      [match [evaluate-result evaluator top-form]
        [result/error error]
        [push-error top-form [quote [runtime error when evaluating form]]]

        [result/ok -]
        [do]]]
     def-ctx [transient-kv-map]
     node-to-ldesc [transient-kv-map]
     try-get-word-report
     [func gw [form]
      [match form
        [form/word w] [some w]
        [do
          [push-error form [quote [expected word]]]
          [none]]]]
     get-word
     [func gw [form]
      [if-let [w [try-get-word-report form]]
        w
        [word ---word-not-found---]]]
     get-list
     [func gl [form]
      [match form
        [form/list l] l
        [do
          [push-error form [quote [expected list]]]
          [list]]]]
    set-local
    [func sl [lvars f kind]
      [let-do [w [get-word f]]
        [when [has lvars w] [push-error f [quote [redeclaring local]]]]
        [set-kv-map lvars w kind]]]
    set-def
    [func sd [f kind]
      [let-do [w [get-word f]]
        [when [has def-ctx w] [push-error f [quote [redefing def]]]]
        [set-kv-map def-ctx w kind]]]
    type-ctx [transient-kv-map]
    set-type
    [func st [f arity]
      [let-do [w [get-word f]]
        [if [is-reserved-type-name w]
          [push-error f [quote [type name is reserved]]]
          [do
            [when [has type-ctx w] [push-error f [quote [redefing type]]]]
            [set-kv-map type-ctx w arity]]]]]
    parse-param-list
    [func parse-param-list [param-list]
      [let
        [n-of-param-forms [size param-list]]
        [if [and
              [lt-s 1 n-of-param-forms]
              [if-let [but-last-param [try-get-word [at param-list -2]]]
                [eq-word but-last-param [word ..]]
                false]]
          [pair [slice param-list 0 [sub n-of-param-forms 2]] [some [last param-list]]]
          [pair param-list [none]]]]]
    ]
    [letfn [
      [func mk-form-to-type [type-param-map]
        [func f2t [form]
          [match form
            [form/word w]
            [if-let [arity-ok [builtin-type-arity-ok w 0]]
              [do
                [when-not arity-ok
                  [push-error form [quote [wrong number of type arguments to builtin]]]]
                [btype/apply w [list]]]
              [if [has type-param-map w]
                [btype/var w]
                [if-let [arity [try-get type-ctx w]]
                  [do
                    [when-not [eq 0 arity]
                      [push-error form [quote [wrong number of type arguments]]]]
                    [btype/apply w [list]]]
                  [do
                    [push-error form [quote [undefined type or type param]]]
                    [btype/var w]]]]]

            [form/list l]
            [if [is-empty l]
              [do
                 [push-error form [quote [type is empty]]]
                 [btype/error]]
              [let-do [fw [get-word [first l]]]
                [switch fw
                  [[word type-scheme]]
                  [do
                    [push-error form [quote [does not accept type-scheme]]]
                    [btype/error]]

                  [[word func]]
                  [if [lt-s [size l] 3]
                    [do
                      [push-error form [quote [func expects a parameter list and a return type]]]
                      [btype/error]]
                    [let-do [parsed-params [parse-param-list [get-list [second l]]]]
                      [btype/func
                        [list-map p [pair/fst parsed-params] [f2t p]]
                        [if-let [rest-param [pair/snd parsed-params]]
                          [some [f2t rest-param]]
                          [none]]
                        [f2t [third l]]]]]

                  [let-do [n-of-args [dec [size l]]]
                    [if-let [arity-ok [builtin-type-arity-ok fw n-of-args]]
                      [when-not arity-ok
                        [push-error form [quote [wrong number of type arguments to builtin]]]]
                      [if-let [arity [try-get type-ctx fw]]
                        [when-not [eq n-of-args arity]
                          [push-error form [quote [wrong number of type arguments]]]]
                        [push-error form [quote [undefined type]]]]]
                    [btype/apply fw [list-map arg [rest l] [f2t arg]]]]]]]]]]
      [func form-to-type [form] [[mk-form-to-type [transient-kv-map]] form]]
      [func form-to-type-param-list [form]
        [let-do
          [type-param-words [growable-list]
           word-to-form [transient-kv-map]]
          [for-each tpf [get-list form]
            [when-let [tpw [try-get-word-report tpf]]
              [do
                [when [has word-to-form tpw]
                  [push-error tpf [quote [duplicate type param]]]]
                [when [is-reserved-type-name tpw]
                  [push-error tpf [quote [reserved types cannot be used as type params]]]]
                [set-kv-map word-to-form tpw tpf]
                [push type-param-words tpw]]]]
          [pair
            [clone-growable-to-frozen-list type-param-words]
            word-to-form]]]
      [func form-to-type-scheme [form]
        [match form
          [form/word w]
          [btype-scheme [list] [form-to-type form]]

          [form/list l]
          [if [is-empty l]
            [do
              [push-error form [quote [type is empty]]]
              [btype-scheme [list] [btype/error]]]
            [if [eq-word [get-word [first l]] [word type-scheme]]
              [let-do
                [param-pair [form-to-type-param-list [second l]]]
                [btype-scheme
                  [pair/fst param-pair]
                  [[mk-form-to-type [pair/snd param-pair]] [third l]]]]
              [btype-scheme [list] [form-to-type form]]]]]]
      [func form-to-func [lstack form]
        [let-do
           [form-list [get-list form]
            - [when-not [eq [size form-list] 4] [push-error form [quote [function-like form expected 4 sub-forms]]]]
            name [get-word [second form-list]]
            parsed-params [parse-param-list [get-list [third form-list]]]
            regular-param-forms [pair/fst parsed-params]
            opt-rest-param [pair/snd parsed-params]
            lvars [transient-kv-map]
            lctx [local-context lvars form]
            new-lstack [local-stack/frame lstack lctx]
            counter-atom [atom 0]]
          [set-local lvars [second form-list] [local-var-kind/func-internal-self]]
          [for-each param regular-param-forms
            [set-local lvars param [local-var-kind/param name [inc-atom counter-atom]]]]
          [when-let [rest-param opt-rest-param]
            [set-local lvars rest-param [local-var-kind/param name [inc-atom counter-atom]]]]
          [bfunc
            name
            [list-map param regular-param-forms [get-word param]]
            [match opt-rest-param [option/none] [option/none] [option/some v] [option/some [get-word v]]]
            [form-to-ast new-lstack [fourth form-list]]]]]
      [func form-to-ast [lstack form]
        [let [report-error [func r [msg] [push-error form msg]]
              assert-empty-stack [func aes []
                [match lstack
                  [local-stack/empty] [do]
                  [local-stack/frame lvars lctx] [report-error [quote [not allowed in local context]]]]]]
          [match form
          [form/word w]
          [let-do [bf [bform/var [get-word form]]]
            [if-let [ldesc [try-get-local lstack w]]
              [set-kv-map node-to-ldesc bf ldesc]
              [if-let [ddesc [try-get def-ctx w]]
                [do]
                [report-error [quote [undefined word]]]]]
            bf]

          [form/list l]
          [let [n-of-args [dec [size l]]
                assert-n-args [func ana [n] [when-not [eq n-of-args n] [report-error [quote [expected n-of-args arguments]]]]]
                get-arg [func get-arg [i] [if [lt-s i n-of-args] [at l [inc i]] [quote 0]]]
                first-form [first l]]
            [match first-form
              [form/word first-word]
              [switch first-word
                [[word i32]]
                [bform/literal [literal/i32 [get-word [get-arg 0]]]]

                [[word f64]]
                [bform/literal [literal/f64 [get-word [get-arg 0]]]]

                [[word i64] [word f32] [word v128]]
                [logq-abort form-to-ast not implemented [identity first-form]]

                [[word word]]
                [bform/literal [literal/word [get-word [get-arg 0]]]]

                [[word extern]]
                [bform/extern [list-map w [rest l] [get-word w]]]

                [[word intrinsic]]
                [bform/intrinsic [get-word [get-arg 0]]]

                [[word func]]
                [bform/func [form-to-func lstack form]]

                [[word atom]]
                [bform/atom [form-to-ast lstack [get-arg 0]]]

                [[word if]]
                [do
                  [assert-n-args 3]
                  [bform/if [form-to-ast lstack [get-arg 0]] [form-to-ast lstack [get-arg 1]] [form-to-ast lstack [get-arg 2]]]]

                [[word switch]]
                [do
                  [when-not [is-odd [size l]] [report-error [quote [expected even number of arguments]]]]
                  [bform/switch
                    [form-to-ast lstack [get-arg 0]]
                    [list-map p [pairwise [slice l 2 [dec [size l]]]]
                      [pair
                        [list-map v [get-list [first p]] [form-to-ast lstack v]]
                        [form-to-ast lstack [second p]]]]
                      [form-to-ast lstack [last l]]]]

                [[word match]]
                [bform/match
                  [form-to-ast lstack [get-arg 0]]
                  [list-map p [pairwise [slice l 2 [size l]]]
                    [let-do [pat-list [get-list [first p]]
                              lvars [transient-kv-map]
                              lctx [local-context lvars form]
                              new-lstack [local-stack/frame lstack lctx]]
                      [assert [not [is-empty pat-list]] match pattern is empty]
                      [pair
                        [match-pattern
                          [get-word [first pat-list]]
                          [list-map param [rest pat-list]
                            [do
                              [set-local lvars param [local-var-kind/match-param]]
                              [get-word param]]]]
                        [form-to-ast new-lstack [second p]]]]]
                  [if [is-odd [size l]]
                    [some [form-to-ast lstack [last l]]]
                    [none]]]

                [[word do]]
                [bform/do [list-map arg [rest l] [form-to-ast lstack arg]]]

                [[word let]]
                [let-do
                  [bindings [get-list [get-arg 0]]
                   lvars [transient-kv-map]
                   lctx [local-context lvars form]
                   new-lstack [local-stack/frame lstack lctx]]
                  [assert-n-args 2]
                  [bform/let
                    [list-map p [pairwise bindings]
                      [let-do [name [first p]
                               be [form-to-ast new-lstack [second p]]]
                        [set-local lvars name [local-var-kind/let]]
                        [pair [get-word name] be]]]
                    [form-to-ast new-lstack [get-arg 1]]]]

                [[word letfn]]
                [let-do
                  [funcs [get-list [get-arg 0]]
                   lvars [transient-kv-map]
                   lctx [local-context lvars form]
                   new-lstack [local-stack/frame lstack lctx]]
                  [assert-n-args 2]
                  [for-each ff funcs
                    [let [name [second [get-list ff]]]
                      [set-local lvars name [local-var-kind/letfn]]]]
                  [bform/letfn
                    [list-map ff funcs
                      [do
                        [todo check ff starts with func]
                        [form-to-func new-lstack ff]]]
                    [form-to-ast new-lstack [get-arg 1]]]]

                [[word def]]
                [do
                  [assert-n-args 2]
                  [assert-empty-stack]
                  [let-do [bf [bform/def [get-word [get-arg 0]] [form-to-ast lstack [third l]]]]
                    [set-def [get-arg 0] [def-desc/any]]
                    [eval-form form]
                    bf]]

                [[word defexpr]]
                [do
                  [assert-empty-stack]
                  [let-do [bf [bform/defexpr [form-to-func lstack form]]]
                    [set-def [get-arg 0] [def-desc/fexpr]]
                    [eval-form form]
                    bf]]

                [[word defmacro]]
                [do
                  [assert-empty-stack]
                  [let-do [bf [bform/defmacro [form-to-func lstack form]]]
                    [set-def [get-arg 0] [def-desc/macro]]
                    [eval-form form]
                    bf]]

                [[word fexpr] [word macro] [word letrec]]
                [logq-abort form-to-ast [identity first-form] deprecated]

                [[word load]]
                [do
                  [assert-empty-stack]
                  [assert-n-args 1]
                  [let-do [bforms [list-map bf [read-file [get-word [get-arg 0]]] [form-to-ast lstack bf]]]
                    [eval-form form]
                    [bform/do bforms]]]

                [[word type]]
                [let-do
                  [fb
                    [bform/type
                      [list-map triple [triplewise [rest l]]
                        [let-do
                          [type-name [get-word [first triple]]
                           type-prefix [concat-words type-name [word /]]
                           def-prefix
                           [func dp [name desc]
                            [let-do [full-name [concat-words type-prefix name]]
                              [when [has def-ctx full-name]
                                [report-error [quote [redefining type]]]]
                              [set-kv-map def-ctx full-name [def-desc/record-proj]]]]
                           param-pair [form-to-type-param-list [second triple]]
                           type-params [pair/fst param-pair]
                           type-params-map [pair/snd param-pair]
                           form-to-type-with-params [mk-form-to-type type-params-map]]
                          [set-type [first triple] [size type-params]]
                          [type-decl
                            type-name
                            type-params
                            [match [third triple]
                              [form/list l]
                              [do
                                [assert [not [is-empty l]] type decl kind form is empty]
                                [switch [get-word [first l]]
                                  [[word union]]
                                  [type-decl-kind/union
                                    [list-map ctor [rest l]
                                      [let-do [ctor-list [get-list ctor]
                                              ctor-name [get-word [first ctor-list]]]
                                        [assert [not [is-empty ctor-list]] type decl kind union ctor is empty]
                                        [def-prefix ctor-name [def-desc/union-ctor]]
                                        [pair
                                          ctor-name
                                          [list-map arg [rest ctor-list] [form-to-type-with-params arg]]]]]]

                                  [[word record]]
                                  [do
                                    [set-def [first triple] [def-desc/record-ctor]]
                                    [type-decl-kind/record
                                      [list-map field [rest l]
                                        [let-do [field-list [get-list field]
                                                 field-name [get-word [first field-list]]]
                                          [assert [not [is-empty field-list]] type decl kind record field is empty]
                                          [def-prefix field-name [def-desc/record-proj]]
                                          [pair field-name [form-to-type-with-params [second field-list]]]]]]]

                                  [logq-abort unknown type kind]]]

                              [logq-abort form-to-type-decl-kind not implemented]]]]]]]
                  [eval-form form]
                  fb]

                [[word type-anno]]
                [do
                  [assert-n-args 2]
                  [bform/type-anno
                    [form-to-ast lstack [get-arg 0]]
                    [form-to-type-scheme [get-arg 1]]]]

                [if-let [ldesc [try-get-local lstack first-word]]
                  [bform/call [form-to-ast lstack first-form] [list-map arg [rest l] [form-to-ast lstack arg]]]
                  [if-let [ddesc [try-get def-ctx first-word]]
                    [match ddesc
                      [def-desc/fexpr]
                      [bform/call-fexpr [bform/var [get-word first-form]] [rest l]]

                      [def-desc/macro]
                      [if-let [macro-func [try-get-macro eval-ctx first-word]]
                        [form-to-ast lstack [interpreter-apply macro-func [rest l]]]
                        [logq-abort form-to-ast macro not found]]

                      [bform/call [form-to-ast lstack first-form] [list-map arg [rest l] [form-to-ast lstack arg]]]]
                    [do
                      [report-error [quote [undefined word]]]
                      [bform/call [form-to-ast lstack first-form] [list-map arg [rest l] [form-to-ast lstack arg]]]]]]]

              [form/list fl]
              [bform/call [form-to-ast lstack [first l]] [list-map arg [rest l] [form-to-ast lstack arg]]]]]]]]]
    [form-to-ast-converter
      [func f2a [top-form]
        [let [bform [form-to-ast [local-stack/empty] top-form]
              errors [clone-growable-to-frozen-list errors]]
          [if [is-empty errors]
            [result/ok bform]
            [result/error errors]]]]
      errors
      node-to-ldesc]]]]

[defn map-option [f ast]
  [[func go [ast]
    [if-let [new-ast [f ast]]
      new-ast
      [match ast
        [bform/func f] [logq-abort map-option not implemented func]
        [bform/if c t e] [bform/if [go c] [go t] [go e]]
        [bform/do l] [bform/do [list-map arg l [go arg]]]
        [bform/switch c cases d] [logq-abort map-option not implemented switch]
        [bform/match c cases d] [logq-abort map-option not implemented match]
        [bform/letfn l d] [logq-abort map-option not implemented letfn]
        [bform/let l d] [bform/let [list-map p l [pair [pair/fst p] [go [pair/snd p]]]] [go d]]
        [bform/def w d] [bform/def w [go d]]
        [bform/defexpr f] [logq-abort map-option not implemented defexpr]
        [bform/defmacro f] [logq-abort map-option not implemented defmacro]
        [bform/call f args] [bform/call [go f] [list-map arg args [go arg]]]
        [bform/call-fexpr f form-args] [bform/call-fexpr [go f] form-args]
        [bform/type-anno f t] [bform/type-anno [go f] t]

        ast]]]
    ast]]

[defn substitute [ast subst]
  [map-option
    [func proc-var [bf]
      [match bf
        [bform/var w] [try-get subst w]
        [none]]]
    ast]]

[defn has-dep-on-param [node-to-ldesc arg fname param-i]
  [letfn
    [[func go [bf]
      [let [has-dep
            [if-let [ldesc [try-get node-to-ldesc bf]]
              [match ldesc
                [local-var-kind/param desc-fname desc-param-i]
                [and [eq-word fname desc-fname] [eq param-i desc-param-i]]
                false]
              false]]
        [if has-dep
          true
          [match bf
            [bform/var w] false
            [bform/literal l] false
            [bform/intrinsic w] false
            [bform/extern l] false
            [bform/type l] false

            [bform/if c t e] [or [go c] [go t] [go e]]

            [bform/do l] [exists l go]

            [bform/call f args]
            [or
              [go f]
              [exists args go]]

            [bform/call-fexpr f form-args] [go f]

            [bform/let bindings e]
            [or
              [exists bindings [func f [b] [go [pair/snd b]]]]
              [go e]]

            [do
              [log bf]
              [logq-abort has-dep-on-param not implemented]]]]]]]
    [go arg]]]

[type tail-call-result []
  [union
    [no-rec-calls]
    [non-tail]
    [only-tail [transient-kv-map bform [list i32]]]]]

[defn tail-call-analysis [node-to-ldesc the-func]
  [comment also returns a map of the tail calls so a compiler knows names of parameters to bind before continuing in a loop]
  [let-do
    [tail-rec-calls [transient-kv-map]
     non-tail-rec-calls [atom false]
     go
      [func go [is-tail bf]
        [match bf
          [bform/var w] [do]
          [bform/literal l] [do]
          [bform/intrinsic w] [do]
          [bform/extern l] [do]
          [bform/type l] [do]
          [bform/atom v] [do]

          [bform/func f] [do]
          [bform/if c t e]
          [do
            [go false c]
            [go is-tail t]
            [go is-tail e]]

          [bform/switch e cases default]
          [do
            [go false e]
            [for-each p cases [go is-tail [pair/snd p]]]
            [go is-tail default]]

          [bform/match e cases opt-default]
          [do
            [go false e]
            [for-each p cases [go is-tail [pair/snd p]]]
            [when-let [default opt-default]
              [go is-tail default]]]

          [bform/do l]
          [when-not [is-empty l]
            [for i 0 [dec [size l]] [go false [at l i]]]
            [go is-tail [last l]]]

          [bform/let bindings e]
          [do
            [for-each p bindings [go false [pair/snd p]]]
            [go is-tail e]]

          [bform/letfn fns e]
          [do
            [for-each fn fns [go false [bfunc/body fn]]]
            [go is-tail e]]

          [bform/call f args]
          [do
            [match f
              [bform/var wf]
              [when [and
                      [eq-word [bfunc/name the-func] wf]
                      [match [get node-to-ldesc f] [local-var-kind/func-internal-self] 1 0]]
                  [if is-tail
                    [let-do [dependent-args [growable-list]]
                      [for i 0 [size args]
                        [when
                          [exists [slice args [inc i] [size args]]
                            [func has-dep [arg] [has-dep-on-param node-to-ldesc arg [bfunc/name the-func] i]]]
                          [push dependent-args i]]]
                      [set-kv-map tail-rec-calls bf [clone-growable-to-frozen-list dependent-args]]]
                    [atom-set non-tail-rec-calls true]]]
              [do]]
            [for-each arg args [go false arg]]]

          [bform/call-fexpr f form-args]
          [go false f]

            [do
              [log bf]
              [logq-abort tail-call-analysis not implemented]]]]]
      [go true [bfunc/body the-func]]
      [if [atom-get non-tail-rec-calls]
        [tail-call-result/non-tail]
        [if [kv-map-size tail-rec-calls]
          [tail-call-result/only-tail tail-rec-calls]
          [tail-call-result/no-rec-calls]]]]]
