[load ast-bind.wuns]

[defn forms-to-asts [forms]
  [let [converter [mk-form-to-ast]
        f2a [form-to-ast-converter/form-to-ast converter]]
    [map-result forms
      [func f [form] [f2a form]]]]]

[defn test-ok-fn [forms]
  [let [converter [mk-form-to-ast]
        f2a [form-to-ast-converter/form-to-ast converter]]
    [match [forms-to-asts forms]
      [result/error errors]
      [do
        [log forms]
        [for-each error errors
          [log-report-message error]]
        [logq-abort test-ok there were errors]]
      [result/ok bforms] bforms]]]

[defmacro test-ok [.. forms]
  [flist [quote test-ok-fn]
    [form-concat [list [quote list]] [list-map f forms [mk-quote f]]]]]

[defn test-error-fn [expected-errors-form forms]
  [let [converter [mk-form-to-ast]
        f2a [form-to-ast-converter/form-to-ast converter]]
    [match [forms-to-asts forms]
      [result/error errors]
      [let [expected-errors [form-to-list expected-errors-form]]
        [when-not [eq [size expected-errors] [size errors]]
          [log-location [first forms]]
          [logq different number of errors than expected]
          [logq expected]
          [for-each error expected-errors [log error]]
          [logq actual]
          [for-each error errors [log-report-message error]]
          ]
        [for i 0 [size expected-errors]
          [let [expected-message [at expected-errors i]
                  actual-message [report-message/message [at errors i]]]
            [when-not [eq-form expected-message actual-message]
              [log-location [first forms]]
              [logq different message than expected]
              [logq expected [identity expected-message]]
              [logq actual [identity actual-message]]]]]]

      [result/ok bform]
      [do
        [log forms]
        [logq-abort test-error there were no errors]]]]]

[defmacro test-error [expected-errors .. forms]
  [flist [quote test-error-fn]
    [mk-quote expected-errors]
    [form-concat [list [quote list]] [list-map f forms [mk-quote f]]]]]

[defn test-suite []
  [test-ok
    [type opt [] [union [none]]]
    [opt/none]]

  [test-ok
[type option [a]
  [union
    [none]
    [some a]]]

[type function-kind []
  [union
    [ctor]
    [func]
    [macro]
    [fexpr]]]

[type
  type-var-kind []
  [union
    [linked type]
    [word word]]

  type-var []
  [record
    [kind [atom type-var-kind]]
    [level [atom i32]]]

  func-type []
  [record
    [params [list type]]
    [rest-param-opt [option type]]
    [result type]
    [kind function-kind]]

  inst-type []
  [union
    [func func-type]
    [apply word [list type]]]

  type []
  [union
    [var type-var]
    [inst inst-type]]]

    ]
  [test-ok
    [load m.wuns]
    x]
  [test-ok
    [type pair [a b] [record [fst a] [snd b]]]
    [pair [i32 1] [word a]]
    [pair/snd [pair [i32 1] [word a]]]]
  [test-ok
    [type-anno [i32 2] [type-scheme [a b c] [func [[list a] [list b]] [list c]]]]]

  [test-error [[redefing type]] [type t [] [union]] [type t [] [union]]]
  [test-error [[type name is reserved]] [type i32 [] [union]]]

  [test-error [[undefined type or type param]] [type t [] [union [ctor no-such-type]]]]
  [test-error [[undefined type]] [type t [] [union [ctor [no-such-type]]]]]
  [test-error [[type is empty]] [type-anno [i32 2] []]]
  [test-error [[type is empty]] [type-anno [i32 2] [type-scheme [] []]]]
[comment    [test-error [[does not accept type-scheme]] [type-anno [i32 2] [type-scheme [] type-scheme]]] ]
  [test-error [[does not accept type-scheme]] [type-anno [i32 2] [type-scheme [] [type-scheme]]]]
  [test-error [[func expects a parameter list and a return type]] [type-anno [i32 2] [func]]]
  [test-error [[func expects a parameter list and a return type]] [type-anno [i32 2] [func []]]]
  [test-error [[wrong number of type arguments to builtin]] [type t [] [union [ctor [i32 f64]]]]]
  [test-error [[wrong number of type arguments]] [type t [] [union [ctor]]] [type t2 [] [union [ctor [t i32]]]]]

  [test-error [[undefined type]] [type t [] [union [ctor [no-such-type]]]]]
  [test-error [[duplicate type param]] [type-anno [i32 2] [type-scheme [a a] i32]]]
  [test-error [[duplicate type param]] [type t [a a] [union]]]
  [test-error [[reserved types cannot be used as type params]] [type t [i32] [union]]]

  [test-ok [let [] [i32 4] [i32 5]]]
  [test-ok [letfn [] [i32 4] [i32 5]]]
  [test-ok [func f [] [i32 4] [i32 5]]]

  [word done]
  ]

[defn test-file-ok [file-name]
  [test-ok-fn [read-file file-name]]
  [word done]]

[defn test-tail [form]
  [let [converter [mk-form-to-ast]
           f2a [form-to-ast-converter/form-to-ast converter]
           node-to-ldesc [form-to-ast-converter/node-to-ldesc converter]]
    [match [f2a form]
      [result/error errors]
      [logq-abort form-to-ast errors]

      [result/ok bform]
        [match bform
          [bform/func bf]
          [tail-call-analysis node-to-ldesc bf]

          [logq-abort test-tail not a func]]]]]

[defn test-assert-no-rec-calls [form]
  [match [test-tail form]
    [tail-call-result/no-rec-calls] [do]
    [logq-abort assert-no-rec-calls not no rec calls]]]

[defn int-list-eq [l1 l2]
  [and [eq [size l1] [size l2]]
    [[func go [i]
      [if [eq i [size l1]]
        true
        [and [eq [at l1 i] [at l2 i]] [go [inc i]]]]] 0]]]

[defn test-assert-only-tail [expected form]
  [match [test-tail form]
    [tail-call-result/only-tail call-to-deps]
    [let [lls [kv-map-values call-to-deps]]
      [assert [eq [size lls] [size expected]] only tail size]
      [[func go [i]
        [when [lt-s i [size lls]]
          [assert [int-list-eq [at expected i] [at lls i]]]
          [go [inc i]]]] 0]]
    [logq-abort assert-only-tail not only tail]]]

[defn test-assert-has-non-tail [form]
  [match [test-tail form]
    [tail-call-result/non-tail] [do]
    [logq-abort assert-no-tail not no tail]]]

[defn test-tail-analysis []
  [test-assert-no-rec-calls
    [quote [func f [] [do]]]]
  [test-assert-only-tail [list [list]]
    [quote [func f [] [f]]]]
  [test-assert-only-tail [list [list] [list]]
    [quote [func f [] [if [i32 1] [f] [f]]]]]
  [test-assert-only-tail [list [list]]
    [quote
      [func go [res n]
        [if n
          [go [[intrinsic i32.add] res n] [[intrinsic i32.sub] n [i32 1]]]
          res]]]]
  [comment here arg 1 depends on parameter 0 in the tail call]
  [test-assert-only-tail [list [list 0]]
    [quote [func go [n res]
      [if n
        [go [[intrinsic i32.sub] n [i32 1]] [[intrinsic i32.add] res n]]
        res]]]]
  [test-assert-has-non-tail
    [quote [func f [] [do [f] [i32 4]]]]]]
