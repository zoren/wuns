[defmacro kv-map [.. entries]
  [let [ml [mutable-list]]
    [push ml [quote transient-kv-map]]
    [for-inc i 0 2 [size entries]
      [push ml
        [let [k [at entries i]]
                [if [is-word k]
                  [list [quote quote] k]
                  k]]]
      [push ml [at entries [inc i]]]]
    [concat [quote [persistent-object]] [list ml]]]]

[defmacro getq [m w]
  [list [quote get] m [list [quote quote] w]]]

[defmacro hasq [m w]
  [list [quote has] m [list [quote quote] w]]]

[defn make-top-ctx []
  [kv-map var-descriptors [transient-kv-map]]]

[defn make-ctx [var-descriptors outer def-form]
  [kv-map var-descriptors var-descriptors outer outer def-form def-form]]

[defn get-var-descriptor [ctx word]
  [loop [cur-ctx ctx]
    [let [var-map [getq cur-ctx var-descriptors]]
      [if [has var-map word]
        [get var-map word]
        [if [hasq cur-ctx outer]
          [continue cur-ctx [getq cur-ctx outer]]
          [log-abort unknown variable [identity word]]]]]]]

[defmacro report [form .. lmsg]
  [list [quote report-error] [list [quote quote] lmsg] form]]

[defmacro report-when [cond form .. lmsg]
  [list [quote when] cond
    [list [quote report-error] [list [quote quote] lmsg] form]]]

[defmacro report-when-not [cond form .. lmsg]
  [list [quote when-not] cond
    [list [quote report-error] [list [quote quote] lmsg] form]]]

[def type-error [quote type-error]]

[defn check [ctx form]
  [ifs
    [is-word form]
    [let [desc [get-var-descriptor ctx form]]

      ]

    [not [is-list form]]
    [do
      [report form not a list]
      type-error]

    [is-empty form]
    [do
      [report form empty list]
      type-error]

    [let
      [first-form [first form]
       s-form [size form]
       n-of-args [dec s-form]]
      [ifs
        [eq-word first-form [quote quote]]
        [if [eq n-of-args 1]
          [let [v [second form]]
            [if [is-word v]
              [if [is-i32 v] [quote i32] [quote word]]
              [quote list form]]]
          [quote list form]]

        [eq-word first-form [quote if]]
        [let
          [- [report-when-not [eq n-of-args 3] form must have 3 arguments]
           ct [check ctx [at form 1]]
           tt [check ctx [at form 2]]
           et [check ctx [at form 3]]]
          [report-when-not [eq-word ct [quote i32]] first argument must be an i32]
          [report-when-not [eq tt et] second and third arguments must have the same type]
          ]

        [eq-word first-form [quote let]]
        [let [new-ctx [make-ctx [transient-kv-map] ctx first-form]]
          [for i 1 [dec s-form]
            [check new-ctx [at form i]]]
          [check new-ctx [last form]]]

        [eq-word first-form [quote loop]]
        []

        [eq-word first-form [quote continue]]
        []

        [eq-word first-form [quote def]]
        [let
          [- [report-when-not [eq n-of-args 3] form must have 3 arguments]
           var [second form]]
          [report-when-not [is-word var] var first argument must be a word]
          [set [getq ctx var-descriptors] var [check ctx [third form]]]]


        [eq-form first-form [quote func]]
        []

        []
  ]]]]

[defn make-top-env []
  [kv-map var-values [transient-kv-map]]]

[defn make-env [var-values outer def-form]
  [kv-map var-values var-values outer outer def-form def-form]]

[defn get-var-value [env var]
  [loop [cur-env env]
    [let [var-map [getq cur-env var-values]]
      [if [has var-map var]
        [get var-map var]
        [if [hasq cur-env outer]
          [continue cur-env [getq cur-env outer]]
          [log-abort unknownnn variable [identity var]]]]]]]

[defn make-var-obj []
  [kv-map value [atom 0] meta [atom 0]]]

[defn make-eval-context []
[let [var-objects [transient-kv-map]
      get-var-object [func get-var-object [var] [get var-objects var]]
      def-set-var [func def-set-var [var-name value]
        [let [v [if [has var-objects var-name]
                  [get var-objects var-name]
                  [let [new-var [make-var-obj]]
                    [set var-objects var-name new-var]
                    new-var]]]
          [atom-set [getq v value] value]]]
comp
[func comp [ctx form]
  [let [comp-bodies
    [func comp-bodies [ctx bodies]
      [let [cbodies [mutable-list]]
        [for i 0 [size bodies]
          [push cbodies [comp ctx [at bodies i]]]]
        [func ev-bodies [env]
          [loop [result [] i 0]
            [if [lt i [size cbodies]]
              [continue result [[at cbodies i] env] i [inc i]]]
              result]]]]]
  [ifs
    [is-word form]
    [get-var-descriptor ctx form]

    [not [is-list form]]
    [log-abort expected list but found [identity form]]

    [is-empty form]
    [log-abort empty list]

    [let
      [first-form [first form]
       s-form [size form]
       n-of-args [dec [size form]]]
      [ifs
        [eq-word first-form [quote quote]]
        [let [v [if [eq n-of-args 1]
          [second form]
          [rest form]]]
          [func quote [-] v]]

        [eq-word first-form [quote if]]
        [let [forms [concat form [list [] [] []]]
              cond [comp ctx [at forms 1]]
              then [comp ctx [at forms 2]]
              else [comp ctx [at forms 3]]]
          [report-when-not [eq [size forms] 4] form if must have 3 arguments]
          [func if [env]
            [if [cond env]
              [then env]
              [else env]]]]

        [eq-word first-form [quote let]]
        [let [bindings [second form]
              s-bindings [size bindings]
              var-descs [transient-kv-map]
              new-ctx [make-ctx var-descs ctx first-form]]
          [report-when-not [is-list bindings] bindings must be a list]
          [report-when-not [is-even s-bindings] bindings must have an even number of elements]
          [for-inc i 0 2 s-bindings
            [let [binding [at bindings i]
                  value [at bindings [inc i]]]
              [report-when-not [is-word binding] binding must be a word]
              [set var-descs binding [comp new-ctx value]]]]
          [let [ebodies [comp-bodies new-ctx [slice form 2 s-form]]]
            [func let [env]
              [let [var-values [transient-kv-map] inner [make-env var-values env first-form]]
                [for-inc i 0 2 s-bindings
                  [let [binding [at bindings i]
                        value [at bindings [inc i]]]
                    [set var-values binding [comp inner value]]]]
                [ebodies inner]]]]]

          [if [is-list first-form]
            []
            [log-abort unknownn function [identity first-form]]]

            ]]
          ]

        ]]]
  [kv-map eval [func eval [form] [comp 0 form]]]]]

[def ctx [make-eval-context]]

[defn ev-cc [form]
  [[[getq ctx eval] form] 0]]

[comment
        [eq-word first-form [quote def]]
        [let [var [second form]
              value [comp ctx [third form]]]
          [set [getq env var-values] var value]]

        [eq-word first-form [quote let]]
        [let [bindings [second form]
              var-values [transient-kv-map]
              new-env [make-env var-values env first-form]]
          [assert [is-list bindings] bindings must be a list]
          [assert [is-even [size bindings]] bindings must have an even number of elements]
          [for-inc i 0 2 [size bindings]
            [let [binding [at bindings i]
                  value [at bindings [inc i]]]
              [assert [is-word binding] binding must be a word]
              [set var-values binding [eval new-env value]]]]
          [for i 2 [dec s-form]
            [eval new-env [at form i]]]
          [eval new-env [last form]]]

        [eq-word first-form [quote loop]]
        [let [bindings [second form]
              var-values [transient-kv-map]
              new-env [make-env var-values env first-form]]
          [assert [is-list bindings] bindings must be a list]
          [assert [is-even [size bindings]] bindings must have an even number of elements]
          [for-inc i 0 2 [size bindings]
            [let [binding [at bindings i]
                  value [at bindings [inc i]]]
              [assert [is-word binding] binding must be a word]
              [set var-values binding [eval new-env value]]]]
          [loop []
            [for i 2 [dec s-form]
              [eval new-env [at form i]]]
            [eval new-env [last form]]]
          ]

        [eq-word first-form [quote add]]
        [do
          [assert [eq n-of-args 2] must have 2 arguments]
          [add [eval env [at form 1]] [eval env [at form 2]]]]

]