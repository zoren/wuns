[def list [func list [.. entries] entries]]
[def extern-with-meta [extern extern-with-meta]]
[def form-word
  [extern-with-meta
    [extern host form-word]
    [quote [type [func [word] form]]]]]
[def form-list
  [extern-with-meta
    [extern host form-list]
    [quote [type [func [[list form]] form]]]]]
[def flist [func form-list [.. elements] [form-list elements]]]

[def defmacro
  [macro defmacro [name params .. bodies]
    [flist [quote def] name
      [flist [quote macro] name params [form-list [[extern host concat] [list [quote do]] bodies]]]]]]

[defmacro def-extern [name type]
  [flist [quote def] name
    [flist [quote extern-with-meta]
      [flist [quote extern] [quote host] name]
      [flist [quote quote] [flist [quote type] type]]]]]

[def-extern concat [type-scheme [a] [func [.. [list a]] [list a]]]]

[defmacro defn [name params .. bodies]
  [flist [quote def] name [flist [quote func] name params [form-list [concat [list [quote do]] bodies]]]]]

[defmacro if-not [c t f] [list [word if] c f t]]

[def-extern concat-lists [type-scheme [a] [func [[list [list a]]] [list a]]]]

[defn form-concat [.. list-forms]
  [form-list [concat-lists list-forms]]]

[defn mk-quote [form] [flist [quote quote] form]]

[defmacro defexpr [name parameters .. bodies]
  [flist [quote def] name
    [closure-with-meta
      [form-concat [list [quote func] name parameters] bodies]
      [quote [quote [function-kind fexpr]]]]]]

[def-extern size [type-scheme [a] [func [[list a]] i32]]]

[def-extern at [type-scheme [a] [func [[list a] i32] a]]]

[defmacro comment [.. -]
  [quote [do]]]

[def-extern concat-words [func [word word] word]]

[defn def-instruction-fn [def-name inst-name]
  [flist
    [quote def]
    def-name
    [flist [quote extern-with-meta]
      [flist [quote extern] [quote instructions] inst-name]
      [quote [quote [type [func [i32 i32] i32]]]]]]]

[defmacro def-instruction [def-name inst-name] [def-instruction-fn def-name inst-name]]

[def-extern try-get-form-word [func [form] [option word]]]
[def unreachable [extern instructions unreachable]]

[defn form-to-word [form]
  [let [w [try-get-form-word form]]
    [if w w [unreachable]]]]

[defmacro def-bin-i32-inst [name] [def-instruction-fn name [form-word [concat-words [word i32.] [form-to-word name]]]]]

[def-bin-i32-inst add]
[def-bin-i32-inst lt-s]

[def -2 [i32 -2]]
[def -1 [i32 -1]]
[def 0  [i32 0]]
[def 1  [i32 1]]
[def 2  [i32 2]]
[def 3  [i32 3]]
[def 4  [i32 4]]

[defn inc [x] [add x 1]]

[def-bin-i32-inst sub]
[def-bin-i32-inst mul]

[defn dec [x] [sub x 1]]

[defn not [c] [if c 0 1]]

[def-bin-i32-inst eq]

[defn is-empty [form]
  [eq 0 [size form]]]

[defn is-zero [x] [eq x 0]]

[def-instruction i32.bitwise-and i32.and]

[defn is-odd [x] [i32.bitwise-and x 1]]

[defn is-even [x] [not [is-odd x]]]

[defn is-negative [x] [lt-s x 0]]

[defn min [a b] [if [lt-s a b] a b]]
[defn max [a b] [if [lt-s a b] b a]]

[defn first [l] [at l 0]]
[defn second [l] [at l 1]]
[defn third [l] [at l 2]]
[defn fourth [l] [at l 3]]
[defn last [l] [at l -1]]

[defmacro when [cond .. forms]
  [flist
    [quote if] cond
    [form-concat [list [quote do]] forms]
    [quote [do]]]]

[defmacro when-not [cond .. forms]
  [flist
    [quote if] cond
    [quote [do]]
    [form-concat [list [quote do]] forms]]]

[defmacro if-not [cond false-form true-form]
  [flist
    [quote if] cond
    true-form
    false-form]]

[def-extern mutable-list-of-size [type-scheme [a] [func [i32] [mutable-list a]]]]
[def-extern set-array [type-scheme [a] [func [[mutable-list a] i32 a] []]]]
[def-extern freeze-mutable-list [type-scheme [a] [func [[mutable-list a]] [tuple]]]]

[defn is-word [form] [if [try-get-form-word form] 1 0]]
[def-extern log [func [.. any] []]]

[defn quote-list [lmsg]
  [let [s [size lmsg]
        msg [mutable-list-of-size [inc s]]]
    [do
      [set-array msg 0 [quote list]]
    [[func loop [i]
      [when [lt-s i s]
          [set-array msg [inc i]
          [let [e [at lmsg i]]
            [if [is-word e] [mk-quote e] e]]]
          [recur [inc i]]]]
      0]
    [form-list [freeze-mutable-list msg]]]]]

[defmacro assert [cond .. lmsg]
  [flist [quote if] cond
    [quote [do]]
    [flist [quote do]
      [flist [quote log] [quote-list lmsg]]
      [quote [unreachable]]]]]

[defmacro logq [.. lmsg]
  [flist [quote log] [quote-list lmsg]]]

[defmacro logq-abort [.. lmsg]
  [flist [quote do]
    [flist [quote log] [quote-list lmsg]]
    [quote [unreachable]]]]

[defn identity [x] x]

[defmacro ifs [.. clauses]
  [let [s [size clauses]]
    [assert [is-odd s] ifs requires an odd number of arguments]
    [[func loop [i res]
      [if [eq i 0]
        res
        [recur
          [sub i 2]
          [flist [quote if] [at clauses [sub i 2]] [at clauses [dec i]] res]]]]
      [dec s]
      [at clauses -1]]]]

[comment and relies on there only being one falsy value [i32 0]
        it will not return any other falsy value as or returns the first truthy argument]
[defmacro and [.. clauses]
  [let [s [size clauses]]
    [if [is-zero s]
      [quote [i32 1]]
      [[func loop [i res]
        [if [eq i 0]
          res
          [recur
            [dec i]
            [flist [quote if] [at clauses [dec i]] res [quote [i32 0]]]]]]
         [dec s]
         [at clauses -1]]]]]

[def-extern atom [type-scheme [a] [func [a] [atom a]]]]

[def word-counter [atom 0]]

[def-extern char-code-to-word [func [i32] word]]

[def-instruction i32.rem-s i32.rem-s]
[def-instruction i32.div-s i32.div-s]

[def-extern growable-list [type-scheme [a] [func [] [growable-list a]]]]
[def-extern push [type-scheme [a] [func [[growable-list a] a] []]]]
[def-extern clone-growable-to-frozen-list [type-scheme [a] [func [[growable-list a]] [list a]]]]

[def-extern int-to-word [func [i32] word]]

[defn i32-to-form [i]
  [flist [quote i32] [form-word [int-to-word i]]]]

[def-extern char-code-at [func [word i32] i32]]

[defmacro word-to-char-code [w]
  [i32-to-form [char-code-at [form-to-word w] 0]]]

[def-bin-i32-inst le-s]

[defn is-between-inclusive [lower c upper]
  [and [le-s lower c] [le-s c upper]]]

[def-extern word-byte-size [func [word] i32]]

[def-extern atom-get [type-scheme [a] [func [[atom a]] a]]]
[def-extern atom-set [type-scheme [a] [func [[atom a] a] [tuple]]]]

[defn inc-atom [atom]
  [let [prev-val [atom-get atom]]
    [do
      [atom-set atom [inc prev-val]]
      prev-val]]]

[defn genword []
  [form-word [concat-words [word genword] [int-to-word [inc-atom word-counter]]]]]

[defmacro or [.. clauses]
  [let [s [size clauses]]
    [if [is-zero s]
      [quote [i32 0]]
      [[func loop [i res]
        [if [eq i 0]
          res
          [recur
            [dec i]
            [let [w [genword]]
              [flist [quote let] [flist w [at clauses [dec i]]]
                [flist [quote if] w w res]]]]]]
       [dec s]
       [at clauses -1]]]]]

[def-extern try-get-form-list [func [form] [option [list form]]]]

[defn form-to-list [form]
  [let [l [try-get-form-list form]]
    [if l l [unreachable]]]]

[defn is-list [form] [if [try-get-form-list form] 1 0]]

[defmacro if-let [binding-form true-form false-form]
  [assert [is-list binding-form] if-let requires a list as the first argument]
  [let [binding [form-to-list binding-form]
        - [assert [eq 2 [size binding]] if-let bindings should have exactly two elements]
        v [first binding]
        cond [second binding]
        tmp-word [genword]]
    [do
      [assert [is-word v] if-let requires a word as the first element of the first argument]
      [flist [quote let] [flist tmp-word cond]
        [flist [quote if] tmp-word [flist [quote let] [flist v tmp-word] true-form] false-form]]]]]

[defn eq-word [fa fb]
  [and [is-word fa] [is-word fb]
    [let [wa [form-to-word fa] wb [form-to-word fb]
          sa [word-byte-size wa] sb [word-byte-size wb]]
      [and
        [eq sa sb]
        [[func loop [i]
          [if [lt-s i sa]
            [if [eq [char-code-at wa i] [char-code-at wb i]]
              [recur [inc i]]
              0]
            1]] 0]]]]]

[defn eq-form [a b]
  [or
    [eq-word a b]
    [and [is-list a] [is-list b]
      [let [la [form-to-list a]
            lb [form-to-list b]
            sa [size la]]
        [and [eq sa [size lb]]
          [[func loop [i]
            [if [lt-s i sa]
              [if [recur [at la i] [at lb i]]
                [continue i [inc i]]
                0]
              1]] 0]]]]]]

[defn for-func [iw start increment end forms]
  [assert [lt-s 0 increment] for-func increment must be positive]
  [let [ew [genword]]
    [flist
      [quote let] [flist ew end]
      [flist
        [flist
          [quote func] [quote loop] [flist iw]
          [flist [quote if]
            [flist [quote lt-s] iw ew]
            [form-concat
              [list [quote do]]
              forms
              [list [flist [quote recur] [flist [quote add] iw [i32-to-form increment]]]]]
            [quote [do]]]]
        start]]]]

[defmacro for [iw start end .. forms]
  [for-func iw start [i32 1] end forms]]

[defmacro for-pair [iw start end .. forms]
  [for-func iw start [i32 2] end forms]]

[defmacro for-each [element-var collection .. forms]
  [assert [is-word element-var] for-each requires a word as the first argument]
  [let [iteration-var [genword]
        col-var [genword]
        col-size-var [genword]]
    [flist
      [quote let] [flist col-var collection
                        col-size-var [flist [quote size] col-var]]
      [flist
        [flist
          [quote func] [quote loop] [flist iteration-var]
          [flist [quote if]
            [flist [quote lt-s] iteration-var col-size-var]
            [form-concat
              [list [quote let]]
              [list [flist element-var [flist [quote at] col-var iteration-var]]]
              [list
                [form-concat [list [quote do]]
                  forms
                  [list [flist [quote recur] [flist [quote add] iteration-var [quote [i32 1]]]]]]]]
            [quote [do]]]]
        [quote [i32 0]]]]]]

[defmacro list-map [element-var collection form]
  [assert [is-word element-var] list-map requires a word as the first argument]
  [let [iteration-var [genword]
        col-var [genword]
        col-size-var [genword]
        new-col-var [genword]]
    [flist
      [quote let] [flist col-var collection
                        col-size-var [flist [quote size] col-var]
                        new-col-var [flist [quote mutable-list-of-size] col-size-var]]
      [flist [quote do]
        [flist
          [flist
            [quote func] [quote loop] [flist iteration-var]
            [flist [quote if]
              [flist [quote lt-s] iteration-var col-size-var]
              [flist [quote let]
                [flist element-var [flist [quote at] col-var iteration-var]]
                [flist [quote do]
                  [flist [quote set-array] new-col-var iteration-var form]
                  [flist [quote recur] [flist [quote add] iteration-var [quote [i32 1]]]]]]
              [quote [do]]]]
          [quote [i32 0]]]
        [flist [quote freeze-mutable-list] new-col-var]]]]]

[defn half [x] [i32.div-s x 2]]

[def-extern transient-kv-map [func [] transient-kv-map]]
[def-extern set-kv-map [type-scheme [a] [func [transient-kv-map word a] []]]]
[def-extern freeze-kv-map [func [transient-kv-map] []]]

[defn mk-word [w] [flist [quote word] w]]

[defmacro kv-mapq [.. entries]
  [let [s [size entries]
        n-of-pairs [half s]
        ml [mutable-list-of-size n-of-pairs]
        tmp-word [genword]]
    [do
      [assert [is-even s] kv-map requires an even number of arguments]
      [for-pair i 0 s
        [set-array ml [half i]
          [let [k [at entries i]]
            [flist [quote set-kv-map] tmp-word
              [if [is-word k] [mk-word k] k]
              [at entries [inc i]]]]]]
      [flist [quote let]
        [flist tmp-word [quote [transient-kv-map]]]
        [form-concat
          [list [quote do]]
          [freeze-mutable-list ml]
          [list
            [flist [quote freeze-kv-map] tmp-word]
            tmp-word]]]]]]
