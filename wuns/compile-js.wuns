[load std.wuns]

[type wuns-func-kind [] [union [func] [fexpr] [macro]]]

[type wuns-type []
  [union
    [word word]
    [apply word [list wuns-type]]]]

[type wuns-type-decl-kind []
  [union
    [union [list [pair word [list wuns-type]]]]
    [record [list [pair word wuns-type]]]]]

[type wuns-type-decl []
  [record
    [name word]
    [type-params [list word]]
    [kind wuns-type-decl-kind]]]

[type wuns []
  [union
    [var word]
    [i32 word]
    [f64 word]
    [word word]
    [intrinsic word]
    [if wuns wuns wuns]
    [switch wuns [list [pair wuns wuns]] [option wuns]]
    [do [list wuns]]
    [let [list [pair word wuns]] wuns]
    [letrec [list [pair word wuns]] wuns]
    [def word wuns]
    [func wuns-func-kind word [list word] [option word] wuns]
    [call wuns [list wuns]]
    [call-word word [list form]]
    [extern [list word]]
    [type [list wuns-type-decl]]
    ]]

[defn parse-param-words [param-words]
  [let [s [size param-words]]
    [if [and [lt-s 1 s] [eq-word [at param-words -2] [word ..]]]
      [pair [slice param-words 0 [sub s 2]] [some [last param-words]]]
      [pair param-words [none]]]]]

[defn form-to-type [form]
  [match form
    [form/word w]
    [wuns-type/word w]

    [form/list l]
    [do
      [assert [not [is-empty l]] type form-to-type is empty]
      [wuns-type/apply
        [form-to-word [first l]]
        [list-map arg [slice l 1 [size l]] [form-to-type arg]]]]]]

[defn form-to-type-decl-kind [form]
  [match form
    [form/list l]
    [do
      [assert [not [is-empty l]] type decl kind form is empty]
      [switch [form-to-word [first l]]
        [word union]
        [wuns-type-decl-kind/union
          [list-map ctor [slice l 1 [size l]]
            [let-do [ctor-list [form-to-list ctor]]
              [assert [not [is-empty ctor-list]] type decl kind union ctor is empty]
              [pair
                [form-to-word [first ctor-list]]
                [list-map arg [rest ctor-list] [form-to-type arg]]]]]]

        [word record]
        [logq-abort form-to-type-decl-kind not implemented record]

        [logq-abort form-to-type-decl-kind not implemented]]]

    [logq-abort form-to-type-decl-kind not implemented]]]

[defn form-to-ast [form]
  [match form
    [form/word w]
    [wuns/var w]

    [form/list l]
    [match [first l]
      [form/word fw]
      [switch fw
        [word i32]
        [wuns/i32 [form-to-word [second l]]]

        [word f64]
        [wuns/f64 [form-to-word [second l]]]

        [word word]
        [wuns/word [form-to-word [second l]]]

        [word extern]
        [wuns/extern [list-map w [rest l] [form-to-word w]]]

        [word intrinsic]
        [wuns/intrinsic [form-to-word [second l]]]

        [word func]
        [let [name [form-to-word [second l]]
              parsed-params [parse-param-words [list-map p [form-to-list [third l]] [form-to-word p]]]
              body-form [fourth l]]
          [wuns/func
            [wuns-func-kind/func]
            name
            [pair/fst parsed-params]
            [pair/snd parsed-params]
            [form-to-ast body-form]]]

        [word fexpr]
        [logq-abort form-to-ast not implemented fexpr]

        [word macro]
        [let [name [form-to-word [second l]]
              parsed-params [parse-param-words [list-map p [form-to-list [third l]] [form-to-word p]]]
              body-form [fourth l]]
          [wuns/func
            [wuns-func-kind/macro]
            name
            [pair/fst parsed-params]
            [pair/snd parsed-params]
            [form-to-ast body-form]]]

        [word atom]
        [logq-abort form-to-ast not implemented atom]

        [word if]
        [wuns/if [form-to-ast [second l]] [form-to-ast [third l]] [form-to-ast [fourth l]]]

        [word switch]
        [wuns/switch
          [form-to-ast [second l]]
          [list-map p [pairwise [slice l 2 [dec [size l]]]] [pair [form-to-ast [first p]] [form-to-ast [second p]]]]
          [if [is-odd [size l]]
            [some [form-to-ast [last l]]]
            [none]]]

        [word match]
        [logq-abort form-to-ast not implemented match]

        [word do]
        [wuns/do [list-map arg [rest l] [form-to-ast arg]]]

        [word let]
        [wuns/let
          [list-map p [pairwise [slice l 1 [dec [size l]]]] [pair [form-to-word [first p]] [form-to-ast [second p]]]]
          [form-to-ast [last l]]]

        [word letrec]
        [wuns/letrec
          [list-map p [pairwise [slice l 1 [dec [size l]]]] [pair [form-to-word [first p]] [form-to-ast [second p]]]]
          [form-to-ast [last l]]]

        [word def]
        [wuns/def [form-to-word [second l]] [form-to-ast [third l]]]

        [word type]
        [wuns/type
          [list-map triple [triplewise [rest l]]
            [wuns-type-decl
              [form-to-word [first triple]]
              [list-map tv [form-to-list [second triple]] [form-to-word tv]]
              [form-to-type-decl-kind [third triple]]]]]

        [word type-anno]
        [logq-abort form-to-ast not implemented type-anno]

        [wuns/call-word fw [rest l]]]

      [form/list fl]
      [wuns/call [form-to-ast [first l]] [list-map arg [rest l] [form-to-ast arg]]]]]]

[type binop []
  [union
    [eq]
    [lt]
    [add]
    [sub]
    [mul]
    [binary-and]
    [binary-ior]
    ]]

[type js-exp []
  [union
    [number word]
    [string word]
    [var word]
    [array [list js-exp]]
    [subscript js-exp js-exp]
    [ternary js-exp js-exp js-exp]
    [call js-exp [list js-exp]]
    [new js-exp [list js-exp]]
    [binop binop js-exp js-exp]
    [arrow-exp [list word] js-exp]
    [arrow-stmt [list word] js-stmt]
  ]

  js-stmt []
  [union
    [break]
    [exp js-exp]
    [throw js-exp]
    [return js-exp]
    [const-decl word js-exp]
    [if js-exp js-stmt js-stmt]
    [switch js-exp [list [pair js-exp js-stmt]] js-stmt]
    [block [list js-stmt]]
    [seq [list js-stmt]]
  ]
]

[type js-value [] [union]]

[def run-js-stmt
  [type-anno
    [extern js run-js-stmt]
    [func [js-stmt] [js-value]]]]

[def run-js-exp
  [type-anno
    [extern js run-js-exp]
    [func [js-exp] [js-value]]]]

[def call-js-func
  [type-anno
    [extern js call-js-func]
    [func [js-value [list form]] form]]]

[defn block [.. stmts] [js-stmt/block stmts]]

[def js-0 [js-exp/number [word 0]]]

[defn js-bitwise-or-0 [e]
  [js-exp/binop [binop/binary-ior] js-0 e]]

[defn instruction-name-to-binop [inst-name]
  [switch inst-name
    [word i32.add] [binop/add]
    [word i32.sub] [binop/sub]
    [word i32.mul] [binop/mul]
    [word i32.eq] [binop/eq]
    [word i32.lt-s] [binop/lt]
    [logq-abort instruction-name-to-binop not implemented]]]

[defn is-wuns-macro [ast]
  [match ast
    [wuns/func kind name params opt-rest body]
    [match kind [wuns-func-kind/macro] 1 0]
    0]]

[defn iife [stmt]
  [js-exp/call
    [js-exp/arrow-stmt [list] stmt]
    [list]]]

[defn mk-extern [ws]
  [[func add-sub [o i]
    [if [lt-s i [size ws]]
      [add-sub
        [js-exp/subscript o [js-exp/string [at ws i]]]
        [inc i]]
      o]]
    [js-exp/var [word externs]] [i32 0]]]

[defn compile-top-forms [top-forms]
  [letrec
    [def-ctx [transient-kv-map]
     macro-funcs [transient-kv-map]
     top-decls [atom [linked-list/nil]]
     cexp
      [func cexp [wexp]
        [match wexp
          [wuns/var w]
          [js-exp/var w]

          [wuns/i32 w]
          [js-exp/number w]

          [wuns/f64 w]
          [js-exp/number w]

          [wuns/word w]
          [js-exp/string w]

          [wuns/if cond t f]
          [js-exp/ternary [cexp cond] [cexp t] [cexp f]]

          [wuns/func kind name params opt-rest body]
          [js-exp/call
            [js-exp/arrow-stmt [list]
              [block
                [js-stmt/const-decl name
                  [js-exp/arrow-exp
                    [if-let [rest opt-rest]
                      [concat params [list [concat-words [word ...] rest]]]
                      params] [cexp body]]]
                [js-stmt/return [js-exp/var name]]]]
            [list]]


          [wuns/call-word w form-args]
          [if-let [def-val [try-get def-ctx w]]
            [if-let [macro-func [try-get macro-funcs w]]
              [cexp [form-to-ast [call-js-func macro-func form-args]]]
              [js-exp/call [js-exp/var w] [list-map arg form-args [cexp [form-to-ast arg]]]]]
            [js-exp/call [js-exp/var w] [list-map arg form-args [cexp [form-to-ast arg]]]]]

          [wuns/call f args]
          [match f
            [wuns/intrinsic w]
            [js-exp/binop
              [instruction-name-to-binop w]
              [cexp [first args]]
              [cexp [second args]]]

            [wuns/extern ws]
            [js-exp/call [mk-extern ws] [list-map arg args [cexp arg]]]

            [js-exp/call [cexp f] [list-map arg args [cexp arg]]]]

          [do
            [log wexp]
            [logq-abort cexp not implemented]]]]
     cstmt
      [func cstmt [is-tail wexp]
        [match wexp
          [wuns/if cond t f]
          [js-stmt/if [cexp cond]
            [block [cstmt is-tail t]]
            [block [cstmt is-tail f]]]

          [wuns/do exps]
          [js-stmt/block
            [concat
              [list-map f [slice exps 0 [dec [size exps]]] [cstmt 0 f]]
              [list [cstmt is-tail [last exps]]]]]

          [wuns/switch exp cases opt-default]
          [if is-tail
            [js-stmt/switch
              [cexp exp]
              [list-map case cases
                [pair
                  [cexp [pair/fst case]]
                  [cstmt is-tail [pair/snd case]]]]
              [if-let [default-case opt-default]
                [cstmt is-tail default-case]
                [logq-abort cstmt switch without default]]]
            [logq-abort cstmt not implemented switch]]

          [wuns/def w e]
          [do
            [set-kv-map def-ctx w e]
            [js-stmt/const-decl w [cexp e]]]

          [wuns/type decls]
          [js-stmt/seq
            [concat-lists
              [list-map decl decls
                [let [type-name [wuns-type-decl/name decl]
                      type-name-prefix [concat-words type-name [word /]]
                      type-params [wuns-type-decl/type-params decl]
                      kind [wuns-type-decl/kind decl]]
                  [match kind
                    [wuns-type-decl-kind/union ctors]
                    [list-map ctor ctors
                      [let [n-atom [atom 0]
                            params [list-map t [pair/snd ctor] [concat-words [word p] [int-to-word [inc-atom n-atom]]]]]
                        [js-stmt/const-decl
                          [concat-words type-name-prefix [pair/fst ctor]]
                          [js-exp/arrow-exp
                            params
                            [js-exp/call
                              [mk-extern [list [word host] [word make-tagged-value]]]
                              [concat
                                [list [js-exp/string [concat-words type-name-prefix [pair/fst ctor]]]]
                                [list-map p params [js-exp/var p]]]]]]]]

                    [wuns-type-decl-kind/record fields]
                    [logq-abort cstmt not implemented record]]]]]]

          [if is-tail
            [js-stmt/return [cexp wexp]]
            [js-stmt/exp [cexp wexp]]]]]]
    [do
      [for-each top-form top-forms
        [let-do [ast [form-to-ast top-form]]
          [push top-decls [cstmt 0 ast]]
          [match ast
            [wuns/def w e]
            [when [is-wuns-macro e]
              [let-do [top-so-far [clone-growable-to-frozen-list top-decls]
                    decl-block [js-stmt/block [concat top-so-far [list [js-stmt/return [js-exp/var w]]]]]
                    mac-func [run-js-stmt decl-block]]
                [log mac-func]
                [set-kv-map macro-funcs w mac-func]]]
            [do]]]]
      [js-stmt/seq [clone-growable-to-frozen-list top-decls]]]
    ]]

[defn compile-run [form]
  [run-js-stmt [compile-top-forms [list form]]]]

[type
  exports []
  [record
    [compile-run [func [form] js-value]]
    [compile-top-forms [func [[list form]] js-stmt]]]]

[exports
  compile-run
  compile-top-forms]
