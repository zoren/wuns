[def - [quote -]]
[def .. [quote ..]]

[defn has-local-context [ctx var]
  [loop [cur-ctx ctx]
    [ifs
      [has [getq cur-ctx vars] var]
      1

      [hasq cur-ctx outer]
      [continue cur-ctx [getq cur-ctx outer]]

      0]]]

[defn get-top-context [local-ctx]
  [loop [cur-ctx local-ctx]
    [if-let [outer [try-getq cur-ctx outer]]
      [continue cur-ctx outer]
      cur-ctx]]]

[defn try-get-loop-vars [local-ctx]
  [loop [cur-ctx local-ctx]
    [if [if-let [df [try-getq cur-ctx decl-form]] [eq-word [quote loop] df] 0]
      [getq cur-ctx vars]
      [if-let [outer [try-getq cur-ctx outer]]
        [continue cur-ctx outer]
        0]]]]

[defn n-of-args-match-def [def-meta n-of-args]
  [let [n-of-regular-params [getq def-meta n-of-params]]
    [if [hasq def-meta has-rest-param]
      [le-s n-of-regular-params n-of-args]
      [eq n-of-regular-params n-of-args]]]]

[defn report-fn [gctx message form]
  [push [getq gctx messages] [kv-map-id message form]]]

[defmacro report-when [cond form .. lmsg]
  [list [quote when] cond
    [list [quote report-fn] [quote gctx] [quote-list lmsg] form]]]

[defmacro report-when-not [cond form .. lmsg]
  [list [quote when-not] cond
    [list [quote report-fn] [quote gctx] [quote-list lmsg] form]]]

[defmacro report [form .. lmsg]
  [list [quote report-fn] [quote gctx] [quote-list lmsg] form]]

[defn eval-try-get-var [gctx name]
  [let [eval-context [getq gctx eval-context]]
    [eval-context [list [quote try-get-var] name]]]]

[defn has-truthy-key [m k] [and m [has m k] [get m k]]]

[defn has-rest-param [params] [and [lt-s 1 [size params]] [eq-word [at params -2] ..]]]

[defn params-to-map [params]
  [if [and [lt-s 1 [size params]] [eq-word [at params -2] ..]]
    [kv-mapq params [slice params 0 [sub [size params] 2]]
            rest-param [last params]]
    [kv-map-id params]]]

[defn expand-form [gctx local-ctx form]
  [ifs
    [is-word form]
    [do
      [when-not [has-local-context local-ctx form]
        [if-let [def-var [eval-try-get-var gctx form]]
          [let [m [var-meta def-var]
                params [has-truthy-key m [quote params]]]
            [report-when params form defed func used as value]]
          [report form var not found]]]
      form]

    [not [is-list form]]
    [do

      form]

    [is-empty form]
    [do
      [report form empty list]
      form]

    [let [first-form [first form]
          s-form [size form]
          n-of-args [dec s-form]]
        [ifs
          [eq-word [quote i32] first-form]
          form

          [eq-word [quote quote] first-form]
          form

          [eq-word [quote active-data] first-form]
          form

          [eq-word [quote if] first-form]
          [let [res [mutable-list-of-size s-form]]
            [set-array res 0 first-form]
            [report-when [or [lt-s n-of-args 2] [lt-s 3 n-of-args]] form if expects 2 or 3 arguments]
            [for i 4 s-form
              [recur gctx local-ctx [at form i]]
              [report [at form i] if extra forms ignored]]
            [for i 1 s-form [set-array res i [recur gctx local-ctx [at form i]]]]
            res]

          [or [eq-word [quote let] first-form] [eq-word [quote loop] first-form]]
          [let [res [mutable-list-of-size s-form]
                bindings [at form 1]
                s-bindings [size bindings]
                vars [transient-kv-map]
                new-local-ctx [kv-mapq vars vars outer local-ctx decl-form first-form]
                new-bindings [mutable-list-of-size s-bindings]]
            [for-pair i 0 s-bindings
              [let [var [at bindings i]
                    value [at bindings [inc i]]]
                [set-array new-bindings i var]
                [set-array new-bindings [inc i] [recur gctx new-local-ctx value]]
                [if [is-word var]
                  [do
                    [report-when [has vars var] var already defined]
                    [set-kv-map vars var [kv-map-id var]]]
                  [report var not a word let or loop]]]]
            [set-array res 0 first-form]
            [set-array res 1 new-bindings]
            [for i 2 s-form [set-array res i [recur gctx new-local-ctx [at form i]]]]
            res]

          [eq-word [quote continue] first-form]
          [let [loop-vars [try-get-loop-vars local-ctx]
                res [mutable-list-of-size s-form]]
            [comment todo check if we are at tail position]
            [set-array res 0 first-form]
            [report-when-not loop-vars form continue outside loop]
            [for-pair i 1 s-form
              [let [var [at form i]]
                [report-when-not [is-word var] var not a word continue]
                [report-when-not [and loop-vars [has loop-vars var]] var loop var not found in expand]
                [set-array res i var]
                [set-array res [inc i] [recur gctx local-ctx [at form [inc i]]]]]]
            res]

          [eq-word [quote func] first-form]
          [let [name [at form 1]
                params [at form 2]
                - [assert [is-list params] params not a list [identity name] [identity i32]]
                params-map [transient-kv-map]
                n-of-params [size params]
                has-rest-param [has-rest-param params]
                signature
                [if has-rest-param
                  [let [dot-dot-index [sub n-of-params 2]
                        rest-param [last params]]
                    [for i 0 dot-dot-index
                      [let [param [at params i]]
                        [set-kv-map params-map param [kv-mapq var param]]]]
                    [set-kv-map params-map rest-param [kv-mapq var rest-param rest-param 1]]
                    [kv-mapq params [slice params 0 dot-dot-index]
                            rest-param rest-param]]
                  [do
                    [comment todo check for extra arguments]
                    [for-each param params
                      [set-kv-map params-map param [kv-mapq var param]]]
                    [kv-map-id params]]]
                  empty-ctx [kv-mapq vars empty-kv-map decl-form first-form]
                  fn-local-ctx [kv-mapq vars params-map decl-form first-form signature signature
                                       n-of-params n-of-params has-rest-param has-rest-param]]
            [let [res [mutable-list-of-size s-form]]
              [set-array res 0 first-form]
              [set-array res 1 name]
              [set-array res 2 params]
              [for i 3 s-form [set-array res i [recur gctx fn-local-ctx [at form i]]]]
              res]]

          [eq-word [quote recur] first-form]
          [let [top-ctx [get-top-context local-ctx]
                res [mutable-list-of-size s-form]]
            [report-when-not [and [hasq top-ctx n-of-params]] form recur not inside function]
            [report-when-not [n-of-args-match-def top-ctx n-of-args] form wrong number of arguments]
            [set-array res 0 first-form]
            [for i 1 s-form [set-array res i [recur gctx local-ctx [at form i]]]]
            res]

          [eq-form [quote extern] first-form]
          [do
            [for i 1 s-form [report-when-not [is-word [at form i]] [at form i] not a word]]
            form]

          [eq-word [quote def] first-form]
          [let [- [report-when-not [eq n-of-args 2] form def expects 2 arguments]
                name [at form 1]
                - [report-when-not [is-word name] name not a word]
                local-ctx [kv-mapq vars empty-kv-map decl-form first-form]
                e-form [list first-form name [recur gctx local-ctx [at form 2]]]
                eval-context [getq gctx eval-context]]
            [report-when [eval-try-get-var gctx name] name already defined]
            [eval-context e-form]
            e-form]

          [eq-word [quote def-with-meta] first-form]
          [let [- [report-when-not [eq n-of-args 3] form def-with-meta expects 3 arguments]
                name [at form 1]
                - [report-when-not [is-word name] name not a word]
                meta-form [at form 2]
                local-ctx [kv-mapq vars empty-kv-map decl-form first-form]
                e-form [list first-form name [recur gctx local-ctx meta-form] [recur gctx local-ctx [at form 3]]]
                eval-context [getq gctx eval-context]]
            [report-when [eval-try-get-var gctx name] name already defined]
            [eval-context e-form]
            e-form]

          [eq-word [quote import] first-form]
          [let [- [report-when-not [eq s-form 4] form import expects 3 arguments]
                module-name [at form 1]
                name [at form 2]
                t [at form 3]
                ff [first t]]
              [ifs
                [eq-word ff [quote func]]
                [let [signature [kv-mapq params [second t] results [third t]]]
                  form]

                [eq-word ff [quote memory]]
                [do
                  form]

                [assert 0 expand import unexpected type]]]

          [if [or [not [is-word first-form]] [has-local-context local-ctx first-form]]
            [let [res [mutable-list-of-size s-form]]
              [set-array res 0 [recur gctx local-ctx first-form]]
              [for i 1 s-form [set-array res i [recur gctx local-ctx [at form i]]]]
              res]
            [if-let [def-var [eval-try-get-var gctx first-form]]
              [let []
                [let [var-meta [var-meta def-var]
                      var-val-meta [meta [var-get def-var]]
                      no-eval-args [has-truthy-key var-meta [quote no-eval-args]]
                      eval-result  [has-truthy-key var-meta [quote eval-result]]]
                  [ifs
                    [and no-eval-args eval-result]
                    [let [macro-func [var-get def-var]
                          mac-result-form [apply macro-func [slice form 1 s-form]]]
                      [recur gctx local-ctx mac-result-form]]

                    [and [not no-eval-args] [not eval-result]]
                    [let [res [mutable-list-of-size s-form]]
                      [set-array res 0 first-form]
                      [for i 1 s-form [set-array res i [recur gctx local-ctx [at form i]]]]
                      res]

                    [and no-eval-args [not eval-result]]
                    [let [fexpr-func [var-get def-var]]
                      [apply fexpr-func [slice form 1 s-form]]
                      form]

                    [logq-abort manc not implemented]]]]
              [if-let [instruction [try-get-instruction first-form]]
                [let [imm-parameters [getq instruction immediate-parameters]
                      imm-index [inc [size imm-parameters]]
                      res [mutable-list-of-size s-form]]
                  [report-when-not [eq [getq instruction arity] n-of-args] form wrong number of instruction arguments]
                  [set-array res 0 first-form]
                  [for i 1 imm-index [set-array res i [at form i]]]
                  [for i imm-index s-form [set-array res i [recur gctx local-ctx [at form i]]]]
                  res]
                [do
                  [report first-form first symbol not found during expansion]
                  form]]]]]]]]

[def empty-local-context [kv-mapq vars empty-kv-map]]

[def make-eval-context [extern interpreter make-eval-context]]

[def host-object
  [kv-mapq
    m
    [kv-mapq
      p0 [func p0 [] 0]
      p1 [func p1 [p] 1]
      p2 [func p2 [p q] 2]
      p0r [func p0r [.. r] 0]
      p1r [func p1r [p .. r] 1]]
    host
    [extern host]
    instructions
    [extern instructions]]]

[defn make-global-context []
  [kv-mapq
    messages [growable-list]
    eval-context [make-eval-context host-object]]]

[defn try-get-range [form]
  [let [m [meta form]]
    [if [and m [hasq m range]]
      [getq m range]
      [list]]]]

[defn try-get-location [form]
  [let [m [meta form]]
    [if [and m [hasq m location]]
      [getq m location]
      [list]]]]
