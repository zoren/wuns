[def - [quote -]]
[def .. [quote ..]]

[defn has-local-context [ctx var]
  [loop [cur-ctx ctx]
    [ifs
      [has [getq cur-ctx vars] var]
      1

      [hasq cur-ctx outer]
      [continue cur-ctx [getq cur-ctx outer]]

      0]]]

[defn get-top-context [local-ctx]
  [loop [cur-ctx local-ctx]
    [if [hasq cur-ctx outer]
      [continue cur-ctx [getq cur-ctx outer]]
      cur-ctx]]]

[defn try-get-loop-vars [local-ctx]
  [loop [cur-ctx local-ctx]
    [ifs
      [eq-word [quote loop] [getq cur-ctx decl-form]]
      [getq cur-ctx vars]

      [hasq cur-ctx outer]
      [continue cur-ctx [getq cur-ctx outer]]

      0]]]

[defn n-of-args-match-def [def-meta n-of-args]
  [let [n-of-regular-params [getq def-meta n-of-params]]
    [if [hasq def-meta has-rest-param]
      [le-s n-of-regular-params n-of-args]
      [eq n-of-regular-params n-of-args]]]]

[defn report-fn [gctx msg form]
  [push [getq gctx messages] [kv-map message msg form form]]]

[defmacro report-when [cond form .. lmsg]
  [list [quote when] cond
    [list [quote report-fn] [quote gctx] [quote-list lmsg] form]]]

[defmacro report-when-not [cond form .. lmsg]
  [list [quote when-not] cond
    [list [quote report-fn] [quote gctx] [quote-list lmsg] form]]]

[defmacro report [form .. lmsg]
  [list [quote report-fn] [quote gctx] [quote-list lmsg] form]]

[defn eval-try-get-var [gctx name]
  [let [eval-context [getq gctx eval-context]]
    [eval-context [list [quote try-get-var] name]]]]

[defn has-truthy-key [m k] [and m [has m k] [get m k]]]

[defn has-rest-param [params] [and [lt-s 1 [size params]] [eq-word [at params -2] ..]]]

[defn params-to-map [params]
  [if [and [lt-s 1 [size params]] [eq-word [at params -2] ..]]
    [kv-map params [slice params 0 [sub [size params] 2]] rest-param [last params]]
    [kv-map params params]]]

[defn expand-form [gctx local-ctx form]
  [ifs
    [is-word form]
    [do
      [when-not [has-local-context local-ctx form]
        [if-let [def-var [eval-try-get-var gctx form]]
          [let [m [var-meta def-var]
                params [has-truthy-key m [quote params]]]
            [report-when params form defed func used as value]]
          [report form symbol not found during expansion]]]
      form]

    [not [is-list form]]
    [do

      form]

    [is-empty form]
    [do
      [report form empty list]
      form]

    [let [first-form [first form]
          s-form [size form]
          n-of-args [dec s-form]]
        [ifs
          [eq-word [quote quote] first-form]
          form

          [eq-word [quote active-data] first-form]
          form

          [eq-word [quote if] first-form]
          [let [res [mutable-list-of-size s-form]]
            [set-array res 0 first-form]
            [report-when [or [lt-s n-of-args 2] [lt-s 3 n-of-args]] form if expects 2 or 3 arguments]
            [for i 1 s-form [set-array res i [recur gctx local-ctx [at form i]]]]
            res]

          [or [eq-word [quote let] first-form] [eq-word [quote loop] first-form]]
          [let [res [mutable-list-of-size s-form]
                bindings [at form 1]
                s-bindings [size bindings]
                vars [transient-kv-map]
                new-local-ctx [kv-map vars vars outer local-ctx decl-form first-form]
                new-bindings [mutable-list-of-size s-bindings]]
            [for-pair i 0 s-bindings
              [let [var [at bindings i]
                    value [at bindings [inc i]]]
                [set-array new-bindings i var]
                [set-array new-bindings [inc i] [recur gctx new-local-ctx value]]
                [if [is-word var]
                  [do
                    [report-when [has vars var] var already defined]
                    [set vars var [kv-map var var]]]
                  [report var not a word let or loop]]]]
            [set-array res 0 first-form]
            [set-array res 1 new-bindings]
            [for i 2 s-form [set-array res i [recur gctx new-local-ctx [at form i]]]]
            res]

          [eq-word [quote continue] first-form]
          [let [loop-vars [try-get-loop-vars local-ctx]
                res [mutable-list-of-size s-form]]
            [comment todo check if we are at tail position]
            [set-array res 0 first-form]
            [report-when-not loop-vars form not inside loop]
            [for-pair i 1 s-form
              [let [var [at form i]]
                [report-when-not [is-word var] var not a word continue]
                [report-when-not [and loop-vars [has loop-vars var]] var loop var not found in expand]
                [set-array res i var]
                [set-array res [inc i] [recur gctx local-ctx [at form [inc i]]]]]]
            res]

          [eq-word [quote func] first-form]
          [let [name [at form 1]
                params [at form 2]
                - [assert [is-list params] params not a list [identity name] [identity i32]]
                params-map [transient-kv-map]
                n-of-params [size params]
                has-rest-param [has-rest-param params]
                signature
                [if has-rest-param
                  [let [dot-dot-index [sub n-of-params 2]
                        rest-param [last params]]
                    [for i 0 dot-dot-index
                      [let [param [at params i]]
                        [set params-map param [kv-map var param]]]]
                    [set params-map rest-param [kv-map var rest-param rest-param 1]]
                    [kv-map params [slice params 0 dot-dot-index]
                            rest-param rest-param]]
                  [do
                    [comment todo check for extra arguments]
                    [for-each param params
                      [set params-map param [kv-map var param]]]
                    [kv-map params params]]]
                  empty-ctx [kv-map vars empty-kv-map decl-form first-form]
                  fn-local-ctx [kv-map vars params-map decl-form first-form signature signature
                                       n-of-params n-of-params has-rest-param has-rest-param]]
            [let [res [mutable-list-of-size s-form]]
              [set-array res 0 first-form]
              [set-array res 1 name]
              [set-array res 2 params]
              [for i 3 s-form [set-array res i [recur gctx fn-local-ctx [at form i]]]]
              res]]

          [eq-word [quote recur] first-form]
          [let [top-ctx [get-top-context local-ctx]
                res [mutable-list-of-size s-form]]
            [report-when-not [and [hasq top-ctx n-of-params]] form recur not inside function]
            [report-when-not [n-of-args-match-def top-ctx n-of-args] form wrong number of arguments]
            [set-array res 0 first-form]
            [for i 1 s-form [set-array res i [recur gctx local-ctx [at form i]]]]
            res]

          [eq-form first-form [quote extern]]
          [do
            [report-when-not [eq n-of-args 3] form extern expects 3 arguments]
            [let [module-name [second form]
                  name [third form]]
              [report-when-not [is-word module-name] module-name not a word]
              [report-when-not [is-word name] name not a word]
              form]]

          [eq-word [quote def] first-form]
          [let [- [report-when-not [eq n-of-args 2] form def expects 2 arguments]
                name [at form 1]
                local-ctx [kv-map vars empty-kv-map decl-form first-form]]
            [report-when-not [is-word name] name not a word]
            [list first-form name [recur gctx local-ctx [at form 2]]]]

          [eq-word [quote def-with-meta] first-form]
          [let [- [report-when-not [eq n-of-args 3] form def expects 3 arguments]
                name [at form 1]
                meta-form [at form 2]
                local-ctx [kv-map vars empty-kv-map decl-form first-form]]
            [report-when-not [is-word name] name not a word]
            [list first-form name [recur gctx local-ctx meta-form] [recur gctx local-ctx [at form 3]]]]

          [eq-word [quote import] first-form]
          [let [- [report-when-not [eq s-form 4] form import expects 3 arguments]
                module-name [at form 1]
                name [at form 2]
                t [at form 3]
                ff [first t]]
              [ifs
                [eq-word ff [quote func]]
                [let [signature [kv-map params [second t] results [third t]]]
                  form]

                [eq-word ff [quote memory]]
                [do
                  form]

                [assert 0 expand import unexpected type]]]

          [if [or [not [is-word first-form]] [has-local-context local-ctx first-form]]
            [let [res [mutable-list-of-size s-form]]
              [set-array res 0 [recur gctx local-ctx first-form]]
              [for i 1 s-form [set-array res i [recur gctx local-ctx [at form i]]]]
              res]
            [if-let [def-var [eval-try-get-var gctx first-form]]
              [let []
                [let [var-meta [var-meta def-var]
                      var-val-meta [meta [var-get def-var]]
                      no-eval-args [has-truthy-key var-meta [quote no-eval-args]]
                      eval-result  [has-truthy-key var-meta [quote eval-result]]]
                  [report-when-not
                    [n-of-args-match-def var-val-meta n-of-args]
                    form
                    wrong number of arguments]
                  [ifs
                    [and no-eval-args eval-result]
                    [let [macro-func [var-get def-var]
                          mac-result-form [apply macro-func [slice form 1 s-form]]]
                      [recur gctx local-ctx mac-result-form]]

                    [and [not no-eval-args] [not eval-result]]
                    [let [res [mutable-list-of-size s-form]]
                      [set-array res 0 first-form]
                      [for i 1 s-form [set-array res i [recur gctx local-ctx [at form i]]]]
                      res]

                    [and no-eval-args [not eval-result]]
                    [let [fexpr-func [var-get def-var]]
                      [apply fexpr-func [slice form 1 s-form]]
                      form]

                    [logq-abort manc not implemented]]]]
              [if-let [instruction [try-get-instruction first-form]]
                [let [imm-parameters [getq instruction immediate-parameters]
                      imm-index [inc [size imm-parameters]]
                      res [mutable-list-of-size s-form]]
                  [report-when-not [eq [getq instruction arity] n-of-args] form wrong number of instruction arguments]
                  [set-array res 0 first-form]
                  [for i 1 imm-index [set-array res i [at form i]]]
                  [for i imm-index s-form [set-array res i [recur gctx local-ctx [at form i]]]]
                  res]
                [do
                  [report first-form first symbol not found during expansion]
                  form]]]]]]]]

[def empty-local-context [kv-map vars empty-kv-map]]

[def host-object
  [kv-map
    m
    [kv-map
      p0 [func p0 [] 0]
      p1 [func p1 [p] 1]
      p2 [func p2 [p q] 2]
      p0r [func p0r [.. r] 0]
      p1r [func p1r [p .. r] 1]]
    host
    [kv-map-id
      size
      at
      mutable-list-of-size
      set-array
      freeze-mutable-list

      transient-kv-map
      set
      freeze-kv-map

      is-word
      log
      atom
      growable-list
      push

      char-code-to-word
      concat-words
      char-code-at
      word-byte-size
      atom-get
      atom-set
      is-list
      has
      get
      keys
      var-get
      var-meta
      apply
      make-eval-context
      meta
      word-with-meta
      list-with-meta
       ]]]

[defn make-global-context []
  [kv-map
    messages [growable-list]
    eval-context [make-eval-context host-object]]]

[defn expand-top-level-forms [gctx forms]
  [let [res [mutable-list-of-size [size forms]]
        eval-context [getq gctx eval-context]]
    [for i 0 [size forms]
      [let [form [at forms i]
            e-form [expand-form gctx empty-local-context form]]
        [eval-context e-form]
        [set-array res i e-form]]]
    res]]

[defn init-host-context [gctx host-func-types]
  [comment
    [add-global-binding gctx [quote wuns-active-mem-top] [kv-map def-form [quote def]]]
  ]]

[defn try-get-range [form]
  [let [m [meta form]]
    [if [and m [hasq m range]]
      [getq m range]
      [list]]]]

[defn try-get-location [form]
  [let [m [meta form]]
    [if [and m [hasq m location]]
      [getq m location]
      [list]]]]

[defn test-expand-no-errors-fn [host-func-types forms]
  [let [gctx [make-global-context]
        - [init-host-context gctx host-func-types]
        res [expand-top-level-forms gctx forms]
        messages [getq gctx messages]]
    [for-each err messages
      [log [list err [getq err message] [getq err form]
        [try-get-location [getq err form]]]]]
    [assert [is-empty messages] unexpected error messages]]]

[defn test-expand [host-func-types]
[quote
    [test-expand-no-errors-fn host-func-types [quote
  is-word
  is-list
  ]]]
  [test-expand-no-errors-fn host-func-types [quote
  [def x [i32.const 1]]
  [def y [i32.const 2]]
  ]]
]
