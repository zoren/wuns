[load std.wuns]

[type wuns-func-kind [] [union [func] [fexpr] [macro]]]

[type wuns-type []
  [union
    [word word]
    [apply word [list wuns-type]]]]

[type wuns-type-decl-kind []
  [union
    [union [list [pair word [list wuns-type]]]]
    [record [list [pair word wuns-type]]]]]

[type wuns-type-decl []
  [record
    [name word]
    [type-params [list word]]
    [kind wuns-type-decl-kind]]]

[type wuns []
  [union
    [var word]
    [i32 word]
    [f64 word]
    [word word]
    [intrinsic word]
    [if wuns wuns wuns]
    [switch wuns [list [pair [list wuns] wuns]] [option wuns]]
    [do [list wuns]]
    [let [list [pair word wuns]] wuns]
    [letrec [list [pair word wuns]] wuns]
    [def word wuns]
    [func wuns-func-kind word [list word] [option word] wuns]
    [call wuns [list wuns]]
    [call-word word [list form]]
    [extern [list word]]
    [type [list wuns-type-decl]]
    ]]

[defn parse-param-words [param-words]
  [let [s [size param-words]]
    [if [and [lt-s 1 s] [eq-word [at param-words -2] [word ..]]]
      [pair [slice param-words 0 [sub s 2]] [some [last param-words]]]
      [pair param-words [none]]]]]

[defn form-to-type [form]
  [match form
    [form/word w]
    [wuns-type/word w]

    [form/list l]
    [do
      [assert [not [is-empty l]] type form-to-type is empty]
      [wuns-type/apply
        [form-to-word [first l]]
        [list-map arg [slice l 1 [size l]] [form-to-type arg]]]]]]

[defn form-to-type-decl-kind [form]
  [match form
    [form/list l]
    [do
      [assert [not [is-empty l]] type decl kind form is empty]
      [switch [form-to-word [first l]]
        [word union]
        [wuns-type-decl-kind/union
          [list-map ctor [slice l 1 [size l]]
            [let-do [ctor-list [form-to-list ctor]]
              [assert [not [is-empty ctor-list]] type decl kind union ctor is empty]
              [pair
                [form-to-word [first ctor-list]]
                [list-map arg [rest ctor-list] [form-to-type arg]]]]]]

        [word record]
        [logq-abort form-to-type-decl-kind not implemented record]

        [logq-abort form-to-type-decl-kind not implemented]]]

    [logq-abort form-to-type-decl-kind not implemented]]]

[defn form-to-lit [form]
  [match form
    [form/list l]
    [do
      [assert [eq 2 [size l]] lit form-to-lit size is not 2]
      [switch [form-to-word [first l]]
        [word i32] [wuns/i32 [form-to-word [second l]]]
        [word f64] [wuns/f64 [form-to-word [second l]]]
        [word word] [wuns/word [form-to-word [second l]]]
        [logq-abort form-to-lit not implemented]]]]]

[defn form-to-literal-list [form]
  [match form
    [form/list l]
    [if [is-empty l]
      [list]
      [match [first l]
        [form/word w] [list [form-to-lit [first l]]]
        [list-map arg l [form-to-lit arg]]]]
    [logq-abort form-to-literal-list not implemented]]]

[defn form-to-ast [form]
  [match form
    [form/word w]
    [wuns/var w]

    [form/list l]
    [match [first l]
      [form/word fw]
      [switch fw
        [word i32]
        [wuns/i32 [form-to-word [second l]]]

        [word f64]
        [wuns/f64 [form-to-word [second l]]]

        [word word]
        [wuns/word [form-to-word [second l]]]

        [word extern]
        [wuns/extern [list-map w [rest l] [form-to-word w]]]

        [word intrinsic]
        [wuns/intrinsic [form-to-word [second l]]]

        [[word func] [word fexpr] [word macro]]
        [let [name [form-to-word [second l]]
              parsed-params [parse-param-words [list-map p [form-to-list [third l]] [form-to-word p]]]
              body-form [fourth l]]
          [wuns/func
            [switch fw
              [word func]  [wuns-func-kind/func]
              [word fexpr] [wuns-func-kind/fexpr]
              [word macro] [wuns-func-kind/macro]
              [logq-abort form-to-ast not implemented wuns-func-kind]]
            name
            [pair/fst parsed-params]
            [pair/snd parsed-params]
            [form-to-ast body-form]]]

        [word atom]
        [logq-abort form-to-ast not implemented atom]

        [word if]
        [wuns/if [form-to-ast [second l]] [form-to-ast [third l]] [form-to-ast [fourth l]]]

        [word switch]
        [wuns/switch
          [form-to-ast [second l]]
          [list-map p [pairwise [slice l 2 [dec [size l]]]]
            [pair
              [form-to-literal-list [first p]]
              [form-to-ast [second p]]]]
          [if [is-odd [size l]]
            [some [form-to-ast [last l]]]
            [none]]]

        [word match]
        [logq-abort form-to-ast not implemented match]

        [word do]
        [wuns/do [list-map arg [rest l] [form-to-ast arg]]]

        [word let]
        [wuns/let
          [list-map p [pairwise [slice l 1 [dec [size l]]]] [pair [form-to-word [first p]] [form-to-ast [second p]]]]
          [form-to-ast [last l]]]

        [word letrec]
        [wuns/letrec
          [list-map p [pairwise [slice l 1 [dec [size l]]]] [pair [form-to-word [first p]] [form-to-ast [second p]]]]
          [form-to-ast [last l]]]

        [word def]
        [wuns/def [form-to-word [second l]] [form-to-ast [third l]]]

        [word type]
        [wuns/type
          [list-map triple [triplewise [rest l]]
            [wuns-type-decl
              [form-to-word [first triple]]
              [list-map tv [form-to-list [second triple]] [form-to-word tv]]
              [form-to-type-decl-kind [third triple]]]]]

        [word type-anno]
        [logq-abort form-to-ast not implemented type-anno]

        [wuns/call-word fw [rest l]]]

      [form/list fl]
      [wuns/call [form-to-ast [first l]] [list-map arg [rest l] [form-to-ast arg]]]]]]
