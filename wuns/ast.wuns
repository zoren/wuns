[load std.wuns]

[type wuns-func-kind [] [union [func] [fexpr] [macro]]]

[type wuns-type []
  [union
    [word word]
    [apply word [list wuns-type]]]]

[type wuns-type-decl-kind []
  [union
    [union [list [pair word [list wuns-type]]]]
    [record [list [pair word wuns-type]]]]]

[type wuns-type-decl []
  [record
    [name word]
    [type-params [list word]]
    [kind wuns-type-decl-kind]]]

[type match-pattern [] [record [ctor word] [params [list word]]]]

[type wuns []
  [union
    [var word]
    [i32 word]
    [f64 word]
    [word word]
    [intrinsic word]
    [if wuns wuns wuns]
    [switch wuns [list [pair [list wuns] wuns]] [option wuns]]
    [match wuns  [list [pair match-pattern wuns]] [option wuns]]
    [do [list wuns]]
    [let [list [pair word wuns]] wuns]
    [letrec [list [pair word wuns]] wuns]
    [def word wuns]
    [func wuns-func-kind word [list word] [option word] wuns]
    [call wuns [list wuns]]
    [call-word word [list form]]
    [extern [list word]]
    [type [list wuns-type-decl]]
    ]]

[defn parse-param-words [param-words]
  [let [s [size param-words]]
    [if [and [lt-s 1 s] [eq-word [at param-words -2] [word ..]]]
      [pair [slice param-words 0 [sub s 2]] [some [last param-words]]]
      [pair param-words [none]]]]]

[defn form-to-type [form]
  [match form
    [form/word w]
    [wuns-type/word w]

    [form/list l]
    [do
      [assert [not [is-empty l]] type form-to-type is empty]
      [wuns-type/apply
        [form-to-word [first l]]
        [list-map arg [slice l 1 [size l]] [form-to-type arg]]]]]]

[defn form-to-type-decl-kind [form]
  [match form
    [form/list l]
    [do
      [assert [not [is-empty l]] type decl kind form is empty]
      [switch [form-to-word [first l]]
        [word union]
        [wuns-type-decl-kind/union
          [list-map ctor [slice l 1 [size l]]
            [let-do [ctor-list [form-to-list ctor]]
              [assert [not [is-empty ctor-list]] type decl kind union ctor is empty]
              [pair
                [form-to-word [first ctor-list]]
                [list-map arg [rest ctor-list] [form-to-type arg]]]]]]

        [word record]
        [logq-abort form-to-type-decl-kind not implemented record]

        [logq-abort form-to-type-decl-kind not implemented]]]

    [logq-abort form-to-type-decl-kind not implemented]]]

[defn form-to-lit [form]
  [match form
    [form/list l]
    [do
      [assert [eq 2 [size l]] lit form-to-lit size is not 2]
      [switch [form-to-word [first l]]
        [word i32] [wuns/i32 [form-to-word [second l]]]
        [word f64] [wuns/f64 [form-to-word [second l]]]
        [word word] [wuns/word [form-to-word [second l]]]
        [logq-abort form-to-lit not implemented [identity form]]]]
    [logq-abort form-to-lit not implemented word [identity form]]]]

[defn form-to-literal-list [form]
  [match form
    [form/list l]
    [if [is-empty l]
      [list]
      [match [first l]
        [form/word w] [list [form-to-lit form]]
        [list-map arg l [form-to-lit arg]]]]
    [logq-abort form-to-literal-list not implemented]]]

[type report-message []
  [record
    [message form]
    [form form]]]

[type form-to-ast-converter []
  [record
    [form-to-ast [func [form] wuns]]
    [errors [atom [linked-list report-message]]]]]

[defn mk-form-to-ast []
  [let
    [errors [atom [linked-list/nil]]
     get-word
     [func gw [form]
      [match form
        [form/word w] w
        [do
          [push errors [report-message [quote [expected word]] form]]
          [word 0]]]]
     form-to-ast
     [func form-to-ast [form]
      [let [report-error [func r [msg] [push errors [report-message msg form]]]]
        [match form
        [form/word w]
        [wuns/var w]

        [form/list l]
        [let [n-of-args [dec [size l]]
              get-arg [func get-arg [i]
                        [if [lt-s i n-of-args]
                          [at l [inc i]]
                          [quote 0]]]]
        [match [first l]
          [form/word fw]
          [switch fw
            [word i32]
            [wuns/i32 [get-word [get-arg 0]]]

            [word f64]
            [wuns/f64 [get-word [get-arg 0]]]

            [word word]
            [wuns/word [get-word [get-arg 0]]]

            [word extern]
            [wuns/extern [list-map w [rest l] [get-word w]]]

            [word intrinsic]
            [wuns/intrinsic [get-word [get-arg 0]]]

            [[word func] [word fexpr] [word macro]]
            [let [name [get-word [get-arg 0]]
                  parsed-params [parse-param-words [list-map p [form-to-list [get-arg 1]] [get-word p]]]
                  body-form [get-arg 2]]
              [wuns/func
                [switch fw
                  [word func]  [wuns-func-kind/func]
                  [word fexpr] [wuns-func-kind/fexpr]
                  [word macro] [wuns-func-kind/macro]
                  [logq-abort form-to-ast not implemented]]
                name
                [pair/fst parsed-params]
                [pair/snd parsed-params]
                [form-to-ast body-form]]]

            [word atom]
            [logq-abort form-to-ast not implemented atom]

            [word if]
            [do
              [when-not [eq n-of-args 3] [report-error [quote [if expects 3 arguments]]]]
              [wuns/if [form-to-ast [get-arg 0]] [form-to-ast [get-arg 1]] [form-to-ast [get-arg 2]]]]

            [word switch]
            [wuns/switch
              [form-to-ast [get-arg 0]]
              [list-map p [pairwise [slice l 2 [dec [size l]]]]
                [pair
                  [form-to-literal-list [first p]]
                  [form-to-ast [second p]]]]
              [if [is-odd [size l]]
                [some [form-to-ast [last l]]]
                [none]]]

            [word match]
            [wuns/match
              [form-to-ast [get-arg 0]]
              [list-map p [pairwise [slice l 2 [size l]]]
                [pair
                  [let-do [pat-list [form-to-list [first p]]]
                    [assert [not [is-empty pat-list]] match pattern is empty]
                    [match-pattern
                      [get-word [first pat-list]]
                      [list-map arg [rest pat-list] [get-word arg]]]]
                  [form-to-ast [second p]]]]
              [if [is-odd [size l]]
                [some [form-to-ast [last l]]]
                [none]]]

            [word do]
            [wuns/do [list-map arg [rest l] [form-to-ast arg]]]

            [word let]
            [wuns/let
              [list-map p [pairwise [slice l 1 [dec [size l]]]] [pair [get-word [first p]] [form-to-ast [second p]]]]
              [form-to-ast [last l]]]

            [word letrec]
            [wuns/letrec
              [list-map p [pairwise [slice l 1 [dec [size l]]]] [pair [get-word [first p]] [form-to-ast [second p]]]]
              [form-to-ast [last l]]]

            [word def]
            [wuns/def [get-word [get-arg 0]] [form-to-ast [third l]]]

            [word type]
            [wuns/type
              [list-map triple [triplewise [rest l]]
                [wuns-type-decl
                  [get-word [first triple]]
                  [list-map tv [form-to-list [second triple]] [get-word tv]]
                  [form-to-type-decl-kind [third triple]]]]]

            [word type-anno]
            [logq-abort form-to-ast not implemented type-anno]

            [wuns/call-word fw [rest l]]]

          [form/list fl]
          [wuns/call [form-to-ast [first l]] [list-map arg [rest l] [form-to-ast arg]]]]]]]]]
  [form-to-ast-converter
    form-to-ast
    errors]]]

[defn form-to-wuns-ctor-calls [form]
  [match form
    [form/word w]
    [wuns/call [wuns/var [word form/word]] [list [wuns/word w]]]

    [form/list l]
    [wuns/call [wuns/var [word flist]]
      [list-map e l [form-to-wuns-ctor-calls e]]]]]
