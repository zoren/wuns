[import env mem [memory 0]]

[import env log-pointer [func [i32 i32] []]]
[import env log-i32 [func [i32] []]]

[constant -1 [i32.const -1]]
[constant 0 [i32.const 0]]
[constant 1 [i32.const 1]]
[constant 2 [i32.const 2]]
[constant 3 [i32.const 3]]
[constant 4 [i32.const 4]]

[defn is-between-inclusive [lower c upper]
  [and [i32.le-s lower c] [i32.le-s c upper]]]

[defn inc [x] [i32.add x 1]]
[defn not [c] [if c [i32.const 0] [i32.const 1]]]
[defn is-zero [x] [i32.eq x [i32.const 0]]]
[defn is-negative [x] [i32.lt-s x [i32.const 0]]]

[defn tag [p] [i32.load [memarg mem 0 offset 0 align 4] p]]
[defn size [p] [i32.load [memarg mem 0 offset 4 align 4] p]]

[constant tag-word [i32.const 1]]
[constant tag-list [i32.const 3]]

[defn is-word [f] [i32.eq [tag f] tag-word]]
[defn is-list [f] [i32.eq [tag f] tag-list]]

[defn log-word [w]
  [log-pointer [i32.add [i32.const 8] w] [size w]]]

[defn log-abort [w]
  [log-word w]
  [unreachable]]

[defn char-code-at [w i]
  [if [not [is-word w]] [log-abort [quote not-a-word]]]
  [if [is-negative i] [log-abort [quote negative-index]]]
  [if [i32.ge-s i [size w]] [log-abort [quote index-out-of-bounds]]]
  [i32.load8-s [memarg mem 0 offset 8 align 1] [i32.add w i]]]

[defn at [l i]
  [if [not [is-list l]] [log-abort [quote not-a-list]]]
  [if [is-negative i] [log-abort [quote negative-index]]]
  [if [i32.ge-s i [size l]] [log-abort [quote index-out-of-bounds]]]
  [i32.load [memarg mem 0 offset 8 align 4] [i32.add l [i32.mul i [i32.const 4]]]]]

[defn alloc-init []
  [if [i32.load [memarg mem 0 offset 0 align 4] [i32.const 0]] [log-abort [quote alloc-already-initialized]]]
  [i32.store [memarg mem 0 offset 0 align 4] [i32.const 0] wuns-active-mem-top]]

[defn not-is-address-aligned [x]
  [i32.and x [i32.const 3]]]

[defn align-address [x] [i32.and [i32.add 3 x] [i32.xor -1 3]]]

[defn alloc [size]
  [if [is-negative size] [log-abort [quote bump-alloc-size-must-be-positive]]]
  [if [is-zero size] [log-abort [quote bump-alloc-size-must-be-non-zero]]]
  [if [i32.gt-s size [i32.const 65536]] [log-abort [quote bump-alloc-size-too-large]]]
  [if [not-is-address-aligned size] [log-abort [quote bump-alloc-size-not-aligned]]]
  [let [current-top [i32.load [memarg mem 0 offset 0 align 4] [i32.const 0]]]
    [if [i32.eq current-top [i32.const 0]] [log-abort [quote alloc-memory-not-initialized]]]
    [if [not-is-address-aligned current-top] [log-abort [quote bump-alloc-current-top-not-aligned]]]
    [let [mem-size-bytes [i32.mul [memory.size 0] [i32.const 65536]]]
      [if [i32.gt-s current-top mem-size-bytes] [log-abort [quote bump-alloc-current-top-out-of-bounds]]]
      [let [new-top [i32.add current-top size]]
        [if [i32.gt-s new-top mem-size-bytes] [log-abort [quote bump-alloc-out-of-memory]]]
        [i32.store [memarg mem 0 offset 0 align 4] [i32.const 0] new-top]]]
    current-top]]

[constant tag-mutable-list [i32.const 7]]

[defn mutable-list-of-size [s]
  [if [is-negative s] [log-abort [quote mutable-list-of-size-size-must-be-positive]]]
  [let [p [alloc [i32.mul [i32.add s [i32.const 2]] [i32.const 4]]]]
    [i32.store [memarg mem 0 offset 0 align 4] p tag-mutable-list]
    [i32.store [memarg mem 0 offset 4 align 4] p s]
    p]]

[defn set-array [l i v]
  [if [not [i32.eq [tag l] tag-mutable-list]] [log-abort [quote set-array-not-a-mutable-list]]]
  [if [is-negative i] [log-abort [quote set-array-negative-index]]]
  [if [i32.ge-s i [size l]] [log-abort [quote set-array-index-out-of-bounds]]]
  [i32.store [memarg mem 0 offset 8 align 4] [i32.add l [i32.mul i [i32.const 4]]] v]]

[defn freeze-mutable-list [l]
  [if [not [i32.eq [tag l] tag-mutable-list]] [log-abort [quote freeze-mutable-list-not-a-mutable-list]]]
  [i32.store [memarg mem 0 offset 0 align 4] l tag-list]]

[defn stupid-gauss [n]
  [loop [i [i32.const 0] r [i32.const 0]]
    [if [i32.le-s i n]
      [continue r [i32.add i r] i [inc i]]
      r]]]

[defn alloc-word [n-bytes]
  [if [is-negative n-bytes] [log-abort [quote alloc-word-size-must-be-positive]]]
  [let [p [alloc [i32.add [align-address n-bytes] [i32.const 8]]]]
    [i32.store [memarg mem 0 offset 0 align 4] p tag-word]
    [i32.store [memarg mem 0 offset 4 align 4] p n-bytes]
    p]]

[defn word-byte-pointer [w] [i32.add w [i32.const 8]]]

[defn concat-words [w1 w2]
  [let [s1 [size w1] s2 [size w2]
        res [alloc-word [i32.add s1 s2]]]
    [memory.copy 0 [word-byte-pointer res] [word-byte-pointer w1] s1]
    [memory.copy 0 [i32.add [word-byte-pointer res] s1] [word-byte-pointer w2] s2]
    res]]

[defn char-code-to-word [cc]
  [let [w [alloc-word 1]]
    [i32.store8 [memarg mem 0 offset 8 align 1] w cc]
    w]]

[constant tag-growable-list [i32.const 9]]

[defn make-cap-buffer [capacity]
  [let [cap-buffer [alloc [i32.mul [i32.add [i32.const 1] capacity] 4]]]
    [i32.store [memarg mem 0 offset 0 align 4] cap-buffer capacity]
    cap-buffer]]

[defn growable-list-with-init-capacity [init-capacity]
  [if [i32.lt-s init-capacity 1] [log-abort [quote growable-list-with-init-capacity-capacity-must-greater-than-zero]]]
  [let [p [alloc [i32.const 12]]
        cap-buffer [make-cap-buffer init-capacity]]
    [i32.store [memarg mem 0 offset 0 align 4] p tag-growable-list]
    [i32.store [memarg mem 0 offset 4 align 4] p 0]
    [i32.store [memarg mem 0 offset 8 align 4] p cap-buffer]
    p]]

[defn growable-list []
  [growable-list-with-init-capacity [i32.const 16]]]

[defn push [g-list element]
  [if [not [i32.eq [tag g-list] tag-growable-list]] [log-abort [quote capacity-not-a-growable-list]]]
  [let [s [i32.load [memarg mem 0 offset 4 align 4] g-list]
        cap-buffer [i32.load [memarg mem 0 offset 8 align 4] g-list]
        cur-cap [i32.load [memarg mem 0 offset 0 align 4] cap-buffer]]
    [if [i32.ge-s s cur-cap]
      [let [new-cap-buffer [make-cap-buffer [i32.mul cur-cap 2]]]
        [memory.copy 0 [i32.add 4 new-cap-buffer] [i32.add 4 cap-buffer] [i32.mul cur-cap 4]]
        [i32.store [memarg mem 0 offset 8 align 4] g-list new-cap-buffer]]
      [i32.store [memarg mem 0 offset 4 align 4] [i32.add cap-buffer [i32.mul s 4]] element]]
    [i32.store [memarg mem 0 offset 4 align 4] g-list [i32.add s 1]]]]

[constant tag-atom [i32.const 11]]

[defn atom [v]
  [let [p [alloc [i32.const 8]]]
    [i32.store [memarg mem 0 offset 0 align 4] p tag-atom]
    [i32.store [memarg mem 0 offset 4 align 4] p v]
    p]]

[defn atom-get [a]
  [if [not [i32.eq [tag a] tag-atom]] [log-abort [quote atom-get-not-an-atom]]]
  [i32.load [memarg mem 0 offset 4 align 4] a]]

[defn atom-set [a v]
  [if [not [i32.eq [tag a] tag-atom]] [log-abort [quote atom-set-not-an-atom]]]
  [i32.store [memarg mem 0 offset 4 align 4] a v]]

[defn main []
  [log-word [quote hello]]
  [log-word [quote world]]
  [let [l [quote 123 abc xyz]]
    [log-word [at l [i32.const 0]]]
    [log-word [at l [i32.const 1]]]
    [log-word [at l [i32.const 2]]]]
  [alloc-init]
  [alloc [i32.const 4]]
  [let [mut-list [mutable-list-of-size 1]]
    [set-array mut-list [i32.const 0] [quote word-in-list]]
    [freeze-mutable-list mut-list]
    [log-word [at mut-list [i32.const 0]]]]
  [log-i32 [stupid-gauss [i32.const 10]]]
  [log-i32 [stupid-gauss [i32.const 100]]]
  [log-word [concat-words [quote 123] [quote abc]]]
  [log-i32 [size [quote 123]]]
  [log-word [char-code-to-word [i32.const 49]]]
  [let [a [atom [quote init-atom-val]]]
    [log-word [atom-get a]]
    [atom-set a [quote new-atom-val]]
    [log-word [atom-get a]]]
  [log-i32 [is-between-inclusive [i32.const 1] [i32.const 2] [i32.const 3]]]
  [log-i32 [is-between-inclusive [i32.const 1] [i32.const 3] [i32.const 3]]]
  [log-i32 [is-between-inclusive [i32.const 1] [i32.const 4] [i32.const 3]]]
  [log-i32 [and]]
  [log-i32 [or]]
  [log-pointer [active-data [i8 65 66 67 68]] 4]
  [log-word [form-to-bytes wbm]]
  [log-word [quote qwr]]
  [log-i32 [size [form-to-bytes 123123213]]]
  [log-i32 [size [form-to-bytes []]]]
  [log-i32 [size [form-to-bytes [a b c]]]]
  [log-i32 [at [form-to-bytes [a]] 0]]
  [log-word [at [form-to-bytes [a]] 0]]

  ]
