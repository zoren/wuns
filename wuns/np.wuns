[import env mem [memory 0]]

[defmacro s32 [addr val] [list [quote i32.store] [quote 0] [quote 2] [quote 0] addr val]]
[defmacro s32-offset [offset addr val] [list [quote i32.store] [quote 0] [quote 2] offset addr val]]
[defmacro l32 [addr] [list [quote i32.load] [quote 0] [quote 2] [quote 0] addr]]
[defmacro l32-offset [offset addr] [list [quote i32.load] [quote 0] [quote 2] offset addr]]

[defn bump-alloc-init []
  [if [eq [l32 [const 0]] [const 0]]
    [s32 [const 0] [const 16]]
    [unreachable]]]

[defn bump-free [p size]
  [let [current-top [l32 [const 0]]
        popped-top [sub current-top size]]
    [if [eq popped-top p]
      [s32 [const 0] popped-top]
      [unreachable]]]]

[defn try-bump-free [p size] []
  [let [current-top [l32 [const 0]]
        popped-top [sub current-top size]]
    [when [eq popped-top p]
      [s32 [const 0] popped-top]]]]

[defn mk-i32 [x] [list [quote i32.const] x]]

[def mem-alloc-size [quote 4]]

[defmacro not-is-address-aligned [x]
  [list [quote bitwise-and] [mk-i32 [dec mem-alloc-size]] x]]

[comment maybe memset newly allocated memory to zero]
[defn bump-alloc [size]
  [if [le size [i32.const 0]] [unreachable]]
  [if [gt size [i32.const 65536]] [unreachable]]
  [if [not-is-address-aligned size] [unreachable]]
  [let
    [current-top [l32 [i32.const 0]]
     - [if [eq current-top [i32.const 0]] [unreachable]]
     - [if [not-is-address-aligned current-top] [unreachable]]
     mem-size-bytes [bitwise-shift-left [memory.size 0] [i32.const 16]]
     - [if [gt current-top mem-size-bytes] [unreachable]]
     new-top [add current-top size]]
    [if [gt new-top mem-size-bytes] [unreachable]]
    [s32 [i32.const 0] new-top]
    current-top]]

[defn is-power-of-2 [x] [eq [quote 0] [bitwise-and x [dec x]]]]

[defn align [n x]
  [assert n must not be zero]
  [assert [is-power-of-2 n] must be power of 2]
  [let [dn [dec n]]
    [list [quote bitwise-and]
      [list [quote add] [mk-i32 dn] x]
      [mk-i32 [bitwise-xor [i32.const -1] dn]]]]]

[defmacro mem-align [x] [align mem-alloc-size x]]

[import env log-size-pointer [func [i32 i32 i32] []]]

[defn test-log []
  [let [start [i32.const 32]
        end [i32.const 127]
        s [sub end start]
        alloc-size [mem-align s]
        p [bump-alloc alloc-size]]
    [loop [i [i32.const 0]]
      [when [lt i s]
        [store8 0 0 0 [add p i] [add start i]]
        [continue i [add i [i32.const 1]]]]]
    [log-size-pointer 0 s p]
    [bump-free p alloc-size]]]

[defn byte-size [type]
  [ifs
    [eq-word [quote i8] type]
    [i32.const 1]

    [eq-word [quote i16] type]
    [i32.const 2]

    [eq-word [quote i32] type]
    [i32.const 4]

    [log-abort unknown type [identity type]]]]

[comment [handle memory [pointer ui8] n-bytes] [err-no n-of-read-bytes]]
[import env read [func [i32 i32 i32 i32] [i32 i32]]]
[import env read-bytes [func [i32 i32 i32 i32 i32] [i32 i32]]]

[defn is-whitespace [c]
  [or [eq c [quote 32]] [eq c [quote 10]]]]

[defn is-between-inclusive [lower c upper]
  [and [le lower c] [le c upper]]]

[defn is-a-to-z [c]
  [is-between-inclusive [quote 97] c [quote 122]]]

[defn is-digit-and-some [c]
  [comment - . / 0 1 2 3 4 5 6 7 8 9]
  [is-between-inclusive [quote 45] c [quote 57]]]

[defn is-word-char [c]
  [or
    [is-a-to-z c]
    [is-digit-and-some c]]]

[defn is-square-bracket [c]
  [or [eq c [quote 91]] [eq c [quote 93]]]]

[defn is-illegal [c]
  [not [or
    [is-word-char c]
    [is-whitespace c]
    [is-square-bracket c]]]]

[defn scan-word-char [start end]
  [loop [j start]
    [if [and [lt j end] [is-word-char [load8-u 0 0 0 j]]]
      [continue j [inc j]]
      j]]]

[defn scan-whitespace [start end]
  [loop [j start]
    [if [and [lt j end] [is-whitespace [load8-u 0 0 0 j]]]
      [continue j [inc j]]
      j]]]

[defn scan-illegal [start end]
  [loop [j start]
    [if [and [lt j end] [is-illegal [load8-u 0 0 0 j]]]
      [continue j [inc j]]
      j]]]

[defn shift-input-buffer [buffer cur]
  ]

[defn create-size-buffer [capacity]
  [let [p [bump-alloc [add 4 capacity]]]
    [s32 p capacity]
    p]]

[comment a i32 size and a pointer to a buffer that has buffer size and ]
[defn create-growable-list [initial-size]
  [let [p [bump-alloc [const 8]]]
    [s32 p [i32.const 0]]
    [s32-offset 4 p [create-size-buffer initial-size]]
    p]]

[defn get-size [list]
  [let [s [l32 list]]
    [when [is-negative s] [unreachable]]
    s]]

[defn get-capacity [list] [l32 [l32-offset 4 list]]]

[defn push-n-bytes [list n-bytes]
  [assert [not [is-negative n-bytes]] size must not be negative]
  [let [size [get-size list]
        new-size [add size n-bytes]
        buffer [l32-offset 4 list]
        buffer-capacity [l32 buffer]]
    [s32 list new-size]
    [when [gt new-size buffer-capacity]
      [let [new-buffer [create-size-buffer [add buffer-capacity buffer-capacity]]]
        [memory.copy 0 [add new-buffer 4] [add buffer 4] size]
        [try-bump-free buffer [add 4 buffer-capacity]]
        [s32-offset 4 list new-buffer]]]]]

[defn pop-n-bytes [list n-bytes]
  [assert [not [is-negative n-bytes]] size must not be negative]
  [let [size [get-size list]
        new-size [sub size n-bytes]
        buffer [l32-offset 4 list]]
    [assert [not [is-negative new-size]] cannot pop more than what is in the list]
    [s32 list new-size]]]

[defn push-i32 [list i]
  [push-n-bytes list 4]
  [let [size [l32 list]
        buffer [l32 [add list 4]]]
    [s32 [add buffer size] i]]]

[defn at-i32 [list i]
  [when [is-negative i] [unreachable]]
  [when [ge i [div [get-size list] 4]] [unreachable]]
  [l32-offset 4 [add [l32-offset 4 list] [mul i 4]]]]

[defn test-list []
  [let [l [create-growable-list [const 4]]]
    [push-i32 l [const 10]]
    [push-i32 l [const 20]]
    [push-i32 l [const 30]]
    [list l [get-size l] [get-capacity l] [at-i32 l [const 0]] [at-i32 l 1] [at-i32 l 2]]]]

[defmacro l16 [addr] [list [quote i32.load16-u] [quote 0] [quote 1] [quote 0] addr]]

[defn lex-one-utf16 [p end]
  [when [ge p end] [unreachable]]
  [let [c [l16 p]]
    [ifs
      [is-word-char c]
      [loop [j [add 2 p]]
        [if [and [lt j end] [is-word-char [l16 j]]]
          [continue j [add 2 j]]
          [list [quote word] [sub j p]]]]

      [is-whitespace c]
      [loop [j [add 2 p]]
        [if [and [lt j end] [is-whitespace [l16 j]]]
          [continue j [add 2 j]]
          [list [quote wspc] [sub j p]]]]

      [eq c [const 91]]
      [list [quote lsqb] 2]

      [eq c [const 93]]
      [list [quote rsqb] 2]

      [loop [j [add 2 p]]
        [if [and [lt j end] [is-illegal [l16 j]]]
          [continue j [add 2 j]]
          [list [quote ille] [sub j p]]]]]]]

[defn create-terminal [tag size]
  [let [p [bump-alloc [const 8]]]
    [s32 p size]
    [s32-offset 4 p tag]
    p]]

[def list-tag [quote 5]]
[def root-tag [quote 7]]

[defn set-child-n [non-term n child]
  [s32-offset 8 [add non-term [mul n 4]] child]]

[defn get-node-size [node] [l32 node]]

[defn get-node-tag [node] [l32-offset 4 node]]

[defn get-node-number-of-children [node] [l32-offset 8 node]]

[defn get-node-child [node i]
  [let [n [get-node-number-of-children node]]
    [assert [lt i n] get-node-child i must be less than number of children]
    [l32-offset 12 [add node [mul i 4]]]]]

[defn sum-byte-sizes [nodes]
  [let [n [div [get-size nodes] 4]]
    [loop [i 0 sum 0]
      [if [lt i n]
        [let [child [at-i32 nodes i]]
          [continue
            i [inc i]
            sum [add sum [get-node-size child]]]]
        sum]]]]

[defn create-non-terminal-from-list [tag children]
  [let [s [get-size children]
        p [bump-alloc [add [const 12] s]]]
    [s32 p [sum-byte-sizes children]]
    [s32-offset 4 p tag]
    [s32-offset 8 p [div s 4]]
    [memory.copy 0 [add p [const 12]] [add 4 [l32-offset 4 children]] s]
    p]]

[defn last-i32 [list]
  [let [s [get-size list]]
    [assert [gt s 0] last-i32 list must not be empty]
    [at-i32 list [dec [div s 4]]]]]

[defn parse [start end]
  [let [root-children [create-growable-list [const 4]]
        stack [create-growable-list [const 4]]]
    [push-i32 stack root-children]
    [loop [p start]
      [when [lt p end]
        [let [c [l16 p]]
          [ifs
            [is-word-char c]
            [let [end [loop [q [add 2 p]] [if [is-word-char [l16 q]] [continue q [add 2 q]] q]]]
              [push-i32
                [last-i32 stack]
                [create-terminal [const 97] [sub end p]]]
              [continue p end]]

            [is-whitespace c]
            [let [end [loop [q [add 2 p]] [if [is-whitespace [l16 q]] [continue q [add 2 q]] q]]]
              [push-i32
                [last-i32 stack]
                [create-terminal [const 32] [sub end p]]]
              [continue p end]]

            [eq c [const 91]]
            [let [new-children-list [create-growable-list [const 8]]]
              [comment [if [there is already an empty list on the stack reuse it] [create-growable-list [const 8]]]]
              [push-i32 new-children-list [create-terminal [const 91] 2]]
              [push-i32 stack new-children-list]
              [continue p [add 2 p]]]

            [eq c [const 93]]
            [let [stack-size [div [get-size stack] 4]
                  top [at-i32 stack [dec stack-size]]]
              [push-i32 top [create-terminal [const 93] 2]]
              [when [lt 1 stack-size]
                [let [children [last-i32 stack]]
                  [pop-n-bytes stack 4]
                  [push-i32 [last-i32 stack] [create-non-terminal-from-list list-tag children]]]]
              [continue p [add 2 p]]]

            [let [end [loop [q [add 2 p]] [if [is-illegal [l16 q]] [continue q [add 2 q]] q]]]
              [push-i32
                [last-i32 stack]
                [create-terminal [const -1] [sub end p]]]
              [continue p end]]]]]]
    [comment [loop over the stack popping unclosed lists and creating non-terminals and freeing the temporary growable lists]]
    [create-non-terminal-from-list root-tag root-children]
    ]]

[comment
  states
  init 1
  whitespace 2
  word 97
  square-bracket-left 91
  square-bracket-right 93
  list 5]

[def buffer-size [quote 256]]

[defn fill [handle cur end]
  [read-bytes 0 handle cur [sub buffer-size [sub end cur]]]]

[defn parse-state [handle parent]
  [let [buffer [bump-alloc buffer-size]]
    []]]

[defn parse-root [handle]
  []]

