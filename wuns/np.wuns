[import env mem [memory 0]]

[defmacro s32 [addr val] [list [quote i32.store] [quote 0] [quote 2] [quote 0] addr val]]
[defmacro s32-offset [offset addr val] [list [quote i32.store] [quote 0] [quote 2] offset addr val]]
[defmacro l32 [addr] [list [quote i32.load] [quote 0] [quote 2] [quote 0] addr]]
[defmacro l32-offset [offset addr] [list [quote i32.load] [quote 0] [quote 2] offset addr]]

[defn bump-alloc-init []
  [if [eq [l32 [const 0]] [const 0]]
    [s32 [const 0] [const 16]]
    [unreachable]]]

[defn bump-free [p size]
  [let [current-top [l32 [const 0]]
        popped-top [sub current-top size]]
    [if [eq popped-top p]
      [s32 [const 0] popped-top]
      [unreachable]]]]

[defn try-bump-free [p size] []
  [let [current-top [l32 [const 0]]
        popped-top [sub current-top size]]
    [when [eq popped-top p]
      [s32 [const 0] popped-top]]]]

[defn mk-i32 [x] [list [quote i32.const] x]]

[def mem-alloc-size [quote 4]]

[defmacro not-is-address-aligned [x]
  [list [quote bitwise-and] [mk-i32 [dec mem-alloc-size]] x]]

[comment maybe memset newly allocated memory to zero]
[defn bump-alloc [size]
  [if [le size [i32.const 0]] [unreachable]]
  [if [gt size [i32.const 65536]] [unreachable]]
  [if [not-is-address-aligned size] [unreachable]]
  [let
    [current-top [l32 [i32.const 0]]
     - [if [eq current-top [i32.const 0]] [unreachable]]
     - [if [not-is-address-aligned current-top] [unreachable]]
     mem-size-bytes [bitwise-shift-left [memory.size 0] [i32.const 16]]
     - [if [gt current-top mem-size-bytes] [unreachable]]
     new-top [add current-top size]]
    [if [gt new-top mem-size-bytes] [unreachable]]
    [s32 [i32.const 0] new-top]
    current-top]]

[defn is-power-of-2 [x] [eq [quote 0] [bitwise-and x [dec x]]]]

[defn align [n x]
  [assert n must not be zero]
  [assert [is-power-of-2 n] must be power of 2]
  [let [dn [dec n]]
    [list [quote bitwise-and]
      [list [quote add] [mk-i32 dn] x]
      [mk-i32 [bitwise-xor [i32.const -1] dn]]]]]

[defmacro mem-align [x] [align mem-alloc-size x]]

[import env log-size-pointer [func [i32 i32 i32] []]]

[defn test-log []
  [let [start [i32.const 32]
        end [i32.const 127]
        s [sub end start]
        alloc-size [mem-align s]
        p [bump-alloc alloc-size]]
    [loop [i [i32.const 0]]
      [when [lt i s]
        [store8 0 0 0 [add p i] [add start i]]
        [continue i [add i [i32.const 1]]]]]
    [log-size-pointer 0 s p]
    [bump-free p alloc-size]]]

[defn byte-size [type]
  [ifs
    [eq-word [quote i8] type]
    [i32.const 1]

    [eq-word [quote i16] type]
    [i32.const 2]

    [eq-word [quote i32] type]
    [i32.const 4]

    [log-abort unknown type [identity type]]]]

[comment [handle memory [pointer ui8] n-bytes] [err-no n-of-read-bytes]]
[import env read [func [i32 i32 i32 i32] [i32 i32]]]
[import env read-bytes [func [i32 i32 i32 i32 i32] [i32 i32]]]

[defn is-whitespace [c]
  [or [eq c [quote 32]] [eq c [quote 10]]]]

[defn is-between-inclusive [lower c upper]
  [and [le lower c] [le c upper]]]

[defn is-a-to-z [c]
  [is-between-inclusive [quote 97] c [quote 122]]]

[defn is-digit-and-some [c]
  [comment - . / 0 1 2 3 4 5 6 7 8 9]
  [is-between-inclusive [quote 45] c [quote 57]]]

[defn is-word-char [c]
  [or
    [is-a-to-z c]
    [is-digit-and-some c]]]

[defn is-square-bracket [c]
  [or [eq c [quote 91]] [eq c [quote 93]]]]

[defn is-illegal [c]
  [not [or
    [is-word-char c]
    [is-whitespace c]
    [is-square-bracket c]]]]

[defn scan-word-char [start end]
  [loop [j start]
    [if [and [lt j end] [is-word-char [load8-u 0 0 0 j]]]
      [continue j [inc j]]
      j]]]

[defn scan-whitespace [start end]
  [loop [j start]
    [if [and [lt j end] [is-whitespace [load8-u 0 0 0 j]]]
      [continue j [inc j]]
      j]]]

[defn scan-illegal [start end]
  [loop [j start]
    [if [and [lt j end] [is-illegal [load8-u 0 0 0 j]]]
      [continue j [inc j]]
      j]]]

[defn shift-input-buffer [buffer cur]
  ]

[defn create-size-buffer [capacity]
  [let [p [bump-alloc [add 4 capacity]]]
    [s32 p capacity]
    p]]

[comment a i32 size and a pointer to a buffer that has buffer size and ]
[defn create-growable-list [initial-size]
  [let [p [bump-alloc [const 8]]]
    [s32 p [i32.const 0]]
    [s32-offset 4 p [create-size-buffer initial-size]]
    p]]

[defn get-size [list]
  [let [s [l32 list]]
    [when [is-negative s] [unreachable]]
    s]]

[defn get-capacity [list] [l32 [l32-offset 4 list]]]

[defn push-n-bytes [list n-bytes]
  [assert [not [is-negative n-bytes]] size must not be negative]
  [let [size [get-size list]
        new-size [add size n-bytes]
        buffer [l32-offset 4 list]
        buffer-capacity [l32 buffer]]
    [s32 list new-size]
    [when [gt new-size buffer-capacity]
      [let [new-buffer [create-size-buffer [add buffer-capacity buffer-capacity]]]
        [memory.copy 0 [add new-buffer 4] [add buffer 4] size]
        [try-bump-free buffer [add 4 buffer-capacity]]
        [s32-offset 4 list new-buffer]]]]]

[defn pop-n-bytes [list n-bytes]
  [assert [not [is-negative n-bytes]] size must not be negative]
  [let [size [get-size list]
        new-size [sub size n-bytes]
        buffer [l32-offset 4 list]]
    [assert [not [is-negative new-size]] cannot pop more than what is in the list]
    [s32 list new-size]]]

[defn push-i32 [list i]
  [push-n-bytes list 4]
  [let [size [l32 list]
        buffer [l32 [add list 4]]]
    [s32 [add buffer size] i]]]

[defn at-i32 [list i]
  [when [is-negative i] [unreachable]]
  [when [ge i [div [get-size list] 4]] [unreachable]]
  [l32-offset 4 [add [l32-offset 4 list] [mul i 4]]]]

[defn test-list []
  [let [l [create-growable-list [const 4]]]
    [push-i32 l [const 10]]
    [push-i32 l [const 20]]
    [push-i32 l [const 30]]
    [list l [get-size l] [get-capacity l] [at-i32 l [const 0]] [at-i32 l 1] [at-i32 l 2]]]]

[defmacro l16 [addr] [list [quote i32.load16-u] [quote 0] [quote 1] [quote 0] addr]]

[defn lex-one-utf16 [p end]
  [when [ge p end] [unreachable]]
  [let [c [l16 p]]
    [ifs
      [is-word-char c]
      [loop [j [add 2 p]]
        [if [and [lt j end] [is-word-char [l16 j]]]
          [continue j [add 2 j]]
          [list [quote word] [sub j p]]]]

      [is-whitespace c]
      [loop [j [add 2 p]]
        [if [and [lt j end] [is-whitespace [l16 j]]]
          [continue j [add 2 j]]
          [list [quote wspc] [sub j p]]]]

      [eq c [const 91]]
      [list [quote lsqb] 2]

      [eq c [const 93]]
      [list [quote rsqb] 2]

      [loop [j [add 2 p]]
        [if [and [lt j end] [is-illegal [l16 j]]]
          [continue j [add 2 j]]
          [list [quote ille] [sub j p]]]]]]]

[defn create-terminal [tag size]
  [let [p [bump-alloc [const 8]]]
    [s32 p size]
    [s32-offset 4 p tag]
    p]]

[def tag-list [quote 5]]
[def root-tag [quote 7]]

[defn set-child-n [non-term n child]
  [s32-offset 8 [add non-term [mul n 4]] child]]

[defn get-node-size [node] [l32 node]]

[defn get-node-tag [node] [l32-offset 4 node]]

[defn get-node-number-of-children [node] [l32-offset 8 node]]

[defn get-node-child [node i]
  [let [n [get-node-number-of-children node]]
    [assert [lt i n] get-node-child i must be less than number of children]
    [l32-offset 12 [add node [mul i 4]]]]]

[defn sum-byte-sizes [nodes]
  [let [n [div [get-size nodes] 4]]
    [loop [i 0 sum 0]
      [if [lt i n]
        [let [child [at-i32 nodes i]]
          [continue
            i [inc i]
            sum [add sum [get-node-size child]]]]
        sum]]]]

[defn create-non-terminal-from-list [tag children]
  [let [s [get-size children]
        p [bump-alloc [add [const 12] s]]]
    [s32 p [sum-byte-sizes children]]
    [s32-offset 4 p tag]
    [s32-offset 8 p [div s 4]]
    [memory.copy 0 [add p [const 12]] [add 4 [l32-offset 4 children]] s]
    p]]

[defn last-i32 [list]
  [let [s [get-size list]]
    [assert [gt s 0] last-i32 list must not be empty]
    [at-i32 list [dec [div s 4]]]]]

[def tag-word [const 97]]

[defn parse [start end]
  [let [root-children [create-growable-list [const 4]]
        stack [create-growable-list [const 4]]]
    [push-i32 stack root-children]
    [loop [p start]
      [when [lt p end]
        [let [c [l16 p]]
          [ifs
            [is-word-char c]
            [let [wend [loop [q [add 2 p]] [if [and [lt q end] [is-word-char [l16 q]]] [continue q [add 2 q]] q]]]
              [push-i32
                [last-i32 stack]
                [create-terminal tag-word [sub wend p]]]
              [continue p wend]]

            [is-whitespace c]
            [let [wend [loop [q [add 2 p]] [if [and [lt q end] [is-whitespace [l16 q]]] [continue q [add 2 q]] q]]]
              [push-i32
                [last-i32 stack]
                [create-terminal [const 32] [sub wend p]]]
              [continue p wend]]

            [eq c [const 91]]
            [let [new-children-list [create-growable-list [const 8]]]
              [comment [if [there is already an empty list on the stack reuse it] [create-growable-list [const 8]]]]
              [push-i32 new-children-list [create-terminal [const 91] 2]]
              [push-i32 stack new-children-list]
              [continue p [add 2 p]]]

            [eq c [const 93]]
            [let [stack-size [div [get-size stack] 4]
                  top [at-i32 stack [dec stack-size]]]
              [push-i32 top [create-terminal [const 93] 2]]
              [when [lt 1 stack-size]
                [let [children [last-i32 stack]]
                  [pop-n-bytes stack 4]
                  [push-i32 [last-i32 stack] [create-non-terminal-from-list tag-list children]]]]
              [continue p [add 2 p]]]

            [let [wend [loop [q [add 2 p]] [if [and [lt q end] [is-illegal [l16 q]]] [continue q [add 2 q]] q]]]
              [push-i32
                [last-i32 stack]
                [create-terminal [const -1] [sub wend p]]]
              [continue p wend]]]]]]
    [loop [stack-size [div [get-size stack] 4]]
      [when [lt 1 stack-size]
        [let [children [at-i32 stack [dec stack-size]]]
          [pop-n-bytes stack 4]
          [push-i32 [last-i32 stack] [create-non-terminal-from-list tag-list children]]]
        [continue stack-size [dec stack-size]]]]
    [create-non-terminal-from-list root-tag root-children]]]

[defn alloc-tagged-word [n-bytes]
  [let [p [bump-alloc [add [const 8] [mem-align n-bytes]]]]
    [s32 p tag-word]
    [s32-offset 4 p n-bytes]
    p]]

[defn is-word [form]
  [eq [l32 form] tag-word]]

[defn word-size [word]
  [l32-offset 4 word]]

[defn word-pointer [word]
  [add word [const 8]]]

[defn validate-word [word]
  [let [s [l32-offset 4 word]]
    [when [is-negative s] [unreachable]]
    [when [eq 0 s] [unreachable]]
    [when [not [eq [l32 word] tag-word]] [unreachable]]
    [loop [i 0]
      [when [lt i s]
        [when [not [is-word-char [load8-u 0 0 8 i]]]
          [unreachable]]
        [continue i [inc i]]]]
    s]]

[defn alloc-tagged-list [n-elements]
  [let [p [bump-alloc [add [const 8] [mul 4 n-elements]]]]
    [s32 p tag-list]
    [s32-offset 4 p n-elements]
    p]]

[defn is-list [form]
  [eq [l32 form] tag-list]]

[defn tag [form] [l32 form]]

[defn list-size [list]
  [l32-offset 4 list]]

[defn at-alloc-list [form i]
  [assert [is-list form] at-alloc-list form must be a list]
  [assert [not [is-negative i]] at-alloc-list i must not be negative]
  [let [s [list-size form]]
    [assert [lt i s] at-alloc-list i must be less than the size of the list]
    [l32-offset 8 [add form [mul i 4]]]]]

[defn number-of-word-or-list [node]
  [let [n-children [get-node-number-of-children node]]
    [loop [i 0 sum 0]
      [if [ge i n-children]
        sum
        [let [child [get-node-child node i]
              tag [get-node-tag child]]
          [if [or [eq tag tag-word] [eq tag tag-list]]
            [continue i [inc i] sum [inc sum]]
            [continue i [inc i]]]]]]]]

[defn node-to-form [text node]
  [let [tag [get-node-tag node]]
    [ifs
      [eq tag tag-word]
      [let [s [get-node-size node]
            tw [alloc-tagged-word s]]
        [memory.copy 0 [word-pointer tw] text s]
        tw]

      [eq tag tag-list]
      [let [n-form-children [number-of-word-or-list node]
            tl [alloc-tagged-list n-form-children]
            n-children [get-node-number-of-children node]]
        [loop [p text node-index 0 form-index 0]
          [if [ge node-index n-children]
            tl
            [let [child [get-node-child node node-index]
                  s [get-node-size child]
                  form [node-to-form p child]]
              [if form
                [do
                  [s32-offset 8 [add tl [mul form-index 4]] form]
                  [continue p [add p s] node-index [inc node-index] form-index [inc form-index]]]
                [continue p [add p s] node-index [inc node-index]]]]]]]

       0]]]

[defn tree-to-forms [text node]
  [let [n-form-children [number-of-word-or-list node]
        gl [create-growable-list [mul 4 n-form-children]]
        n-children [get-node-number-of-children node]]
    [loop [p text node-index 0]
      [if [ge node-index n-children]
        gl
        [let [child [get-node-child node node-index]
              s [get-node-size child]
              form [node-to-form p child]]
          [when form [push-i32 gl form]]
          [continue p [add p s] node-index [inc node-index]]]]]]]
